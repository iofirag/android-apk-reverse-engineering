<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="AStarSearch">Algoritmo A*</string>
    <string name="AStarSearch0">O algoritmo \"A*\" (pronuncia-se A-estrela) foi uma melhoria do algoritmo de Dijkstra. Primeiro, vamos encontrar o caminho mais curto deste labirinto usando o algoritmo de Dijkstra.</string>
    <string name="AStarSearch1">Neste labirinto, podemos deduzir que o custo entre os nodos no grafo é 1.</string>
    <string name="AStarSearch10">Pode ser mais fácil de entender se pensarmos nos custos estimados que estabelecemos como representantes de cada altitude de ponto.</string>
    <string name="AStarSearch100">Ao definir uma estimativa de custo apropriado baseado no que é conhecido com antecedência e tratando-lhe como alternativa, pesquisas mais eficientes se tornam possíveis.</string>
    <string name="AStarSearch101">Tomando o custo atual do ponto de partida para a nossa localização atual + o custo estimado da nossa posição atual para o objetivo, nos dá o custo do ponto de partida para o destino.</string>
    <string name="AStarSearch11">O objetivo no canto inferior direito seria o ponto mais baixo, e o ponto no canto superior esquerdo com custo 8 seria o maior ponto. Descendo a colina sempre parece mais fácil que subi-la.</string>
    <string name="AStarSearch12">Ao explorar o labirinto, se tornarmos mais fácil a movimentação na direção de menor custo da mesma forma que é fácil se mover para baixo, conseguiremos alcançar o destino rapidamente.</string>
    <string name="AStarSearch13">Agora, vamos tentar resolver o labirinto usando o algoritmo A*.</string>
    <string name="AStarSearch14">Primeiro, consideramos o ponto de partida como totalmente explorado.</string>
    <string name="AStarSearch15">Calculamos então o custo de cada ponto cujo movimento é possível do ponto de partida.</string>
    <string name="AStarSearch16">Este custo é calculado como a soma do custo de se mover para esse ponto e o custo estimado para o destino.</string>
    <string name="AStarSearch17">Escolhemos um dos pontos com o menor custo.</string>
    <string name="AStarSearch18">O ponto escolhido é considerado totalmente explorado.</string>
    <string name="AStarSearch19">Novamente calculamos o custo de cada ponto para os quais podemos nos mover a partir do ponto totalmente explorado.</string>
    <string name="AStarSearch2">Sob esta premissa, vamos utilizar o algoritmo de Dijkstra para encontrar o caminho mais curto.</string>
    <string name="AStarSearch20">E mais uma vez escolhemos um dos pontos com o menor custo.</string>
    <string name="AStarSearch21">O ponto escolhido é considerado totalmente explorado.</string>
    <string name="AStarSearch22">Daqui em diante, as mesmas operações são repetidas até que o destino seja alcançado.</string>
    <string name="AStarSearch24">Comparado com o algoritmo de Dijkstra, fomos capazes de explorar o labirinto mais eficientemente.</string>
    <string name="AStarSearch25">O que podemos fazer para resolvermos o labirinto ainda mais eficientemente?</string>
    <string name="AStarSearch26">Vamos tentar usar o custo atual do menor caminho ao invés da distância linear.</string>
    <string name="AStarSearch28">Desta vez, alcançamos o objetivo escolhendo o menor caminho, sem usar caminhos desnecessários.</string>
    <string name="AStarSearch29">Realisticamente, não há um momento em que vamos saber o custo real do caminho mais curto. Se nós já soubéssemos o caminho mais curto, não haveria nenhuma razão para procurar, em primeiro lugar.</string>
    <string name="AStarSearch30">Como você pode ver, como a função heurística é determinada se torna um fator crucial para o uso do algoritmo A*.</string>
    <string name="AStarSearch31">Quanto mais perto a função heurística estiver do custo do caminho mais curto atual, mais eficiente será a resolução do labirinto.</string>
    <string name="AStarSearch32">Por outro lado, vamos dar uma olhada no que acontece quando a função heurística falha.</string>
    <string name="AStarSearch33">Aqui, por exemplo, apenas deixamos a função heurística no caminho mais curto e determinamos todos os outros custos como 0.</string>
    <string name="AStarSearch35">A eficiência da busca foi ainda pior do que seria usando o algoritmo de Dijkstra. Contudo, ainda assim o caminho mais curto foi encontrado corretamente.</string>
    <string name="AStarSearch36">Com o algoritmo A*, enquanto a função heurística custar menos ou igual ao menor custo do ponto atual para o destino, encontrar o caminho mais curto no labirinto é garantido, independentemente da eficiência.</string>
    <string name="AStarSearch37">Como um mau exemplo, vamos tentar determinar a função heurística para um valor maior que o menor custo do ponto atual até o objetivo.</string>
    <string name="AStarSearch38">Aqui, deixamos apenas a função heurística do caminho mais curto e determinamos como o dobro do seu valor anterior. Ao fazê-lo, superamos muito o custo mais baixo do ponto atual para o objetivo.</string>
    <string name="AStarSearch4">O caminho mais curto foi encontrado, mas em contrapartida houve travessia em praticamente todos os caminhos.</string>
    <string name="AStarSearch40">O algoritmo decidiu que sua busca estava encerrada, mas o caminho encontrado diferiu do caminho mais curto.</string>
    <string name="AStarSearch41">Deste modo, podemos ver que a maneira como você faz as configurações e atribuições de valores determina se o algoritmo A* é ou não um bom algoritmo.</string>
    <string name="AStarSearch42">Este algoritmo é normalmente usado em programação de jogos para fatores como um inimigo (inteligência artificial) que segue o jogador.</string>
    <string name="AStarSearch43">No entanto, o grande número de cálculos do algoritmo pode ter um efeito negativo na velocidade geral do jogo. Você precisará pensar sobre como usá-lo, seja combinando isso com outros algoritmos ou restringindo seu uso.</string>
    <string name="AStarSearch44">Isto conclui a explicação de algoritmo A*.</string>
    <string name="AStarSearch5">O algoritmo de Dijkstra leva em consideração apenas o custo do ponto de partida antes de se decidir para qual nodo moverá a seguir.</string>
    <string name="AStarSearch6">Por causa disso, ele vai para caminhos como os marcados com setas, não percebendo que eles estão indo ainda mais longe do destino.</string>
    <string name="AStarSearch7">O algoritmo A* não considera apenas o custo a partir do ponto de partida, mas o custo estimado do ponto atual para o destino também.</string>
    <string name="AStarSearch8">Este custo estimado pode ser definido livremente. Neste caso, os valores utilizados foram determinados circundando a distância linear a partir do destino, no canto inferior direito.</string>
    <string name="AStarSearch9">Este custo estimado manual e previamente é conhecido como \"função heurística\".</string>
    <string name="AStarSearchDescription">O \"Algoritmo A*\" é uma versão mais avançada do algoritmo de Dijkstra. Você pode estudar este tópico após comprar todos os algoritmos.</string>
    <string name="AboutDev">Sobre este app</string>
    <string name="AlgorithmText1">Criptografia RSA</string>
    <string name="AlgorithmText2">Criptografia de Curva Elíptica</string>
    <string name="AlreadyBought">Comprado</string>
    <string name="AlreadyBoughtRestore">Se você reinstalou o app ou o instalou em um outro dispositivo iOS, por favor, use a opção \"Restaurar histórico de compras\".</string>
    <string name="AlreadyBoughtRestoreAndroid">Se você reinstalou o app ou o instalou em um outro dispositivo Android, por favor, use a opção \"Restaurar histórico de compras\".</string>
    <string name="AppTitle">Algoritmos: Explicados e Animados</string>
    <string name="Array">Arrays</string>
    <string name="Array0">\"Arrays\" (ou vetores) são um tipo de estrutura de dados, e podem armazenar múltiplos valores.</string>
    <string name="Array1">Cada elemento pode ser acessado por seu índice (um número que denota sua ordem dentro dos dados).</string>
    <string name="Array10">Primeiro, reservamos um espaço adicional no fim do array.</string>
    <string name="Array11">A fim de liberar o espaço necessário para a adição, os dados são deslocados um elemento de cada vez.</string>
    <string name="Array13">O \"Verde\" é adicionado ao espaço vazio, completando a adição.</string>
    <string name="Array14">Inversamente, para remover o segundo elemento,</string>
    <string name="Array15">primeiro deletamos o elemento,</string>
    <string name="Array16">e então preenchemos o espaço em branco deslocando os dados um elemento por vez.</string>
    <string name="Array18">Finalmente, o espaço extra é deletado, completando a eliminação.</string>
    <string name="Array19">Isto conclui a explicação de arrays.</string>
    <string name="Array2">Os dados são armazenados sequencialmente na memória em posições consecutivas.</string>
    <string name="Array3">Pelo fato dos dados serem armazenados em posições consecutivas, os endereços da memória podem ser calculados usando seus índices, permitindo acesso aleatório de dados.</string>
    <string name="Array8">Outra característica de arrays é que adicionar ou deletar dados em locais específicos acarreta um grande custo comparado às listas.</string>
    <string name="Array9">Vamos adicionar o \"Verde\" para a 2ª posição.</string>
    <string name="BellmanFord">Algoritmo de Bellman-Ford</string>
    <string name="BellmanFord0">O algoritmo de \"Bellman-Ford\" é um algoritmo que encontra o caminho mais curto de um grafo.</string>
    <string name="BellmanFord1">Um valor inicial de custo é designado para cada ponto. O ponto de partida recebe 0, e todos os outros pontos são definidos como infinito.</string>
    <string name="BellmanFord10">Seguindo em frente, calculamos a direção oposta de chegar a B a partir de A.</string>
    <string name="BellmanFord11">O custo do ponto B é 9, então o custo a partir do ponto B para o ponto A é 9 + 9 = 18.</string>
    <string name="BellmanFord12">Quando comparamos este valor com o valor atual de A, descobrimos que o valor atual é menor, então o custo não é atualizado.</string>
    <string name="BellmanFord13">Quando se move de um ponto com maior custo para um ponto com menor custo, o custo daquela aresta não é atualizado enquanto seu custo for positivo.</string>
    <string name="BellmanFord14">As mesmas operações serão realizadas em todas as arestas. Cabe a nós escolher a ordem das arestas, mas desta vez, por convenção, faremos os cálculos partindo da aresta do lado esquerdo.</string>
    <string name="BellmanFord15">Selecionamos uma aresta...</string>
    <string name="BellmanFord150">Por exemplo, os caminhos mais curtos para o ponto C (1 movimento) e o ponto D (2 movimentos) foram encontrados.</string>
    <string name="BellmanFord16">e atualizamos seu custo.</string>
    <string name="BellmanFord17">Da mesma forma, selecionamos outra aresta...</string>
    <string name="BellmanFord18">e atualizamos seu custo.</string>
    <string name="BellmanFord19">Agora vemos que, caso se queira ir do ponto A para o ponto B, o custo fica menor passando pelo ponto C do que indo diretamente pelo ponto A.</string>
    <string name="BellmanFord2">Uma das arestas é selecionada. Por convenção, selecionamos a aresta A-B.</string>
    <string name="BellmanFord20">As atualizações de custo são realizadas em todas as arestas.</string>
    <string name="BellmanFord21">Uma rodada de atualizações foi realizada.</string>
    <string name="BellmanFord22">A operação de atualização é repetida em todas as arestas até que não ocorram mais atualizações de custo.</string>
    <string name="BellmanFord24">Não ocorrem mais atualizações de custo, então encerramos a operação.</string>
    <string name="BellmanFord25">Neste momento, a busca do algoritmo é encerrada, e o caminho mais curto a partir do ponto inicial até cada outro ponto foi encontrado.</string>
    <string name="BellmanFord26">Vamos pensar sobre por que o caminho mais curto é encontrado sob tais operações.</string>
    <string name="BellmanFord27">O cenário foi retornado ao seu estado inicial.</string>
    <string name="BellmanFord28">Desta vez, vamos realizar a atualização para todas as arestas na ordem oposta, ou seja, das arestas do lado direito, de modo que as arestas vindas do ponto de partida, A, sejam atualizadas por último.</string>
    <string name="BellmanFord3">O custo de cada travessia de ponta a ponta dentro da aresta selecionada é calculado. O cálculo é realizado pegando o custo do valor inicial + o custo do movimento.</string>
    <string name="BellmanFord30">Uma rodada de atualizações foi realizada.</string>
    <string name="BellmanFord31">Podemos ver que depois de uma rodada de operações, apenas os custos dos pontos alcançáveis a partir de A em 1 movimento foram atualizados.</string>
    <string name="BellmanFord32">Tentaremos uma segunda rodada de atualizações.</string>
    <string name="BellmanFord34">A segunda rodada de atualizações foi realizada.</string>
    <string name="BellmanFord35">Podemos ver que depois de duas rodadas de operações, apenas os custos dos pontos alcançáveis a partir de A em 2 movimentos foram atualizados.</string>
    <string name="BellmanFord36">Na verdade, após realizar a operação de atualização N vezes, é garantido que os caminhos mais curtos serão encontrados para todos os pontos em N movimentos ou menos do ponto de partida A.</string>
    <string name="BellmanFord37">O diagrama teve duas rodadas de atualizações, então os caminhos mais curtos do ponto de partida para todos os pontos em até 2 movimentos terão sido encontrados.</string>
    <string name="BellmanFord38">Os caminhos mais curtos são apenas para pontos com 2 ou menos movimentos de distância, então mesmo que o caminho para o ponto F por A-C-D-F tenha um custo menor, são necessários 3 movimentos, então ele não é considerado.</string>
    <string name="BellmanFord39">Além disso, apesar de ter sido descoberto que o caminho mais curto para o ponto B leva 3 movimentos, isso foi descoberto apenas em virtude da ordem em que as arestas foram atualizadas.</string>
    <string name="BellmanFord4">O cálculo é realizado uma direção de cada vez. Para qualquer direção é válido; por convenção, nesta explicação, vamos calcular primeiro a direção do ponto com menor custo para o ponto com maior custo.</string>
    <string name="BellmanFord40">Em outras palavras, dependendo da ordem em que as arestas são atualizadas, há vezes em que caminhos mais curtos são descobertos requerendo mais movimentos que o número de rodadas de atualizações.</string>
    <string name="BellmanFord41">Então, dado que os caminhos mais curtos em N ou menos movimentos são encontrados após N operações de atualizações serem realizadas, quantas vezes devemos realizar a operação de atualização?</string>
    <string name="BellmanFord42">Dado N pontos, e dado que não voltamos ao mesmo ponto novamente, estamos seguros de poder chegar a todos os pontos em N-1 movimentos.</string>
    <string name="BellmanFord43">Isso quer dizer que, se realizarmos N-1 atualizações, no máximo, os menores caminhos para todos os pontos serão encontrados.</string>
    <string name="BellmanFord44">Além disso, se ao longo do caminho não ocorrerem mais atualizações, podemos dizer que todos os caminhos mais curtos foram determinados, e a operação acaba ali.</string>
    <string name="BellmanFord45">Agora, vamos continuar com as atualizações para o diagrama até que todos os caminhos mais curtos sejam encontrados.</string>
    <string name="BellmanFord47">Não há mais atualizações a serem feitas, então a operação é finalizada.</string>
    <string name="BellmanFord48">Fomos capazes de obter os caminhos mais curtos para todos os pontos, assim como antes.</string>
    <string name="BellmanFord49">Ademais, mesmo se o custo diferir entre os caminhos que vão e voltam entre A e B, como no grafo, e mesmo se apenas uma travessia de mão única for possível, como no caso das outras arestas...</string>
    <string name="BellmanFord5">O custo atual do ponto A é menor, então calcularemos primeiro a travessia do ponto A para o ponto B.</string>
    <string name="BellmanFord50">o algoritmo de Bellman-Ford ainda consegue encontrar os caminhos mais curtos corretamente.</string>
    <string name="BellmanFord51">Grafos cuja direção das arestas é fixa, como no diagrama, são chamados de \"grafos orientados\" (digrafos), e grafos onde a direção das arestas não é fixa são chamados de \"grafos não orientados\".</string>
    <string name="BellmanFord52">Então, o que acontece quando há alguns \"custos negativos\" também?</string>
    <string name="BellmanFord53">\"Custo negativo\" referiria ao -3 na aresta C-B do diagrama.</string>
    <string name="BellmanFord54">É difícil imaginar o que significa o custo ter valor negativo...</string>
    <string name="BellmanFord55">mas por exemplo, vamos imaginar que estamos em movimento em um carro do ponto de partida A até o ponto final G. Podemos pensar em cada custo como a quantidade de combustível consumido.</string>
    <string name="BellmanFord56">Nesta situação, fica mais fácil de entender se pensarmos que há um posto de gasolina aonde podemos abastecer o combustível na área com o custo negativo.</string>
    <string name="BellmanFord57">Com o algoritmo de Bellman-Ford, mesmo em situações como esta, que incorporam custos negativos, os caminhos mais curtos são corretamente encontrados.</string>
    <string name="BellmanFord58">Então, o que aconteceria se o custo negativo da aresta C-B do grafo for de -3 para -6?</string>
    <string name="BellmanFord59">Aparentemente o caminho mais curto seria encontrado sem problema...</string>
    <string name="BellmanFord6">O custo do ponto A é 0, então o custo de partir do ponto A para o ponto B é 0 + 9 = 9.</string>
    <string name="BellmanFord60">mas o custo total para uma viagem cíclica entre A-C-B é -1.</string>
    <string name="BellmanFord61">Caminhos como este são chamados de \"ciclos negativos\".</string>
    <string name="BellmanFord62">Quando há um ciclo negativo, você pode fazer o custo abaixar e abaixar sem fim, andando em círculos por volta destes pontos.</string>
    <string name="BellmanFord63">Portanto, não há como encontrar o caminho mais curto.</string>
    <string name="BellmanFord64">Ao tentar achar o menor caminho neste grafo com o algoritmo de Bellman-Ford, não importa quantas vezes você faça atualizações, o valor de algum ponto mudará, de modo que a operação nunca acabará.</string>
    <string name="BellmanFord65">Na verdade, com o algoritmo de Bellman-Ford, as atualizações deveriam ser concluídas depois de (número de pontos - 1) operações, então...</string>
    <string name="BellmanFord66">se o número de atualizações corresponder ou ultrapassar N vezes, significa que há um ciclo negativo em algum lugar do grafo.</string>
    <string name="BellmanFord67">Como você acabou de ver, o algoritmo de Bellman-Ford é um algoritmo com grande quantidade de cálculos, mas encontra os caminhos mais curtos mesmo quando há custos negativos...</string>
    <string name="BellmanFord68">e pode também detectar quando há um ciclo negativo.</string>
    <string name="BellmanFord69">Isto conclui a explicação de algoritmo de Bellman-Ford.</string>
    <string name="BellmanFord7">Se o resultado for menor que o valor atual, o custo é atualizado para o novo valor.</string>
    <string name="BellmanFord8">O valor atual de B é infinito, então o custo é atualizado para 9.</string>
    <string name="BellmanFord9">Quando um valor é atualizado, registramos o caminho e de qual ponto teve início. No diagrama, o caminho é mostrado em laranja.</string>
    <string name="BinarySearch">Busca Binária</string>
    <string name="BinarySearch0">A \"Busca Binária\" é um algoritmo para buscar por elementos de um array já ordenado.</string>
    <string name="BinarySearch1">Vamos tentar procurar o número 6.</string>
    <string name="BinarySearch10">Olhamos para o número do centro do array restante. Desta vez é o 6.</string>
    <string name="BinarySearch11">6 = 6, então o número que buscamos foi encontrado.</string>
    <string name="BinarySearch12">Deste modo, vemos que a busca binária faz uso de um array já ordenado e divide o array em outros arrays menores, permitindo buscar por números eficientemente.</string>
    <string name="BinarySearch13">Isto conclui a explicação da busca binária.</string>
    <string name="BinarySearch2">Primeiro, olhamos para o número do centro do array. Neste caso, é o número 5.</string>
    <string name="BinarySearch3">Comparamos o número 5 com o número 6 que estamos procurando. Por 5 ser menor do que 6, sabemos que o 6 está à direita do 5.</string>
    <string name="BinarySearch4">A partir dos candidatos, removemos os números não mais necessários.</string>
    <string name="BinarySearch6">Novamente, olhamos para o número do centro do array restante. Desta vez é o 7.</string>
    <string name="BinarySearch7">Comparamos 7 com 6. Por 6 ser menor do que 7, sabemos que o número 6 está para a esquerda de 7.</string>
    <string name="BinarySearch8">A partir dos candidatos, removemos os números não mais necessários.</string>
    <string name="BinaryTree">Árvores Binárias de Busca</string>
    <string name="BinaryTree0">\"Árvores binárias de busca\" são um tipo de estrutura de dados.</string>
    <string name="BinaryTree1">Os pontos numerados são chamados de \"nodos\".</string>
    <string name="BinaryTree10">Por outro lado, o maior nodo da árvore binária de busca está localizado no final da linha da subárvore mais à direita, proveniente do nodo mais alto.</string>
    <string name="BinaryTree11">Vamos dar uma olhada no processo de adição de nodos à árvore binária de busca.</string>
    <string name="BinaryTree12">Como exemplo, vamos tentar adicionar o 1.</string>
    <string name="BinaryTree13">Começamos do nodo mais alto da árvore binária de busca, de modo a encontrar a localização apropriada do nodo adicional.</string>
    <string name="BinaryTree14">1 é menor que 15, então ele passa para a esquerda.</string>
    <string name="BinaryTree16">1 é menor que 9, então novamente ele passa para a esquerda.</string>
    <string name="BinaryTree18">1 é menor que 3, então ele passa para a esquerda mais uma vez, mas como não há nodo aonde possa ir, o 1 é adicionado como um novo nodo.</string>
    <string name="BinaryTree2">As árvores binárias de busca possuem duas propriedades.</string>
    <string name="BinaryTree20">A adição do 1 está completa.</string>
    <string name="BinaryTree21">A seguir, vamos tentar adicionar o 4.</string>
    <string name="BinaryTree22">Como antes, começamos do nodo mais alto da árvore binária de busca, de modo a encontrar a localização apropriada do nodo adicional.</string>
    <string name="BinaryTree23">4 é menor que 15, então ele passa para a esquerda.</string>
    <string name="BinaryTree25">4 é menor que 9, então mais uma vez passa para a esquerda.</string>
    <string name="BinaryTree27">4 é maior que 3, então ele passa para a direita.</string>
    <string name="BinaryTree29">4 é menor que 8, então ele passa para a esquerda mais uma vez, mas como não há nodo aonde possa ir, o 4 é adicionado como um novo nodo.</string>
    <string name="BinaryTree3">A primeira propriedade é que todos os nodos são maiores que os nós em sua subárvore à esquerda.</string>
    <string name="BinaryTree31">A adição do 4 está completa.</string>
    <string name="BinaryTree32">Agora vamos observar o processo de exclusão de nodos de uma árvore binária de busca.</string>
    <string name="BinaryTree33">Como exemplo, vamos tentar deletar o 28.</string>
    <string name="BinaryTree34">Quando o nodo não tem filho...</string>
    <string name="BinaryTree35">o nodo alvo é simplesmente deletado e o processo está finalizado.</string>
    <string name="BinaryTree36">A seguir, vamos tentar deletar o 8.</string>
    <string name="BinaryTree37">Ao deletar um nodo que possui apenas 1 filho...</string>
    <string name="BinaryTree38">o nodo alvo é deletado...</string>
    <string name="BinaryTree39">e quando o nodo filho é movido à localização do nodo deletado, o processo está finalizado.</string>
    <string name="BinaryTree4">Por exemplo, o nodo 9 é maior que os outros números em sua subárvore esquerda.</string>
    <string name="BinaryTree40">Por último, vamos tentar deletar o 9.</string>
    <string name="BinaryTree41">Ao deletar um nodo que possui dois filhos...</string>
    <string name="BinaryTree42">primeiro deletamos o nodo alvo...</string>
    <string name="BinaryTree43">e da subárvore esquerda do nodo deletado nós encontramos o maior nodo...</string>
    <string name="BinaryTree44">e movemos ele para a localização do nodo deletado.</string>
    <string name="BinaryTree45">Ao fazer isso, fomos capazes de deletar um nodo ao mesmo tempo que preservamos a integridade da árvore binária de busca.</string>
    <string name="BinaryTree46">Ademais, se o nodo que foi movido também possuir seus próprios filhos, o mesmo processo é repetido recursivamente.</string>
    <string name="BinaryTree47">Dessa vez usamos o maior nodo da subárvore esquerda, mas usar o menor valor da subárvore direita também funciona.</string>
    <string name="BinaryTree48">Desta vez, vamos dar uma olhada no processo de procurar por um nodo em uma árvore binária de busca.</string>
    <string name="BinaryTree49">Como exemplo, vamos tentar encontrar o 12.</string>
    <string name="BinaryTree5">Semelhantemente, o nodo 15 é maior que os outros números em sua subárvore esquerda.</string>
    <string name="BinaryTree50">Começamos nossa busca no topo da árvore binária de busca.</string>
    <string name="BinaryTree51">12 é menor que 15, então passamos para a esquerda.</string>
    <string name="BinaryTree53">12 é maior que 4, então passamos para a direita.</string>
    <string name="BinaryTree55">Encontramos o 12.</string>
    <string name="BinaryTree56">Como você pode ver, fomos capazes de buscar eficientemente usando uma árvore binária de busca.</string>
    <string name="BinaryTree57">No entanto, se a árvore estiver próxima a se formar uma linha reta, sua eficiência de pesquisa torna-se extremamente pobre, como uma busca linear.</string>
    <string name="BinaryTree58">Por outro lado, uma árvore binária de busca que está sempre bem balanceada, chamada de \"árvore binária balanceada\", é capaz de manter a eficácia de busca.</string>
    <string name="BinaryTree59">Isto conclui a explicação de árvores binárias de busca.</string>
    <string name="BinaryTree6">Contrariamente, a segunda propriedade é que todos os nodos são menores que os nodos em sua subárvore à direita.</string>
    <string name="BinaryTree7">Por exemplo, o nodo 15 é menor que os outros números à subárvore direita.</string>
    <string name="BinaryTree8">Por causa dessas duas propriedades, o que vem a seguir é válido.</string>
    <string name="BinaryTree9">Primeiro, o menor nodo da árvore binária de busca está localizado no final da linha da subárvore mais à esquerda, derivada do nodo mais alto.</string>
    <string name="BinaryTreeDescription">\"Árvores Binárias de Busca\" são as árvores de busca mais básicas de todas. Você pode estudar este tópico após comprar todos os algoritmos.</string>
    <string name="BreadthFirstSearch">Busca em Largura</string>
    <string name="BreadthFirstSearch0">A \"Busca em largura\" (ou Breadth-First Search) é um algoritmo que busca através de grafos.</string>
    <string name="BreadthFirstSearch1">Vamos começar a procura com A como o ponto de partida e G como o objetivo.</string>
    <string name="BreadthFirstSearch11">Entre os candidatos, C e D foram os adicionados primeiramente. Entre estes dois, selecionamos o C, do lado esquerdo.</string>
    <string name="BreadthFirstSearch12">Movemos até o ponto selecionado.</string>
    <string name="BreadthFirstSearch13">H, alcançável do ponto atual, C, é adicionado como novo candidato.</string>
    <string name="BreadthFirstSearch14">Daqui em diante, as mesmas operações são repetidas até que o objetivo seja alcançado ou até todos os pontos terem sido inteiramente buscados.</string>
    <string name="BreadthFirstSearch2">Os pontos B, C e D, alcançáveis a partir de A, serão considerados candidatos para os próximos pontos possíveis.</string>
    <string name="BreadthFirstSearch3">Um ponto é selecionado entre os candidatos. A base para a seleção é qualquer um que tenha sido adicionado por primeiro como candidato.</string>
    <string name="BreadthFirstSearch38">O objetivo foi alcançado, então a busca é encerrada.</string>
    <string name="BreadthFirstSearch39">Como você pode ver, busca em largura é única em como procura amplamente por aqueles pontos mais próximos do ponto de partida.</string>
    <string name="BreadthFirstSearch4">Para pontos que se tornaram candidatos ao mesmo tempo, não importa qual será escolhido. Desta vez, por convenção, vamos selecionar pontos do lado esquerdo.</string>
    <string name="BreadthFirstSearch40">Isto conclui a explicação de busca em largura.</string>
    <string name="BreadthFirstSearch5">Como todos eles se tornaram candidatos ao mesmo tempo nesta instância, selecionaremos B.</string>
    <string name="BreadthFirstSearch6">Movemos até o ponto selecionado.</string>
    <string name="BreadthFirstSearch7">E e F, alcançáveis a partir do ponto atual, B, são adicionados como novos candidatos.</string>
    <string name="BreadthFirstSearch8">Os pontos dos candidatos são gerenciados sob o método \"First In First Out\" (FIFO, ou Primeiro que Entra, Primeiro que Sai), então é possível usar a estrutura de dados \"Fila\".</string>
    <string name="BreadthFirstSearch9">Uma explicação mais detalhada de fila pode ser encontrada em \"Filas\", na seção \"Estrutura da Dados\".</string>
    <string name="BubbleSort">Ordenação por Bolha</string>
    <string name="BubbleSort0">A \"Ordenação por Bolha\" (bubble) é um algoritmo usado para ordenar uma sequência de números.</string>
    <string name="BubbleSort1">Os indicadores na extremidade direita da sequência compararão os números aos seus lados esquerdo e direito.</string>
    <string name="BubbleSort16">Os indicadores chegaram à extremidade esquerda da sequência.</string>
    <string name="BubbleSort2">Neste caso, eles compararão 7 e 6.</string>
    <string name="BubbleSort20">Em um ciclo de operações, o menor valor da sequência foi movido para o começo da sequência, à esquerda.</string>
    <string name="BubbleSort21">O número na extremidade esquerda é considerado totalmente ordenado...</string>
    <string name="BubbleSort22">e os indicadores retornam para a extremidade direita.</string>
    <string name="BubbleSort23">As mesmas operações são repetidas até que todos os números sejam completamente ordenados.</string>
    <string name="BubbleSort25">A ordenação está completa.</string>
    <string name="BubbleSort26">Isto conclui a explicação de ordenação por bolha.</string>
    <string name="BubbleSort3">Depois de compará-los, se o número à direita for menor que o da esquerda, os números são trocados de lugar.</string>
    <string name="BubbleSort4">6 é menor do que 7, então os números foram trocados.</string>
    <string name="BubbleSort5">Depois que a comparação é feita, os indicadores são movidos uma posição à esquerda.</string>
    <string name="BubbleSort6">Os números são comparados novamente.</string>
    <string name="BubbleSort7">Desta vez, 6 é maior do que 4, então os números não são trocados.</string>
    <string name="BubbleSort8">Os indicadores são movidos uma posição à esquerda.</string>
    <string name="BubbleSort9">Esta operação é repetida até que a escala alcance a extremidade esquerda da sequência.</string>
    <string name="BuyAllAlgorithms">Adquira todos os algoritmos: %@</string>
    <string name="BuyAllAlgorithmsAndroid">Adquira todos os algoritmos:</string>
    <string name="CKC">Criptografia de Chave Privada</string>
    <string name="CKC0">A \"criptografia de chave privada\" (shared-key, ou simétrica) é um sistema de criptografia que usa a mesma chave para encriptação e decriptação.</string>
    <string name="CKC1">Vejamos a imagem mais ampla de como os dados são trocados usando a criptografia de chave privada.</string>
    <string name="CKC10">A parte B usa a chave para descriptografar o texto cifrado recebido da parte A.</string>
    <string name="CKC11">A parte B obteve os dados originais.</string>
    <string name="CKC12">Se você criptografar os dados, não há nada a se preocupar mesmo se uma parte maliciosa os interceptar.</string>
    <string name="CKC13">Usar a mesma chave para encriptação e decriptação é uma característica da criptografia de chave privada.</string>
    <string name="CKC14">No diagrama estão alguns cálculos usados na criptografia de chave privada.</string>
    <string name="CKC15">Hoje, o método \"AES\" é amplamente usado.</string>
    <string name="CKC16">A seguir, vamos pensar sobre alguns problemas com a criptografia de chave privada.</string>
    <string name="CKC17">Retornaremos brevemente à situação anterior. Agora, a parte B acaba de receber o texto cifrado enviado pela parte A.</string>
    <string name="CKC18">É possível que o texto cifrado tenha sido interceptado pela parte X.</string>
    <string name="CKC19">Agora, por causa das partes A e B não estarem diretamente cientes entre si na comunicação...</string>
    <string name="CKC2">Digamos que a parte A queira enviar dados para a parte B pela internet.</string>
    <string name="CKC20">vamos pensar sobre o que aconteceria se a parte B não soubesse a chave usada para a encriptação.</string>
    <string name="CKC21">A parte A precisa, de alguma maneira, entregar a chave para a parte B.</string>
    <string name="CKC22">Como eles fizeram com o texto cifrado, a parte A envia a chave para a parte B pela internet.</string>
    <string name="CKC23">A parte B, usando a chave recebida da parte A...</string>
    <string name="CKC24">foi capaz de descriptografar o texto cifrado.</string>
    <string name="CKC25">Contudo, é possível que a parte X intercepte a chave também.</string>
    <string name="CKC26">Se esse é o caso, a parte X também é capaz de usar a chave e descriptografar o texto cifrado.</string>
    <string name="CKC27">Podemos ver que há um problema em como esta chave é transmitida.</string>
    <string name="CKC28">Então, a parte A pensou em criptografar ela mesma a chave de modo que não faça diferença caso ela seja interceptada pela parte X.</string>
    <string name="CKC29">Para um computador, uma chave é nada mais que um pedaço de dados.</string>
    <string name="CKC3">Os dados são entregues para a parte B, passando por uma variedade de redes e dispositivos na internet.</string>
    <string name="CKC30">Assim sendo...</string>
    <string name="CKC31">podemos criptografá-la com uma chave nova.</string>
    <string name="CKC32">O texto cifrado contendo a chave...</string>
    <string name="CKC33">é enviado para a parte B.</string>
    <string name="CKC34">Agora, a parte B tem os dados criptografados assim como uma chave criptografada para descriptografar aqueles dados.</string>
    <string name="CKC35">Ainda há a chance da parte X interceptar a chave criptografada.</string>
    <string name="CKC36">Tudo o que resta agora é transmitir a nova chave usada para criptografar a chave para a parte B...</string>
    <string name="CKC37">mas como a parte A deveria mandar essa nova chave para a parte B?</string>
    <string name="CKC38">Sem criptografá-la, a parte X poderia também interceptar a chave nova e ser capaz de usá-la.</string>
    <string name="CKC39">Se criptografarmos ela, haverá uma nova chave, e o problema se repete.</string>
    <string name="CKC4">Portanto, se os dados são enviados como estão...</string>
    <string name="CKC40">Resumindo, a criptografia de chave privada requer um método seguro para transmissão de chaves.</string>
    <string name="CKC41">Isso é chamado de \"problema de entrega das chaves\".</string>
    <string name="CKC42">Há dois tipos de soluções para este problema: 1) métodos usando protocolos de troca de chave e 2) métodos usando criptografia de chave pública, cada qual explicada na seção \"Segurança\" em \"Troca de Chaves de Diffie-Hellman\" e \"Criptografia de Chave Pública\", respectivamente.</string>
    <string name="CKC43">Isto conclui a explicação de criptografia de chave privada.</string>
    <string name="CKC5">há uma chance de serem interceptados por uma terceira parte maliciosa.</string>
    <string name="CKC6">Por esta razão, faz-se necessário criptografar os dados que você deseja manter privados antes de enviá-los.</string>
    <string name="CKC7">Usando uma chave...</string>
    <string name="CKC8">os dados são criptografados em texto cifrado.</string>
    <string name="CKC9">O texto cifrado é enviado à parte B.</string>
    <string name="Cancel">Cancelar</string>
    <string name="CannotPayAlert">As compras estão restritas. Por favor, mude as configurações do seu dispositivo.</string>
    <string name="CannotRestoreAlert">O histórico de compras não pôde ser confirmado. Por favor, verifique se você está conectado na mesma conta iTunes que você usou para realizar a compra.</string>
    <string name="CannotRestoreAlertAndroid">O histórico de compras não pôde ser confirmado. Por favor, tenha a certeza de que você está conectado na mesma conta da loja Google Play que você usou quando efetuou a compra.</string>
    <string name="ChangeConfirmation">Você tem certeza de que deseja fazer essas mudanças?</string>
    <string name="ClusteringSection">Clusterização</string>
    <string name="CompressionSection">Compressão de Dados</string>
    <string name="Config">Configurações</string>
    <string name="DataStructureSection">Estruturas de Dados</string>
    <string name="DepthFirstSearch">Busca em Profundidade</string>
    <string name="DepthFirstSearch0">\"Busca em Profundidade\" (ou Depth-First Search) é um algoritmo que busca através de grafos.</string>
    <string name="DepthFirstSearch1">Vamos começar a procura com A como o ponto de partida e G como o objetivo.</string>
    <string name="DepthFirstSearch11">Entre os candidatos, E e F foram os adicionados por primeiro. Entre estes dois, selecionamos o E do lado esquerdo.</string>
    <string name="DepthFirstSearch12">Movemos até o ponto selecionado.</string>
    <string name="DepthFirstSearch13">K, alcançável do ponto atual, E, é adicionado como novo candidato.</string>
    <string name="DepthFirstSearch14">Daqui em diante, as mesmas operações são repetidas até que o objetivo seja alcançado ou que todos os pontos tenham sido inteiramente buscados.</string>
    <string name="DepthFirstSearch2">Os pontos B, C e D, alcançáveis a partir de A, serão considerados candidatos para os próximos pontos possíveis.</string>
    <string name="DepthFirstSearch28">O objetivo foi alcançado, então a busca é encerrada.</string>
    <string name="DepthFirstSearch29">Como você pode ver, busca em profundidade é única em como procura cavando mais fundo por um caminho específico.</string>
    <string name="DepthFirstSearch3">Um ponto é selecionado entre os candidatos. A base para a seleção é qualquer um que tenha sido adicionado por último como candidato.</string>
    <string name="DepthFirstSearch30">Isto conclui a explicação de busca em profundidade.</string>
    <string name="DepthFirstSearch4">Para pontos que se tornaram candidatos ao mesmo tempo, não importa qual será escolhido. Desta vez, por convenção, vamos selecionar pontos do lado esquerdo.</string>
    <string name="DepthFirstSearch5">Como todos eles se tornaram candidatos ao mesmo tempo nesta instância, selecionaremos B.</string>
    <string name="DepthFirstSearch6">Movemos até o ponto selecionado.</string>
    <string name="DepthFirstSearch7">E e F, alcançáveis a partir do ponto atual, B, são adicionados como novos candidatos.</string>
    <string name="DepthFirstSearch8">Os pontos dos candidatos são gerenciados sob o método \"Last In First Out\" (LIFO, ou Último que Entra, Primeiro que Sai), então é possível usar a estrutura de dados \"Pilha\".</string>
    <string name="DepthFirstSearch9">Uma explicação mais detalhada de pilhas pode ser encontrada em \"Pilhas\", na seção \"Estrutura da Dados\".</string>
    <string name="DiffieHellman">Troca de Chaves de Diffie-Hellman</string>
    <string name="DiffieHellman0">A \"troca de chaves de Diffie-Hellman\" é um método usado para a troca de chaves de forma segura entre 2 partes.</string>
    <string name="DiffieHellman1">Antes de usar fórmulas matemáticas para explicá-la, vamos começar com uma explicação mais conceitual usando um diagrama.</string>
    <string name="DiffieHellman10">pode ser usada como elemento para criar uma nova chave.</string>
    <string name="DiffieHellman11">No exemplo do diagrama, ao usar as chaves P e P-S, uma nova chave, P-P-S, foi criada.</string>
    <string name="DiffieHellman12">Em outras palavras, cada chave criada pode então ser combinada.</string>
    <string name="DiffieHellman13">Vamos tentar trocar as chaves entre a parte A e a parte B, de forma segura, usando este método de combinação.</string>
    <string name="DiffieHellman14">Primeiro, a parte A prepara a chave P. Esta chave P pode ser conhecida por qualquer um, sem problema algum.</string>
    <string name="DiffieHellman15">A parte A envia a chave P para a parte B.</string>
    <string name="DiffieHellman16">A seguir, a parte A e a parte B preparam as chaves secretas SA e SB, respectivamente.</string>
    <string name="DiffieHellman17">As chaves SA e SB precisam ser gerenciadas para que ninguém consiga pegá-las.</string>
    <string name="DiffieHellman18">A parte A cria uma nova chave P-SA a partir da chave P e da chave secreta SA.</string>
    <string name="DiffieHellman19">Semelhantemente, a parte B cria uma nova chave P-SB a partir da chave P e da chave secreta SB.</string>
    <string name="DiffieHellman2">Digamos que haja um método especial para combinar 2 chaves.</string>
    <string name="DiffieHellman20">A parte A envia a chave P-SA para a parte B.</string>
    <string name="DiffieHellman21">Do mesmo modo, a parte B envia a chave P-SB à parte A.</string>
    <string name="DiffieHellman22">A parte A combina a chave secreta SA com a chave P-SB recebida da parte B para obter a nova chave P-SA-SB.</string>
    <string name="DiffieHellman23">Igualmente, a parte B combina a chave secreta SB com a chave P-SA recebida da parte A, e obtém a nova chave P-SA-SB.</string>
    <string name="DiffieHellman24">Portanto, ambas as partes A e B foram capazes de obter a chave P-SA-SB.</string>
    <string name="DiffieHellman25">Esta chave será usada como uma chave de encriptação/decriptação.</string>
    <string name="DiffieHellman26">Vamos verificar a segurança deste método de troca de chaves.</string>
    <string name="DiffieHellman27">Pelas chaves P, P-SA, e P-SB estarem todas sendo enviadas pela internet...</string>
    <string name="DiffieHellman28">há uma chance de que elas sejam interceptadas por uma parte maliciosa X.</string>
    <string name="DiffieHellman29">Contudo, a parte X não consegue criar a chave P-SA-SB pelas chaves que ela obtém.</string>
    <string name="DiffieHellman3">Com este método, quando a chave P e a chave S são combinadas...</string>
    <string name="DiffieHellman30">Mais adiante, pelas chaves não conseguirem serem desconstruídas, as chaves secretas SA e SB não conseguem ser obtidas.</string>
    <string name="DiffieHellman31">Consequentemente, em virtude da parte X não conseguir criar a chave P-SA-SB, este método de troca de chaves é considerado seguro.</string>
    <string name="DiffieHellman32">A seguir, vamos tentar expressar esse método de troca de chaves em termos matemáticos.</string>
    <string name="DiffieHellman33">Primeiro, vamos explicar a \"operação mod\" (ou \"operação de resto-da-divisão-inteira\").</string>
    <string name="DiffieHellman34">A operação mod é uma operação que encontra o restante de uma divisão.</string>
    <string name="DiffieHellman35">Para A mod B, temos C, o resto da divisão de A por B.</string>
    <string name="DiffieHellman36">Vamos mostrar algumas operações como exemplo usando números concretos.</string>
    <string name="DiffieHellman37">Agora, vamos tentar pensar sobre o método de troca de chaves em termos matemáticos.</string>
    <string name="DiffieHellman38">A chave P, que foi criada no começo e pode se tornar pública, será expressada como os 2 números P e G na fórmula.</string>
    <string name="DiffieHellman39">P é um número primo extremamente grande. G será escolhido entre os números primos Ps conhecidos como geradores (ou raízes primitivas).</string>
    <string name="DiffieHellman4">uma nova chave, P-S, é construída a partir dos componentes da chave P e da chave S.</string>
    <string name="DiffieHellman40">Um número fixo de raízes primitivas existe para todos os números primos P.</string>
    <string name="DiffieHellman41">Primeiro, a parte A preparará o número primo P e a raiz primitiva G. Estes números podem ser conhecidos por qualquer um, sem problema algum.</string>
    <string name="DiffieHellman42">A parte A envia o número primo P e a raiz primitiva G à parte B.</string>
    <string name="DiffieHellman43">A seguir, a parte A e a parte B preparam as chaves secretas X e Y, respectivamente.</string>
    <string name="DiffieHellman44">Mais à frente, os números secretos X e Y precisarão ser menores que o número primo P - 2.</string>
    <string name="DiffieHellman45">A parte A e a parte B, cada uma, realizam cálculos (raiz primitiva G elevado ao número secreto de cada uma) de operação mod (número primo P).</string>
    <string name="DiffieHellman46">Este cálculo é conceitualmente parecido com uma síntese.</string>
    <string name="DiffieHellman47">As partes A e B trocam seus cálculos entre si.</string>
    <string name="DiffieHellman48">As partes A e B então calculam (os números que elas recebem elevados aos seus números secretos) a operação mod (número primo P).</string>
    <string name="DiffieHellman49">Esses cálculos resultam no mesmo valor.</string>
    <string name="DiffieHellman5">Este método de combinação possui 2 características especiais.</string>
    <string name="DiffieHellman50">Por conseguinte, as partes A e B foram capazes de compartilhar números usáveis como códigos.</string>
    <string name="DiffieHellman51">Vamos tentar verificar a segurança desse método de troca de chaves.</string>
    <string name="DiffieHellman52">Em razão dos números estarem sendo enviados pela internet...</string>
    <string name="DiffieHellman53">há uma chance de serem interceptados por uma parte X.</string>
    <string name="DiffieHellman54">Contudo, os números compartilhados entre as partes A e B não conseguem ser calculados a partir dos números obtidos pela parte X.</string>
    <string name="DiffieHellman55">Além disso, os números secretos X e Y não podem ser presumidos.</string>
    <string name="DiffieHellman56">O método de resolução para a operação mod (número primo P) de X (raiz primitiva G elevado a X) é chamado de \"problema de logaritmo discreto\", e ainda não foi descoberto.</string>
    <string name="DiffieHellman57">Pode ser dito que a troca de chaves de Diffie-Hellman é um método de troca de chaves que utiliza o problema de logaritmo discreto.</string>
    <string name="DiffieHellman58">Isto conclui a explicação de troca de chaves de Diffie-Hellman.</string>
    <string name="DiffieHellman6">A 1ª característica é que mesmo que alguém tenha a chave P e a chave combinada criada a partir dela, a P-S...</string>
    <string name="DiffieHellman7">é impossível extrair a chave S.</string>
    <string name="DiffieHellman8">Em outras palavras, mesmo que você consiga criar uma chave, você não consegue desconstruí-la.</string>
    <string name="DiffieHellman9">A 2ª característica é que qualquer chave combinada a partir de outras chaves...</string>
    <string name="DiffieHellmanDescription">A \"Troca de Chaves de Diffie-Hellman\" é um método de troca segura de chaves entre 2 partes. Você pode estudar este tópico após comprar todos os algoritmos.</string>
    <string name="DigitalCertification">Certificados Digitais</string>
    <string name="DigitalCertification0">A criptografia de chave pública e o sistema de assinatura digital tinham o problema de não garantir a quem uma chave pública pertencia.</string>
    <string name="DigitalCertification1">Sendo assim, quando a parte A estava tentando mandar uma chave pública para a parte B...</string>
    <string name="DigitalCertification10">Uma autoridade de certificação possui suas próprias chaves pública (PC) e secreta (SC) que ela preparou para si.</string>
    <string name="DigitalCertification11">A parte A prepara a sua própria informação pessoal, incluindo sua chave pública (PA) e endereço de e-mail...</string>
    <string name="DigitalCertification12">e envia para a autoridade de certificação.</string>
    <string name="DigitalCertification13">Uma vez que a confirmação está completa, a autoridade de certificação usa sua chave secreta (SC) e cria uma assinatura digital a partir dos dados da parte A.</string>
    <string name="DigitalCertification14">Uma explicação mais detalhada de sistema de assinaturas digitais pode ser encontrada em \"Assinaturas Digitais\", na seção \"Segurança\".</string>
    <string name="DigitalCertification15">A seguir, a assinatura digital criada e os dados são convertidos em um único arquivo...</string>
    <string name="DigitalCertification16">e enviado à parte A.</string>
    <string name="DigitalCertification17">Este arquivo se torna o certificado digital da parte A.</string>
    <string name="DigitalCertification18">No lugar de uma chave pública, a parte A envia um certificado digital que ela recebeu da parte B.</string>
    <string name="DigitalCertification19">A parte B confirma que o endereço de e-mail no certificado digital que ela recebeu pertence à parte A.</string>
    <string name="DigitalCertification2">uma terceira parte maliciosa poderia dar ao destinatário uma chave pública diferente sem ele notar.</string>
    <string name="DigitalCertification20">Depois disso, a parte B adquire a chave pública da autoridade de certificação...</string>
    <string name="DigitalCertification21">e verifica se a assinatura digital no certificado digital é da autoridade de certificação.</string>
    <string name="DigitalCertification22">A assinatura digital no certificado digital pode ser verificada apenas usando a chave pública (PC) da autoridade de certificação.</string>
    <string name="DigitalCertification23">Em outras palavras, se os resultados da verificação forem livres de problemas, o certificado digital foi, sem dúvida, emitido pela autoridade de certificação.</string>
    <string name="DigitalCertification24">Uma vez que foi confirmado que a assinatura digital pertence à parte A e foi emitida pela autoridade de certificação, a chave pública da parte A (PA) é extraída da assinatura digital.</string>
    <string name="DigitalCertification25">Com isso, a entrega da chave pública da parte A para a parte B está completa.</string>
    <string name="DigitalCertification26">Vejamos se há algum problema com esse estilo de entrega de chave pública.</string>
    <string name="DigitalCertification27">Digamos que uma parte maliciosa X, fingindo ser a parte A, tenta passar adiante sua própria chave pública.</string>
    <string name="DigitalCertification28">Contudo, a parte B não possui motivo para confiar em uma chave que não foi enviada como um certificado digital.</string>
    <string name="DigitalCertification29">Então o que acontece quando a parte X finge ser parte A e tenta ter sua própria chave pública registrada com a autoridade de certificação?</string>
    <string name="DigitalCertification3">Ao utilizar um sistema de \"certificado digital\", podemos ter certeza sobre quem é o criador da chave pública.</string>
    <string name="DigitalCertification30">Em tal caso, a parte X não possui acesso à conta do e-mail da parte A, de modo que a parte X não consegue emitir um certificado.</string>
    <string name="DigitalCertification31">A parte X consegue apenas criar certificados que usa o endereço de e-mail da parte X. Por isso, ela não consegue obter o certificado da parte A.</string>
    <string name="DigitalCertification32">Como você já viu, ao usar o sistema de certificado digital, é possível verificar quem é o dono de uma chave pública.</string>
    <string name="DigitalCertification33">Anteriormente dissemos que a parte B recebeu a chave pública da autoridade de certificação...</string>
    <string name="DigitalCertification34">mas isso nos traz a uma questão.</string>
    <string name="DigitalCertification35">Foi a chave pública (PC), que a parte B recebeu, realmente criada pela autoridade de certificação?</string>
    <string name="DigitalCertification36">Por não haver um jeito de confirmar quem criou a chave em si, pode ser que tenha sido criada por uma parte X fingindo ser uma autoridade de certificação.</string>
    <string name="DigitalCertification37">Em outras palavras, o mesmo problema que vimos com as chaves públicas ocorre aqui também.</string>
    <string name="DigitalCertification38">Na verdade, essa chave pública (PC) da autoridade de certificação...</string>
    <string name="DigitalCertification39">também é entregue como um certificado digital.</string>
    <string name="DigitalCertification4">Vamos observar como o sistema de certificado digital funciona.</string>
    <string name="DigitalCertification40">E a parte que \"assinou\" o certificado digital da autoridade de certificação...</string>
    <string name="DigitalCertification41">é uma autoridade de certificação de maior classe.</string>
    <string name="DigitalCertification42">As autoridades de certificação formam uma estrutura de árvore hierárquica, com as autoridades de maior classe criando as assinaturas digitais para as de menor classe.</string>
    <string name="DigitalCertification43">Para ver como funciona essa estrutura de árvore de autoridades de certificações...</string>
    <string name="DigitalCertification44">digamos, por exemplo, que temos uma autoridade de certificação Y que é altamente confiável pela sociedade.</string>
    <string name="DigitalCertification45">Mesmo que uma nova companhia G queira iniciar seus serviços como autoridade de certificação, ela não possui credibilidade na sociedade.</string>
    <string name="DigitalCertification46">Sendo assim, a companhia G consegue um certificado digital emitido pela companhia Y. Claramente, a companhia Y checará de modo a ter certeza de que a companhia G poderá realizar adequadamente seus serviços de autoridade de certificação.</string>
    <string name="DigitalCertification48">Como resultado, a empresa G pode anunciar-se como uma empresa que ganhou a confiança da empresa Y.</string>
    <string name="DigitalCertification49">Ao fazer isso, organizações maiores asseguram a confiança de organizações menores, formando uma estrutura de árvore organizada.</string>
    <string name="DigitalCertification5">Digamos que a parte A, tendo posse de ambas chave pública (PA) e chave secreta (SA)...</string>
    <string name="DigitalCertification50">Então, quem está no topo da árvore de autoridades de certificações?</string>
    <string name="DigitalCertification51">Uma autoridade de certificação que se mantém no topo das posições é chamada de \"autoridade de certificação raiz (raiz AC)\", e certifica sua própria validez.</string>
    <string name="DigitalCertification52">Mais à frente, certificados que uma autoridade de certificação raiz certifica são chamados de \"certificados raiz\".</string>
    <string name="DigitalCertification53">Se uma autoridade de certificação raiz não for em si uma organização confiável, ela não será usada.</string>
    <string name="DigitalCertification54">Sendo assim, um grande número delas são organizações que já possuem credibilidade social, como grandes companhias e agências do governo.</string>
    <string name="DigitalCertification55">Agora, demos uma olhada na transferência de chaves públicas entre as partes...</string>
    <string name="DigitalCertification56">mas os certificados digitais também são usados durante a comunicação com o website.</string>
    <string name="DigitalCertification57">Ao obter um certificado que inclui uma chave pública de um website, podemos ter certeza de que o site não está sofrendo spoofing de uma terceira parte.</string>
    <string name="DigitalCertification58">Esse certificado é chamado de \"certificado de servidor\", e também é emitido pela autoridade de certificação.</string>
    <string name="DigitalCertification59">No caso de uma pessoa, o certificado é ligado a um endereço de e-mail...</string>
    <string name="DigitalCertification6">está pronta para mandar a chave pública (PA) à parte B.</string>
    <string name="DigitalCertification60">mas no caso do certificado de servidor, ele é ligado a um domínio.</string>
    <string name="DigitalCertification61">Um certificado de servidor garante que a chave pública foi emitida pela organização que gerencia o domínio ao qual o certificado está vinculado.</string>
    <string name="DigitalCertification62">Em outras palavras, pode ser confirmado que a organização que gerencia o domínio do site e a organização que gerencia o servidor que armazena o conteúdo do site são a mesma.</string>
    <string name="DigitalCertification63">Desta forma, os certificados digitais são um sistema societário de garantia sobre quem são os criadores de chaves públicas, através das autoridades de certificação.</string>
    <string name="DigitalCertification64">Isto conclui a explicação de certificados digitais.</string>
    <string name="DigitalCertification7">Primeiro, a parte A precisa solicitar a uma autoridade de certificação para que emita um certificado apontando que ela é a dona da chave pública (PA).</string>
    <string name="DigitalCertification8">Uma autoridade de certificação é uma organização que gerencia certificados digitais. Basicamente, qualquer um pode se tornar tal organização, e elas existem em grande número.</string>
    <string name="DigitalCertification9">Dessa forma, é mais seguro utilizar organizações de confiança como o governo ou grandes, companhias que passam por auditorias.</string>
    <string name="DigitalCertificationDescription">\"Certificados digitais\" são sistemas que garantem a identidade do criador de uma chave pública. Você pode estudar este tópico após comprar todos os algoritmos.</string>
    <string name="DigitalSignature">Assinaturas Digitais</string>
    <string name="DigitalSignature0">Um sistema de \"assinatura digital\" garante não-repudiação...</string>
    <string name="DigitalSignature1">em adição à detecção de autenticação e falsificação, as duas funções implementadas por autenticadores de mensagem.</string>
    <string name="DigitalSignature10">Por exemplo, depois que a parte A envia a mensagem para a parte B, a parte B pode dizer que é a criadora da mensagem.</string>
    <string name="DigitalSignature100">Estritamente falando, também há casos onde os métodos de cálculo da criação das assinaturas são diferentes que os da criptografia.</string>
    <string name="DigitalSignature101">Contudo, eles compartilham a característica de usar chaves privadas para a criação de assinaturas e chaves públicas para a verificação de assinaturas, por isso estamos explicando desta maneira, por convenção.</string>
    <string name="DigitalSignature11">Além disso, por estarem usando chaves privadas, uma chave diferente deverá ser preparada se a parte A decidir enviar a mensagem para outra parte além da parte B.</string>
    <string name="DigitalSignature12">Por outro lado, ao invés de usar MACs, o sistema de assinatura digital usa dados que apenas o remetente consegue criar como base para identificação. Estes dados são chamados de \"assinatura digital\".</string>
    <string name="DigitalSignature13">Vejamos o esboço do processo.</string>
    <string name="DigitalSignature14">O \"Assin.\" na imagem é uma assinatura digital, e pode ser criada apenas pela parte A.</string>
    <string name="DigitalSignature15">Portanto, quando uma mensagem com a assinatura digital da parte A atribuída a ela é recebida, é garantido que o remetente é de fato a parte A.</string>
    <string name="DigitalSignature16">O receptor da mensagem, a parte B, é capaz de confirmar que a assinatura digital é da parte A, mas ela não consegue criar a mesma assinatura digital por si só.</string>
    <string name="DigitalSignature17">Em contraste com autenticadores de mensagens, como a chave privada não é usada, a parte A consegue enviar sua mensagem para múltiplas partes usando a mesma assinatura digital.</string>
    <string name="DigitalSignature2">Vamos revisar autenticadores de mensagem.</string>
    <string name="DigitalSignature20">Vamos dar uma olhada em como uma assinatura digital é criada.</string>
    <string name="DigitalSignature21">Enquanto que a chave usada para criar MACs foi uma chave privada...</string>
    <string name="DigitalSignature22">ao criar uma assinatura digital, aplicamos o processo de \"criptografia de chave pública\".</string>
    <string name="DigitalSignature23">Uma explicação mais detalhada de criptografia de chave pública pode ser encontrada em \"Criptografia de Chave Pública\", na seção \"Segurança\". Por ora, daremos uma visão básica do que ela é.</string>
    <string name="DigitalSignature24">A parte A criptografou os dados e está pronta para enviá-los à parte B.</string>
    <string name="DigitalSignature25">Primeiro, a parte receptora, a parte B, prepara uma chave pública (P) e uma chave secreta (S).</string>
    <string name="DigitalSignature26">A parte B passa a chave pública para a parte A.</string>
    <string name="DigitalSignature27">A parte A usa a chave pública para criptografar os dados.</string>
    <string name="DigitalSignature28">Então ela envia o texto cifrado à parte B.</string>
    <string name="DigitalSignature29">A parte B descriptografa o texto cifrado que ela recebeu, convertendo aos seus dados originais usando a chave secreta, completando a troca.</string>
    <string name="DigitalSignature3">O sistema de autenticadores de mensagem atribui um MAC a uma mensagem de modo a identificar o remetente da mensagem como o dono da chave de criptografia.</string>
    <string name="DigitalSignature30">Então, com a criptografia de chave pública, uma chave pública foi usada para encriptação e uma chave secreta foi usada para decriptação.</string>
    <string name="DigitalSignature31">Assim sendo, qualquer um pode criptografar os dados usando a chave pública...</string>
    <string name="DigitalSignature32">mas como a parte B é a única que possui a chave secreta, é garantido que apenas ela conseguirá realizar a descriptografia.</string>
    <string name="DigitalSignature33">Agora, o que acontece se revertermos o processo, usando a chave secreta para a encriptação e a chave pública para a decriptação?</string>
    <string name="DigitalSignature34">Neste caso, como a parte A possui a chave secreta, apenas ela conseguirá criptografar os dados, mas o texto cifrado criado pode ser descriptografado por qualquer um que possuir a chave pública.</string>
    <string name="DigitalSignature35">Isso é totalmente desprovido de sentido enquanto método de criptografia, mas olhando para isso de uma maneira diferente, podemos ver que o criador do texto cifrado é garantido como sendo a parte A, o único que possui a chave secreta.</string>
    <string name="DigitalSignature36">Numa assinatura digital, este texto cifrado que apenas a parte A consegue criar é usado como assinatura.</string>
    <string name="DigitalSignature37">Vamos dar uma olhada em como uma troca funciona com uma mensagem que usou uma assinatura digital.</string>
    <string name="DigitalSignature38">Primeiro, a parte A prepara a mensagem que ela deseja enviar, assim como as chaves secreta e pública.</string>
    <string name="DigitalSignature39">O fato que o remetente da mensagem prepara as chaves pública e secreta é onde difere da criptografia de chave pública.</string>
    <string name="DigitalSignature4">Aqui, por convenção, vamos enviar uma mensagem sem criptografá-la.</string>
    <string name="DigitalSignature40">A parte A passa a chave pública para a parte B.</string>
    <string name="DigitalSignature41">Então, ela criptografa a mensagem usando a chave secreta.</string>
    <string name="DigitalSignature42">O texto cifrado servirá como a assinatura, e será marcada como \"Assin.\" no diagrama daqui em diante.</string>
    <string name="DigitalSignature43">A parte A envia a mensagem e a assinatura para a parte B.</string>
    <string name="DigitalSignature44">A parte B descriptografa o texto cifrado usando a chave pública.</string>
    <string name="DigitalSignature45">É confirmado que a mensagem descriptografada combina com a mensagem recebida, completando a troca.</string>
    <string name="DigitalSignature46">O texto cifrado, que pode ser descriptografado usando a chave pública da parte A, pode ser criado apenas pela parte A.</string>
    <string name="DigitalSignature47">Assim sendo, conseguimos confirmar que a parte A é a que enviou a mensagem, sendo uma autêntica.</string>
    <string name="DigitalSignature48">Além disso, como a assinatura da parte A não consegue ser criada pela parte B, que possui apenas a chave pública, o papel de prevenir a repudiação é cumprido.</string>
    <string name="DigitalSignature49">Entretanto, a criptografia de chave pública tende a tomar tempo para a encriptação e decriptação.</string>
    <string name="DigitalSignature5">A parte A envia a mensagem e o MAC, assim como a chave usada para criar o MAC, para a parte B.</string>
    <string name="DigitalSignature50">Então, ao invés de criptografar a mensagem diretamente...</string>
    <string name="DigitalSignature51">para encurtar o tempo de cálculo, primeiro, o valor hash da mensagem é determinado...</string>
    <string name="DigitalSignature52">e então o valor hash é criptografado e usado como assinatura.</string>
    <string name="DigitalSignature53">Uma explicação mais detalhada de hashing pode ser encontrada em \"Funções Hash\", na seção \"Segurança\".</string>
    <string name="DigitalSignature54">A mensagem e a assinatura são enviadas à parte B.</string>
    <string name="DigitalSignature55">Semelhantemente, a parte B calcula o valor hash da mensagem recebida.</string>
    <string name="DigitalSignature56">Depois, a assinatura recebida é descriptografada usando a chave pública, e a partir disso o valor hash é calculado.</string>
    <string name="DigitalSignature57">Se puder ser confirmado que os dois valores hash combinam, a troca usando assinatura digital está completa.</string>
    <string name="DigitalSignature58">Assinaturas digitais oferecem as funções para autenticação, detecção de falsificação e prevenção de repudiação, mas há um problema.</string>
    <string name="DigitalSignature59">A parte B, ao fazer a troca usando uma assinatura digital, acredita que a parte A foi o remetente...</string>
    <string name="DigitalSignature6">A parte B recria o MAC usando a mensagem recebida e a chave e confirma que combina com o MAC que ela recebeu.</string>
    <string name="DigitalSignature60">mas na realidade, não podemos dizer que há zero chance de que uma parte X maliciosa não efetuou a troca se passando como parte A.</string>
    <string name="DigitalSignature61">A causa fundamental deste problema reside no fato de que na criptografia de chave pública, não sabemos a quem a chave pública pertence.</string>
    <string name="DigitalSignature62">Não há um único pedaço de informação incluído na chave pública que indique quem a criou.</string>
    <string name="DigitalSignature63">Assim sendo, há a possibilidade de que a chave pública foi criada por alguém se passando como parte A...</string>
    <string name="DigitalSignature64">assim como há a possibilidade de que a parte A realmente criou a chave pública, mas nenhuma delas é certeza.</string>
    <string name="DigitalSignature66">Este problema pode ser resolvido com o sistema de \"certificado digital\".</string>
    <string name="DigitalSignature67">Num certificado digital, a informação sobre o criador da chave pública faz parte da chave, e é lidada como um único certificado.</string>
    <string name="DigitalSignature68">Uma explicação mais detalhada de \"certificados digitais\" pode ser encontrada em \"Certificados Digitais\", na seção \"Segurança\".</string>
    <string name="DigitalSignature69">Isto conclui a explicação de assinaturas digitais.</string>
    <string name="DigitalSignature8">Disso, pode ser verificado que a parte A é a remetente e a mensagem não foi falsificada.</string>
    <string name="DigitalSignature9">Contudo, como os autenticadores de mensagem usam uma chave privada, ainda é possível para qualquer um em posse da chave se fingir de remetente da mensagem.</string>
    <string name="DigitalSignatureDescription">\"Assinaturas digitais\" são sistemas de soluções para problemas de spoofing, falsificação e não-repudiação. Você pode estudar este tópico após comprar todos os algoritmos.</string>
    <string name="Dijkstra">Algoritmo de Dijkstra</string>
    <string name="Dijkstra0">O \"Algoritmo de Dijkstra\" é um algoritmo usado para encontrar o caminho mais curto entre pontos de um grafo. É um método mais eficiente do que o algoritmo de Bellman-Ford.</string>
    <string name="Dijkstra1">Para começar, os valores de custo de cada ponto são determinados. O valor do ponto de partida é considerado 0, e dos outros são considerados infinitos.</string>
    <string name="Dijkstra10">Tomando o caminho determinado como o mais curto, movemos ao ponto B.</string>
    <string name="Dijkstra100">A razão para isso é que escolher seguir um outro caminho requer que passemos por C, resultando em um custo maior do que o caminho atual.</string>
    <string name="Dijkstra101">O caminho A-B-D foi o resultado da escolha dos pontos candidatos com menor custo. Então, sabemos que passar por qualquer outro ponto para chegar até D certamente terá um custo maior.</string>
    <string name="Dijkstra102">Neste caso, os pontos B e C tornam-se candidatos.</string>
    <string name="Dijkstra11">Pontos acessíveis do ponto atual são adicionados como candidatos. Neste caso, são os pontos C, D e E.</string>
    <string name="Dijkstra12">Usando o mesmo método de antes, calculamos o custo de cada candidato.</string>
    <string name="Dijkstra13">O custo total de movimentação para o ponto C a partir do B é 2 + 6 = 8, que é maior que seu valor atual de 5, então nenhuma atualização é feita.</string>
    <string name="Dijkstra14">Os custos dos pontos remanescentes, D e E, foram atualizados.</string>
    <string name="Dijkstra15">Dos pontos candidatos, escolhemos aquele com o menor custo. Neste caso, é o D.</string>
    <string name="Dijkstra16">Até aqui, determinamos que o caminho escolhido A-B-D é o caminho mais curto entre os pontos de partida até D.</string>
    <string name="Dijkstra17">Deste modo, o algoritmo de Dijkstra busca através do grafo, determinando caminhos mais curtos para cada ponto, um caminho por vez.</string>
    <string name="Dijkstra18">A mesma operação é repetida até que seja alcançado o último ponto, G.</string>
    <string name="Dijkstra2">Começamos pelo primeiro ponto.</string>
    <string name="Dijkstra3">Começando pela localização atual, procuramos por pontos inexplorados. Uma vez encontrados, estes pontos se tornam candidatos para a próxima locomoção.</string>
    <string name="Dijkstra35">Alcançamos o último ponto, G, então a busca é encerrada.</string>
    <string name="Dijkstra36">No fim, as árvores destacadas em laranja, chamadas de \"caminhos de comprimento mínimo\", nos mostram o caminho mais curto para cada ponto no grafo.</string>
    <string name="Dijkstra37">O caminho mais curto para o último ponto, G, é o mais espesso.</string>
    <string name="Dijkstra38">Como você pode ver, comparado ao algoritmo de Bellman-Ford, que calcula e atualiza os custos para todas as arestas repetidamente, o algoritmo de Dijkstra procura de forma eficaz o caminho mais curto, planejando quais pontos escolher em seguida.</string>
    <string name="Dijkstra39">Como o algoritmo de Bellman-Ford, mesmo que tenha arestas de uma direção só ou arestas com diferentes custos para ir e vir...</string>
    <string name="Dijkstra4">O custo de cada caminho é calculado. O método de cálculo é o custo do ponto inicial + o custo de movimentação ao ponto candidato.</string>
    <string name="Dijkstra40">o algoritmo de Dijkstra consegue achar o caminho mais curto.</string>
    <string name="Dijkstra41">Grafos cuja direção das arestas é fixa, como no diagrama, são chamados de \"grafos orientados\" (digrafos), e grafos onde a direção das arestas não é fixa são chamados de \"grafos não orientados\".</string>
    <string name="Dijkstra42">Há vezes em que o algoritmo de Dijkstra não consegue encontrar corretamente o caminho mais curto se num grafo contiver um caminho com um \"custo negativo\". Ele difere-se do algoritmo de Bellman-Ford nesse quesito.</string>
    <string name="Dijkstra43">No grafo, A-C-B-G é o caminho mais curto e inclui atravessar o caminho C-B, que possui um custo negativo.</string>
    <string name="Dijkstra44">Como teste, vamos usar o algoritmo de Dijkstra.</string>
    <string name="Dijkstra45">Os pontos B e C, que são alcançáveis a partir do ponto de partida A e não foram totalmente explorados ainda, possuem custos de 2 e 4, respectivamente.</string>
    <string name="Dijkstra46">Até aqui, o algoritmo de Dijkstra determina que o caminho mais curto do ponto de partida A para o B é o caminho A-B.</string>
    <string name="Dijkstra47">A razão para isso é que usar qualquer outro caminho requer a travessia pelo ponto C, e o caminho A-C tem um custo maior que o caminho A-B.</string>
    <string name="Dijkstra48">Como você já sabe, é suposto que todas as arestas possuem um custo maior que 0. Em outras palavras, não existe custos negativos no grafo.</string>
    <string name="Dijkstra49">O algoritmo concluiu que o caminho mais curto do ponto de partida A para o ponto de chegada G é o caminho A-B-G, tendo custo de 3. Como notado anteriormente, isso é um erro.</string>
    <string name="Dijkstra5">Por exemplo, no caso de se mover para B, o custo do ponto de partida é 0, de modo que o custo é 0 + 2 = 2. Do mesmo modo, o custo de se mover para C seria 0 + 5 = 5.</string>
    <string name="Dijkstra52">Ademais, com um grafo como este...</string>
    <string name="Dijkstra53">que contém um \"ciclo negativo\" que resulta em um custo negativo ao tomar certos caminhos...</string>
    <string name="Dijkstra54">com o algoritmo de Dijkstra, uma solução errônea será alcançada, independentemente da existência ou não do menor caminho.</string>
    <string name="Dijkstra55">Por isso, o algoritmo de Dijkstra não deve ser usado em grafos que contenham custos negativos.</string>
    <string name="Dijkstra56">Inversamente, para grafos onde não há custos negativos, pode-se dizer que o algoritmo de Dijkstra consegue achar o caminho mais curto usando menos cálculos do que o algoritmo de Bellman-Ford.</string>
    <string name="Dijkstra57">Isto conclui a explicação de algoritmo de Dijkstra.</string>
    <string name="Dijkstra6">Se o custo calculado for menor que o valor atual, o custo do ponto é atualizado para o novo valor.</string>
    <string name="Dijkstra7">Uma vez que os custos atuais de B e C tendem ao infinito, os resultados calculados são menores, então B e C são atualizados para os novos valores de custo.</string>
    <string name="Dijkstra8">Dos pontos candidatos, escolhemos aquele com o menor custo. Neste caso, é o B.</string>
    <string name="Dijkstra9">Até aqui, determinamos que o caminho escolhido A-B é o caminho mais curto entre o ponto de partida até B.</string>
    <string name="DijkstraDescription">O \"Algoritmo de Dijkstra\" é um algoritmo usado para determinar eficientemente caminhos mais curtos. Você pode estudar este tópico após comprar todos os algoritmos.</string>
    <string name="Euclidean">Algoritmo de Euclides</string>
    <string name="Euclidean0">O \"Algoritmo de Euclides\" é um algoritmo que encontra o máximo divisor comum de 2 números.</string>
    <string name="Euclidean1">Descoberto por Euclides em meados do século IV A.C., é tido como o mais velho algoritmo do mundo.</string>
    <string name="Euclidean10">Para A mod B, temos C, o resto de A dividido por B.</string>
    <string name="Euclidean11">Alguns exemplos de operações usando números concretos.</string>
    <string name="Euclidean12">Agora, vamos observar o algoritmo de Euclides em ação.</string>
    <string name="Euclidean13">Primeiro, encontramos o resto do maior número dividido pelo menor número.</string>
    <string name="Euclidean14">Em outras palavras, vamos fazer uma operação mod com o maior e menor número.</string>
    <string name="Euclidean15">O resultado da divisão encontrou 417 como o resto.</string>
    <string name="Euclidean16">Agora, fazemos a operação mod com o divisor anterior, 695, e o resto anterior, 417.</string>
    <string name="Euclidean17">Encontramos 278.</string>
    <string name="Euclidean18">Repetimos a mesma operação, realizando uma operação mod com 417 e 278.</string>
    <string name="Euclidean19">Encontramos 139.</string>
    <string name="Euclidean2">Como exemplo, vamos considerar o máximo divisor comum de 1112 e 695.</string>
    <string name="Euclidean20">Realizamos uma operação mod com 278 e 139.</string>
    <string name="Euclidean21">Encontramos 0.</string>
    <string name="Euclidean22">Em outras palavras, 278 é divisível por 139.</string>
    <string name="Euclidean23">Quando o resto é 0, o divisor da última operação, 139, é considerado o máximo divisor comum de 1112 e 695.</string>
    <string name="Euclidean24">Como o algoritmo de Euclides é capaz de encontrar o máximo divisor comum? Vamos considerar esta questão usando o diagrama.</string>
    <string name="Euclidean25">Vamos tentar expressar 1112 e 695 em termos de comprimento de barra.</string>
    <string name="Euclidean26">Adicionaremos segmentos em incrementos de n, o máximo divisor comum.</string>
    <string name="Euclidean27">Foi determinado que 139 é o máximo divisor comum, então por convenção, 1112 recebeu 8 segmentos e 695 recebeu 5 segmentos.</string>
    <string name="Euclidean28">Na realidade, não se sabe quantos segmentos cada barra terá.</string>
    <string name="Euclidean29">Contudo, sabemos que ambos 1112 e 695 são múltiplos de um máximo divisor comum, n.</string>
    <string name="Euclidean3">Com o método convencional, fatoramos os dois números em números primos...</string>
    <string name="Euclidean30">Aqui, como na operação anterior, encontraremos o resto do maior número dividido pelo menor número.</string>
    <string name="Euclidean31">Encontramos 417. Pelo diagrama, podemos ver que 417 também é um número ordenadamente dividido em segmentos de comprimento n.</string>
    <string name="Euclidean32">Vamos repetir a operação mod como fizemos anteriormente.</string>
    <string name="Euclidean35">Quando 695 é dividido por 417, temos um resto de 278.</string>
    <string name="Euclidean36">Este resto 278 também é um íntegro múltiplo de n, ou seja, tem o mesmo máximo divisor comum.</string>
    <string name="Euclidean37">Repetimos a divisão novamente.</string>
    <string name="Euclidean38">Por 278 ser divisível por 139, o resto é 0.</string>
    <string name="Euclidean39">É aqui que aprendemos que o máximo divisor comum, n, é 139.</string>
    <string name="Euclidean4">e encontramos o máximo divisor comum (MDC) dos números primos que eles compartilham.</string>
    <string name="Euclidean40">Deste modo, o algoritmo de Euclides é capaz de encontrar o máximo divisor comum simplesmente repetindo divisões.</string>
    <string name="Euclidean41">Uma grande vantagem é que mesmo que os dois números sejam gigantes, o algoritmo é capaz de encontrar o máximo divisor comum com o procedimento padrão.</string>
    <string name="Euclidean42">Isto conclui a explicação de algoritmo de Euclides.</string>
    <string name="Euclidean5">Agora sabemos que o máximo divisor comum de 1112 e 695 é 139.</string>
    <string name="Euclidean6">Contudo, com este método, à medida em que os 2 números vão ficando maiores, mais difícil vai ficando a fatoração.</string>
    <string name="Euclidean7">Com o algoritmo de Euclides, somos capazes de encontrar o máximo divisor comum mais eficientemente.</string>
    <string name="Euclidean8">Antes de entrar na explicação do algoritmo de Euclides, vamos explicar a operação mod (ou \"operação de resto-da-divisão-inteira\").</string>
    <string name="Euclidean9">A operação mod é uma operação que encontra o resto de uma divisão.</string>
    <string name="ExperimentalModeTitle">Simular</string>
    <string name="FewUnique">Poucos únicos</string>
    <string name="GetItemInfoFailed">Não foi possível recuperar a informação do item. Por favor, confirme sua conexão com a internet.</string>
    <string name="GraphSearchSection">Busca em Grafo</string>
    <string name="Hanoi">Torre de Hanoi</string>
    <string name="Hanoi0">A \"Torre de Hanoi\" é um quebra-cabeça de movimentação de discos.</string>
    <string name="Hanoi1">O diagrama mostra 3 estacas, A, B e C, com dois discos na estaca A.</string>
    <string name="Hanoi101">Vamos observar um exemplo de movimentação dos discos baseado nas condições acima.</string>
    <string name="Hanoi102">Então, usando os mesmos princípios de antes, movemos os discos da estaca B para a estaca C.</string>
    <string name="Hanoi15">O disco mais curto está no topo, então podemos movê-lo para a estaca B.</string>
    <string name="Hanoi16">Movemos o disco maior para a estaca C.</string>
    <string name="Hanoi17">Ao mover o disco menor para a estaca C, terminamos os movimentos. Fomos capazes de confirmar que é possível alcançar o objetivo quando há 2 discos.</string>
    <string name="Hanoi18">E quando há 3 discos?</string>
    <string name="Hanoi19">Vamos ignorar o disco maior e pensar como mover os discos restantes para a estaca B.</string>
    <string name="Hanoi2">O objetivo é mover os discos para a estaca C enquanto mantém os discos na mesma ordem que a estaca A.</string>
    <string name="Hanoi20">Se movermos os discos restantes da mesma maneira que antes quando tínhamos apenas 2 discos, somos capazes de movê-los para a estaca B.</string>
    <string name="Hanoi21">Movemos o disco maior para a estaca C.</string>
    <string name="Hanoi22">Nossos movimentos estão concluídos. Fomos capazes de confirmar que também é possível alcançar o objetivo quando há 3 discos.</string>
    <string name="Hanoi23">Na verdade, é possível alcançar o objetivo do jogo para todos os discos, não importando a quantidade de discos.</string>
    <string name="Hanoi24">Vamos tentar provar isso usando indução matemática.</string>
    <string name="Hanoi25">Fomos capazes de alcançar o objetivo quando havia 1 disco.</string>
    <string name="Hanoi27">Vamos supor que somos capazes de alcançar o objetivo quando há n discos.</string>
    <string name="Hanoi29">Vamos pensar sobre mover n+1 discos.</string>
    <string name="Hanoi30">Vamos ignorar o disco maior.</string>
    <string name="Hanoi31">Baseado na nossa suposição de que somos capazes de mover n discos, moveremos n discos para a estaca B.</string>
    <string name="Hanoi32">Movemos o disco maior para a estaca C.</string>
    <string name="Hanoi33">Movemos os n discos da estaca B para a estaca C. Nossos movimentos estão concluídos.</string>
    <string name="Hanoi34">Usando indução matemática, provamos que o objetivo pode ser alcançado com qualquer quantidade de discos.</string>
    <string name="Hanoi35">Vamos pensar a respeito da solução da Torre de Hanoi.</string>
    <string name="Hanoi36">Ao resolver a Torre de Hanoi com n discos, você pode usar a solução da Torre de Hanoi com n - 1 discos.</string>
    <string name="Hanoi37">Para resolver a Torre de Hanoi com n - 1 discos, você pode usar a solução da Torre de Hanoi com n - 2 discos, e assim por diante até que você finalmente tenha apenas um disco, trazendo-o para a solução recursivamente.</string>
    <string name="Hanoi38">Este modo recursivo de pensar é usado em muitos algoritmos, e tais algoritmos são chamados de \"algoritmos recursivos\".</string>
    <string name="Hanoi39">Isto conclui a explicação de Torre de Hanoi.</string>
    <string name="Hanoi4">Existem duas condições para a movimentação dos discos. A primeira condição é que você só pode mover um disco por vez.</string>
    <string name="Hanoi5">Mover 1 disco desse jeito não é um problema...</string>
    <string name="Hanoi6">mas você não pode mover 2 discos ao mesmo tempo como mostrado no diagrama.</string>
    <string name="Hanoi9">A segunda condição é que você não pode colocar um disco maior em cima de um disco menor.</string>
    <string name="Hash">Tabelas de Espalhamento (Hash)</string>
    <string name="Hash0">\"Tabelas de Espalhamento\" (ou Tabelas Hash) são um tipo de estrutura de dados.</string>
    <string name="Hash1">Elas são boas em armazenar dados em conjuntos feitos de \"chaves\" e \"valores\".</string>
    <string name="Hash10">A caixa 2 também não é da Ally.</string>
    <string name="Hash11">A caixa 3 também não é da Ally.</string>
    <string name="Hash12">A chave para os dados armazenados na caixa 4 corresponderam com Ally.</string>
    <string name="Hash13">Extraindo seu valor correspondente, descobrimos que o sexo de Ally é feminino (F).</string>
    <string name="Hash14">Deste modo, a operação de busca linear carrega consigo um custo proporcional ao tamanho dos dados.</string>
    <string name="Hash15">Leva tempo para procurar pelos dados quando armazenados em um array, tornando-a uma escolha inadequada.</string>
    <string name="Hash16">Uma tabela hash resolve este problema.</string>
    <string name="Hash17">Prepararemos um array para armazenar alguns dados. Por convenção, teremos 5 caixas no array.</string>
    <string name="Hash18">Agora, vamos armazenar alguns dados.</string>
    <string name="Hash19">Ao armazenar os dados de \"Joe\"...</string>
    <string name="Hash2">Neste caso, um nome é uma chave, e um sexo é o valor.</string>
    <string name="Hash20">calculamos um código hash para a chave usando a função hash. O resultado obtido neste caso é 4928.</string>
    <string name="Hash21">Uma explicação mais detalhada de funções hash pode ser encontrada em \"Funções Hash\", na seção \"Segurança\", mas basicamente é uma função que converte dados para um valor de comprimento fixo.</string>
    <string name="Hash22">O código hash buscado é dividido pelo número de caixas no array, 5, para o resto ser encontrado.</string>
    <string name="Hash23">A operação que encontra o resto da divisão é chamada de \"operação mod\" (ou \"operação de resto-da-divisão-inteira\").</string>
    <string name="Hash24">A operação mod resultou no valor 3.</string>
    <string name="Hash25">Os dados de \"Joe\" são armazenados na caixa 3 do array para combinar com o resultado.</string>
    <string name="Hash26">Esta operação será repetida para armazenar os outros dados.</string>
    <string name="Hash27">Ao armazenar os dados de \"Sue\"...</string>
    <string name="Hash28">encontramos o código hash da chave, e realizamos uma operação mod nela usando o número das caixas no array, 5. O resultado é 1.</string>
    <string name="Hash29">Os dados de \"Sue\" são armazenados na caixa 1 do array.</string>
    <string name="Hash3">Por exemplo, vamos imaginar os dados do diagrama armazenados em um array.</string>
    <string name="Hash30">Ao armazenar os dados de \"Dan\"...</string>
    <string name="Hash31">encontramos o código hash da chave, e realizamos uma operação mod nela usando o número das caixas no array, 5. O resultado é 4.</string>
    <string name="Hash32">Os dados de \"Dan\" são armazenados na caixa 4 do array.</string>
    <string name="Hash33">Ao armazenar os dados de \"Nell\"...</string>
    <string name="Hash34">encontramos o código hash da chave, e realizamos uma operação mod nela usando o número das caixas no array, 5. O resultado é 1.</string>
    <string name="Hash35">Quando tentamos armazenar os dados de \"Nell\" na caixa 1 do array...</string>
    <string name="Hash36">encontramos os dados de \"Sue\" já armazenados lá. Quando algo desse tipo acontece...</string>
    <string name="Hash37">os dados que chegam ficam conectados aos dados existentes, como uma lista.</string>
    <string name="Hash38">Há vários tipos de estruturas de tabelas hash, mas o método que usa listas é chamado de \"encadeado\" (chained).</string>
    <string name="Hash39">Ao armazenar os dados de \"Ally\"...</string>
    <string name="Hash4">Preparamos 6 caixas para o array e armazenamos dados nelas.</string>
    <string name="Hash40">encontramos o código hash da chave, e realizamos uma operação mod nela usando o número das caixas no array, 5. O resultado é 3.</string>
    <string name="Hash41">Por causa dos dados de \"Joe\" já estarem armazenados na caixa 3 do array, os dados de \"Ally\" ficam conectados como uma lista.</string>
    <string name="Hash42">Ao armazenar os dados de \"Bob\"...</string>
    <string name="Hash43">encontramos o código hash da chave, e realizamos uma operação mod nela usando o número das caixas no array, 5. O resultado é 3.</string>
    <string name="Hash44">Por causa dos dados de \"Joe\" e \"Ally\" já estarem armazenados na caixa 3 do array, os dados de \"Bob\" ficam conectados como uma lista.</string>
    <string name="Hash45">Todos os dados foram armazenados, e a tabela hash está completa.</string>
    <string name="Hash46">Vamos olhar para o sexo de Dan.</string>
    <string name="Hash47">A fim de descobrir em qual caixa do array Dan está...</string>
    <string name="Hash48">encontramos o código hash da chave, e realizamos uma operação mod nela usando o número das caixas no array, 5. O resultado é 4.</string>
    <string name="Hash49">A chave para os dados armazenados na caixa 4 do array correspondem com \"Dan\".</string>
    <string name="Hash5">Agora vamos olhar o sexo da Ally.</string>
    <string name="Hash50">Ao extrair seu valor correspondente, descobrimos que o sexo de Dan é masculino (M).</string>
    <string name="Hash51">Então o que acontece quando olhamos o sexo de Ally?</string>
    <string name="Hash52">A fim de descobrir em qual caixa do array Ally está...</string>
    <string name="Hash53">encontramos o código hash da chave, e realizamos uma operação mod nela usando o número das caixas no array, 5. O resultado é 3.</string>
    <string name="Hash54">A chave para os dados armazenados na caixa 3 do array foi \"Joe\", e não \"Ally\".</string>
    <string name="Hash55">Então uma busca linear é realizada na lista começando pelos dados \"Joe\".</string>
    <string name="Hash56">Dados com a chave \"Ally\" foram encontrados.</string>
    <string name="Hash57">Ao extrair seu valor correspondente, descobrimos que o sexo de Ally é feminino (F).</string>
    <string name="Hash58">Como você pode ver, usando a função hash, tabelas hash são capazes de acessar dados rapidamente dentro de um array.</string>
    <string name="Hash59">Quando valores hash colidem, listas são utilizadas, tornando possível manipular de forma flexível uma quantidade incerta de dados.</string>
    <string name="Hash6">Não sabemos qual é o número da caixa da Ally.</string>
    <string name="Hash60">Quando o tamanho de um array usado por uma tabela hash é muito pequeno, as colisões aumentam, tornando as buscas lineares mais prevalentes.</string>
    <string name="Hash61">Inversamente, se o tamanho do array é muito grande, haverá muitas caixas sem dados armazenados nelas, desperdiçando memória, então prudência se faz necessária.</string>
    <string name="Hash62">As tabelas hash, com seu armazenamento de dados flexível e busca rápida, são usadas em arrays associativos de linguagens de programação.</string>
    <string name="Hash63">Isto conclui a explicação de tabelas hash.</string>
    <string name="Hash7">Portanto, precisamos procurar em ordem, partindo do começo. Esta operação é chamada de \"busca linear\".</string>
    <string name="Hash8">A chave para os dados armazenados na caixa 0 é Joe, que não é Ally.</string>
    <string name="Hash9">A caixa 1 também não é da Ally.</string>
    <string name="HashFunction">Funções Hash</string>
    <string name="HashFunction0">Uma \"função hash\" é uma função que converte os dados fornecidos em um valor irregular de comprimento fixo.</string>
    <string name="HashFunction1">Uma função hash pode ser mais facilmente entendida se a imaginarmos como um liquidificador.</string>
    <string name="HashFunction10">Vamos dar uma olhada em alguns aspectos da função hash a partir desta premissa.</string>
    <string name="HashFunction11">A 1ª característica é que os valores de dados que eles produzem são de comprimento fixo.</string>
    <string name="HashFunction12">O comprimento dos dados retornados varia de acordo com a função hash. No caso da SHA-1, por exemplo, é fixo em 20 bytes.</string>
    <string name="HashFunction13">Mesmo quando há entrada de muitos dados, a saída dos dados do código hash não variam em comprimento.</string>
    <string name="HashFunction16">Semelhantemente, não importa quão pequeno é a entrada, o comprimento do código hash é o mesmo.</string>
    <string name="HashFunction19">A 2ª característica é que caso sejam fornecidas as mesmas entradas, elas invariavelmente produzirão a mesma saída.</string>
    <string name="HashFunction2">Quando colocamos os dados em uma função hash...</string>
    <string name="HashFunction25">A 3ª característica é que caso sejam fornecidas entradas semelhantes, mesmo que distintas apenas por 1 bit, as saídas delas serão muito distintas.</string>
    <string name="HashFunction3">ela nos retorna um valor irregular.</string>
    <string name="HashFunction31">Não é o caso onde, se dados semelhantes forem inseridos, os códigos hash serão similares, também.</string>
    <string name="HashFunction32">A 4ª característica é que mesmo que dados completamente diferentes sejam fornecidos, pode acontecer de códigos hash idênticos serem produzidos como saída, mesmo que as chances sejam baixas.</string>
    <string name="HashFunction38">Isso é chamado de \"colisão\".</string>
    <string name="HashFunction39">A 5ª característica é que converter códigos hash de volta aos seus dados originais é, na realidade, impossível.</string>
    <string name="HashFunction4">Fica mais fácil de entender se imaginarmos a função hash como uma máquina que mistura todos os dados.</string>
    <string name="HashFunction41">O fluxo de entrada e saída é de mão única, o que é uma grande diferença da \"criptografia\".</string>
    <string name="HashFunction43">Uma última característica que pode ser dada é que seus cálculos são relativamente simples.</string>
    <string name="HashFunction46">Há uma série de algoritmos de função hash, mas atualmente é mais comum o uso do \"SHA-2\".</string>
    <string name="HashFunction47">Das funções hash, pode ser dito que produzem um sumário da entrada de dados, e são usadas em muitas situações.</string>
    <string name="HashFunction48">Exemplos de uso da função hash são explicados em detalhe em \"Autenticadores de Mensagem\" e \"Tabelas de Espalhamento (Hash)\", na seção \"Segurança\" e \"Estruturas de Dados\", respectivamente.</string>
    <string name="HashFunction49">Isto conclui a explicação de funções hash.</string>
    <string name="HashFunction5">O retorno irregular da função hash é chamado de \"código hash\".</string>
    <string name="HashFunction6">Códigos hash são números, mas são frequentemente escritos em hexadecimal.</string>
    <string name="HashFunction7">Os computadores administram todos os dados em binário, que usa os dígitos 0 e 1.</string>
    <string name="HashFunction8">Códigos hash também são dados, e são administrados em binário.</string>
    <string name="HashFunction9">O que uma função hash está fazendo de fato é realizando alguns cálculos dentro do computador.</string>
    <string name="Heap">Heaps</string>
    <string name="Heap0">\"Heaps\" são um tipo de estrutura de dados de árvore e são usados ao implementar uma \"fila de prioridade\".</string>
    <string name="Heap1">Uma fila de prioridade é um tipo de estrutura de dados.</string>
    <string name="Heap10">Como o pai (6) é maior que o filho (5), os dois números são trocados.</string>
    <string name="Heap11">Essa operação ocorre até que não ocorram mais trocas.</string>
    <string name="Heap12">O pai (1) é menor que o filho (5), então como o pai é menor, não ocorre troca.</string>
    <string name="Heap13">A adição de um número ao heap está completa.</string>
    <string name="Heap14">Ao extrair um número de um heap, o número no topo é removido.</string>
    <string name="Heap15">Num heap, o menor valor é assegurado no topo.</string>
    <string name="Heap16">Em virtude do número do topo ter sido removido, a estrutura do heap precisa ser reorganizada.</string>
    <string name="Heap17">O número no fim da linha desloca-se ao topo.</string>
    <string name="Heap18">Quando um dos números filhos é menor que o pai, o menor filho adjacente troca com o pai.</string>
    <string name="Heap19">O pai (6) era maior que o filho à direita (5) que, por sua vez, era maior que o filho à esquerda (3), então a criança à esquerda e o pai são trocados.</string>
    <string name="Heap2">Numa fila de prioridade, os dados podem ser adicionados em qualquer ordem.</string>
    <string name="Heap20">Essa operação ocorre até que não ocorram mais trocas.</string>
    <string name="Heap22">A criança à direita (8) era maior que o pai (6) que, por sua vez, era maior que a criança à esquerda (4), então a criança à esquerda e o pai são trocados.</string>
    <string name="Heap23">A extração de um número do heap está completa.</string>
    <string name="Heap24">Deste modo, os heaps podem ser usados para rapidamente extrair os menores dados.</string>
    <string name="Heap25">Contudo, a extração dos dados no meio da árvore não pode ser realizada.</string>
    <string name="Heap26">Heaps são usados em regras como filas de prioridade e o algoritmo de Dijkstra.</string>
    <string name="Heap27">Isso conclui a explicação de heaps.</string>
    <string name="Heap3">Por outro lado, ao extrair os dados, os menores valores são escolhidos primeiro.</string>
    <string name="Heap4">Ser livre para adicionar dados e extrair os menores valores primeiro define uma fila de prioridade.</string>
    <string name="Heap5">A seguir, vamos olhar para uma estrutura de heap.</string>
    <string name="Heap6">Como regra de heaps, um número filho é sempre maior que o seu número pai.</string>
    <string name="Heap7">Tentemos adicionar um número ao heap.</string>
    <string name="Heap8">O número adicionado é colocado primeiro no fim da linha.</string>
    <string name="Heap9">Se o número pai for maior, pai e filho são trocados.</string>
    <string name="HeapDescription">\"Heaps\" são estruturas de dados usados para extrair rapidamente valores mais baixos. Você pode estudar este tópico após comprar todos os algoritmos.</string>
    <string name="HeapSort">Ordenação Heapsort</string>
    <string name="HeapSort0">A \"Ordenação Heapsort\" é um algoritmo usado para ordenar uma sequência de números, e conta com o uso da estrutura de dados heap.</string>
    <string name="HeapSort1">Para começar, todos os números são armazenados em um heap (ou monte). Estes heaps são construídos de modo que os números estejam em ordem descendente. Uma explicação mais detalhada de heaps pode ser encontrada em \"Heaps\", na seção \"Estruturas de Dados\".</string>
    <string name="HeapSort10">Para dar um exemplo mais concreto, os elementos (nodos) do heap e o array...</string>
    <string name="HeapSort105">Embora existam métodos mais otimizados para a construção de heaps, desta vez escolhemos um de fácil entendimento.</string>
    <string name="HeapSort11">têm uma relação correspondente, como demonstrado no diagrama.</string>
    <string name="HeapSort15">Como você pode ver, pode ser dito que o heap é apenas amontoado em um array.</string>
    <string name="HeapSort16">Agora, vamos tentar ordenar o array usando o método de swapping (troca).</string>
    <string name="HeapSort17">Para tornar as coisas mais fáceis de serem entendidas, vamos manter visível a estrutura de árvore do heap.</string>
    <string name="HeapSort18">Como antes, vamos começar armazenando os números em um heap.</string>
    <string name="HeapSort20">Enquanto os números no heap de estrutura de árvore trocam de lugares entre si, o mesmo acontece com os números correspondentes no array.</string>
    <string name="HeapSort21">Todos os números foram armazenados no heap. Ao mesmo tempo, fomos capazes de organizar o array em uma estrutura de heap de ordem descendente.</string>
    <string name="HeapSort22">Em seguida, os números armazenados no heap são retirados um por um.</string>
    <string name="HeapSort23">Heaps de ordens descendentes têm seus dados removidos em ordem começando pelos maiores valores.</string>
    <string name="HeapSort24">O primeiro número no array é o maior número no heap.</string>
    <string name="HeapSort25">O primeiro número no array é trocado pelo número correspondente ao último elemento do heap, completando a operação.</string>
    <string name="HeapSort26">O heap é reorganizado de modo que sua estrutura seja mantida.</string>
    <string name="HeapSort27">Esta operação é repetida até que todos os números sejam completamente ordenados.</string>
    <string name="HeapSort28">A ordenação está completa.</string>
    <string name="HeapSort29">Isto conclui a explicação de ordenação heapsort.</string>
    <string name="HeapSort3">Todos os números foram armazenados em um heap.</string>
    <string name="HeapSort4">A seguir, os números armazenados no heap são retirados um por um.</string>
    <string name="HeapSort5">Uma propriedade de heaps descendentes é que os números são removidos do maior para o menor, de modo que se você alinhar os números na ordem oposta (direita para a esquerda) enquanto são removidos, a ordenação fica completa.</string>
    <string name="HeapSort7">Todos os números foram removidos do heap, e a ordenação está completa.</string>
    <string name="HeapSort8">Dessa vez, nós preparamos uma estrutura de dados de heap extra além da sequência de números...</string>
    <string name="HeapSort9">mas, normalmente, o heap é incorporado no mesmo array contendo a sequência de números, e a ordenação reside na simples troca de números.</string>
    <string name="Huffman">Codificação de Huffman</string>
    <string name="Huffman0">A \"Codificação de Huffman\" é um algoritmo usado para codificar dados.</string>
    <string name="Huffman1">É usado para extensões como imagens e arquivos comprimidos em formatos JPEG e ZIP.</string>
    <string name="Huffman10">Como simples exemplo, temos as regras de codificação no diagrama. Um caractere é expressado como tendo 2 bits.</string>
    <string name="Huffman100">A mesma operação é repetida com \"C ou D\" considerados como um caractere.</string>
    <string name="Huffman101">Dois caracteres são encontrados na ordem de menor frequência entre os 3 restantes: \"A\", \"B\", e \"C ou D\".</string>
    <string name="Huffman102" formatted="false">Desta vez, eles são \"A\" (35%) e \"B\" (25%).</string>
    <string name="Huffman103">Os dois caracteres são conectados com uma linha para criar uma estrutura de árvore.</string>
    <string name="Huffman104">Os dois caracteres são combinados em \"A ou B\", e suas frequências são somadas.</string>
    <string name="Huffman105">\"A ou B\" serão considerados como um caractere.</string>
    <string name="Huffman106">Semelhantemente, os 2 caracteres com as menores frequências são escolhidos, mas eles são os 2 caracteres restantes: \"A ou B\" e \"C ou D\".</string>
    <string name="Huffman107">Os dois são conectados com uma linha para criar uma estrutura de árvore.</string>
    <string name="Huffman108">Todos os caracteres se tornaram um como \"A ou B ou C ou D\". Sua frequência de aparição é, claro, 100%.</string>
    <string name="Huffman109">Agora, a estrutura de árvore que facilita a codificação de Huffman está completa.</string>
    <string name="Huffman11">Tentamos codificar \"ABAABACD\" de acordo com as nossas regras, resultando em dados de tamanho de 16 bits, que é uma grande redução.</string>
    <string name="Huffman110">A frequência de aparição de cada caractere foi apresentada mais uma vez.</string>
    <string name="Huffman111">Os códigos \"0\" e \"1\" são atribuídos aos ramos que se estendem para cima e para baixo.</string>
    <string name="Huffman112">Em seguida, a árvore é percorrida de suas raízes para cada caractere, com um código correspondente sendo estabelecido para cada um.</string>
    <string name="Huffman113">No caso de \"A\", o código atribuído a ele é \"00\".</string>
    <string name="Huffman114">No caso de \"B\", o código atribuído a ele é \"01\".</string>
    <string name="Huffman115">No caso de \"C\", o código atribuído a ele é \"10\".</string>
    <string name="Huffman116">No caso de \"D\", o código atribuído a ele é \"11\".</string>
    <string name="Huffman117">A codificação com a codificação de Huffman está completa.</string>
    <string name="Huffman118">A estrutura de árvore está diferente do último exemplo, e como não há grandes diferenças nas frequências de aparição entre os caracteres, todos os caracteres são expressados como códigos de 2 bits.</string>
    <string name="Huffman119">Por exemplo, mesmo se tentarmos expressar \"C\" e \"D\" como tendo 3 bits para expressar o caractere com maior frequência, o \"A\", com 1 bit...</string>
    <string name="Huffman12">É claro, por elas serem regras que nós criamos, precisamos comunicar as regras criadas com o lado que receberá a string de caracteres.</string>
    <string name="Huffman120" formatted="false">devido à frequência de \"C ou D\" (40%) ser maior que a frequência de \"A\" (35%), a eficiência do código piora.</string>
    <string name="Huffman121">Como você pode ver, a codificação de Huffman é capaz de simples e eficientemente codificar baseado na frequência de caracteres.</string>
    <string name="Huffman122">Isto conclui a explicação de codificação de Huffman.</string>
    <string name="Huffman13">Por convenção, nesta explicação vamos ignorar o quanto de tráfego de rede é consumido para transmitir as regras de codificação.</string>
    <string name="Huffman14">Para que o lado que recebe a string de caracteres decodifique-a...</string>
    <string name="Huffman15">se ele dividir o código em segmentos de 2 caracteres...</string>
    <string name="Huffman16">e decodificá-las checando cada segmento a partir das regras, a string de caracteres original \"ABAABACD\" poderá ser extraída.</string>
    <string name="Huffman17">Vamos considerar codificar a string de caracteres \"ABAABACD\" para ser ainda menor.</string>
    <string name="Huffman18">Com as regras anteriores, expressamos um caractere usando 2 bits...</string>
    <string name="Huffman19">mas parece que se expressarmos \"A\" e \"B\" com 1 bit, podemos codificá-la para ser ainda menor.</string>
    <string name="Huffman2">Como exemplo, vamos imaginar que queremos enviar a string de caracteres \"ABAABACD\" através da rede.</string>
    <string name="Huffman20">Ademais, na string de caracteres \"ABAABACD\", os caracteres \"A\" e \"B\" são mais usados do que os caracteres \"C\" e \"D\".</string>
    <string name="Huffman21">Assim sendo, parece que seria melhor expressar \"A\" e \"B\" com 1 bit ao invés de \"C\" e \"D\", de qualquer maneira.</string>
    <string name="Huffman22">Tentamos codificar \"ABAABACD\" de acordo com as nossas regras, resultando em dados de tamanho de 10 bits, que é uma redução ainda maior.</string>
    <string name="Huffman23">Para que o lado que recebe o código decodifique-o em uma string de caracteres...</string>
    <string name="Huffman24">cada caractere deve ser checado à regra de conversão e decodificado...</string>
    <string name="Huffman25">mas o código \"10\", por exemplo, pode expressar tanto \"BA\" como \"C\".</string>
    <string name="Huffman26">Devido a isso, uma string de caracteres diferente foi extraída.</string>
    <string name="Huffman27">Existem várias outras strings de caracteres que também podem ser extraídas, e a sequência de caracteres original não pode ser determinada de forma inequívoca.</string>
    <string name="Huffman28">Quando os caracteres originais não podem ser determinados inequivocamente a partir do código, ele é chamado de \"não decodificável unicamente\".</string>
    <string name="Huffman29">Vamos considerar outro exemplo. Por convenção, vamos assumir que os 2 caracteres \"A\" e \"B\" serão codificados como no diagrama.</string>
    <string name="Huffman3">Os dados serão codificados em binários como 0s e 1s.</string>
    <string name="Huffman30">Vamos considerar os passos para decodificar o código \"000001\" de acordo com essas regras de codificação.</string>
    <string name="Huffman31">Ao decodificar, olhamos para os números do começo ao fim.</string>
    <string name="Huffman32">O primeiro número é \"0\", mas não conseguimos determinar se ele é um \"A\" ou parte de um \"B\".</string>
    <string name="Huffman33">Os primeiros 2 números são \"00\", mas não conseguimos determinar se eles são um \"AA\" ou parte de um \"B\".</string>
    <string name="Huffman34">Os primeiros 3 números são \"000\", mas não conseguimos determinar se eles são um \"AAA\" ou parte de um \"B\".</string>
    <string name="Huffman35">Semelhantemente, não conseguimos fazer uma determinação com os 4 primeiros números...</string>
    <string name="Huffman36">nem com os 5 primeiros números.</string>
    <string name="Huffman37">Finalmente, vemos um 6º número, \"1\", e determina que o primeiro \"0\" é um \"A\", e que o \"00001\" que segue é um \"B\".</string>
    <string name="Huffman38">Podemos decodificar inequivocamente os números \"000001\" em uma string de caracteres \"AB\". Até aqui, não há problemas.</string>
    <string name="Huffman39">Códigos em uma tabela de conversão cujos caracteres originais podem ser determinados assim que eles aparecem são chamados de \"códigos instantâneos\"...</string>
    <string name="Huffman4">Por exemplo, em código de caracteres ASCII, os caracteres \"A\", \"B\", \"C\", e \"D\" são codificados como mostrado no diagrama.</string>
    <string name="Huffman40">mas, como neste exemplo, aqueles cujos caracteres originais não podem ser determinados sem checar os caracteres à frente são chamados de códigos não instantâneos.</string>
    <string name="Huffman41">Por isso, a decodificação leva um tempo.</string>
    <string name="Huffman42">Por uma questão de codificação/decodificação eficaz, os códigos que são unicamente decodificáveis e instantâneos são preferidos.</string>
    <string name="Huffman43">Vamos considerar onde os problemas estão nas 2 regras de codificação usadas como exemplos nos diagramas.</string>
    <string name="Huffman44">Se tentarmos visualizar o primeiro conjunto de regras de codificação...</string>
    <string name="Huffman45">se o primeiro caractere num dado código é \"0\", determinamos que é um \"A\".</string>
    <string name="Huffman46">Contudo, se for um \"1\", pode ser um \"B\", ou possivelmente uma parte de \"C\" ou \"D\".</string>
    <string name="Huffman47">Vamos tentar visualizar o segundo conjunto de regras de codificação da mesma maneira.</string>
    <string name="Huffman48">Dado qualquer código, o primeiro caractere poderá ser somente \"0\".</string>
    <string name="Huffman49">Contudo, este \"0\" pode ser um \"A\" ou uma parte de \"B\".</string>
    <string name="Huffman5">Em ASCII, um caractere possui 8 bits.</string>
    <string name="Huffman50">Para que algo seja unicamente decodificável e instantâneo, deve haver uma condição onde \"nenhum código será parte ou começo de um outro código\".</string>
    <string name="Huffman51">Os dois exemplos anteriores não satisfizeram essa condição.</string>
    <string name="Huffman52">A codificação de Huffman é um algoritmo que nos guia facilmente a códigos que são unicamente decodificáveis e instantâneos.</string>
    <string name="Huffman53">Vamos dar uma olhada em algumas codificações concretas com a codificação de Huffman.</string>
    <string name="Huffman54">A codificação de Huffman produz códigos unicamente decodificáveis e instantâneos.</string>
    <string name="Huffman55">Primeiro, a frequência de aparição de cada caractere é calculada. As frequências são mostradas no diagrama para o caso do \"ABAABACD\".</string>
    <string name="Huffman56">A seguir, os caracteres são organizados na ordem de maior frequência. Neste exemplo, aconteceu de elas ficarem na ordem padrão de \"ABCD\".</string>
    <string name="Huffman57">A seguir, dois caracteres são encontrados na ordem de menor frequência.</string>
    <string name="Huffman58" formatted="false">Neste caso, eles são \"C\" (12.5%) e \"D\" (12.5%).</string>
    <string name="Huffman59">Os dois caracteres são conectados com uma linha para criar uma estrutura de árvore.</string>
    <string name="Huffman6">Usando ASCII, codificamos a string de caracteres \"ABAABACD\", resultando em dados com tamanho de 64 bits.</string>
    <string name="Huffman60">Os dois caracteres são combinados em \"C ou D\", e suas frequências são somadas.</string>
    <string name="Huffman61">A mesma operação é repetida com \"C ou D\" considerados como um caractere.</string>
    <string name="Huffman62">Dois caracteres são encontrados na ordem de menor frequência entre os 3 restantes: \"A\", \"B\", e \"C ou D\".</string>
    <string name="Huffman63" formatted="false">Desta vez, eles são \"B\" (25%) e \"C ou D\" (25%).</string>
    <string name="Huffman64">Os dois caracteres são conectados com uma linha para criar uma estrutura de árvore.</string>
    <string name="Huffman65">Os dois caracteres são combinados em \"B ou C ou D\", e suas frequências são somadas.</string>
    <string name="Huffman66">\"B ou C ou D\" serão considerados apenas um caractere.</string>
    <string name="Huffman67">Semelhantemente, os 2 caracteres com as menores frequências são escolhidos, mas eles são os 2 caracteres restantes: \"A\" e \"B ou C ou D\".</string>
    <string name="Huffman68">Os dois são conectados com uma linha para criar uma estrutura de árvore.</string>
    <string name="Huffman69">Todos os caracteres se tornaram um como \"A ou B ou C ou D\". Sua frequência de aparição é, claro, 100%.</string>
    <string name="Huffman7">Para minimizar o tráfego de rede, vamos considerar codificar a string de caracteres de 64 bits em algo menor.</string>
    <string name="Huffman70">Agora, a estrutura de árvore que facilita a codificação de Huffman está completa.</string>
    <string name="Huffman71">A frequência de aparição de cada caractere foi apresentada mais uma vez.</string>
    <string name="Huffman72">A seguir, iremos para a codificação usando 0s e 1s.</string>
    <string name="Huffman73">Os códigos \"0\" e \"1\" são atribuídos aos ramos que se estendem para cima e para baixo.</string>
    <string name="Huffman74">Não importa se a atribuição de 0s e 1s for ao contrário. No entanto, se você decidir fazer os ramos superiores \"1\", você não poderá alterar o padrão de atribuição no meio do caminho.</string>
    <string name="Huffman75">Todos os códigos foram atribuídos.</string>
    <string name="Huffman76">Em seguida, a árvore é percorrida de suas raízes para cada caractere, com um código correspondente sendo estabelecido para cada um.</string>
    <string name="Huffman77">No caso de \"A\"...</string>
    <string name="Huffman78">o código atribuído a ele é \"0\".</string>
    <string name="Huffman79">No caso de \"B\"...</string>
    <string name="Huffman8">Para distinguir e lidar com uma grande quantidade de caracteres, o ASCII expressa um caractere como tendo 8 bits.</string>
    <string name="Huffman80">o código atribuído a ele é \"10\".</string>
    <string name="Huffman81">No caso de \"C\"...</string>
    <string name="Huffman82">o código atribuído a ele é \"110\".</string>
    <string name="Huffman83">No caso de \"D\"...</string>
    <string name="Huffman84">o código atribuído a ele é \"111\".</string>
    <string name="Huffman85">A codificação com a codificação de Huffman está completa.</string>
    <string name="Huffman86">Isso significa que a string de caracteres \"ABAABACD\" deve ser codificada usando essas regras.</string>
    <string name="Huffman87">É óbvio, a partir da estrutura de árvore, que \"nenhum código será parte do começo de um outro código\".</string>
    <string name="Huffman88">Portanto, eles são unicamente decodificáveis e instantâneos.</string>
    <string name="Huffman89">Além disso, devido aos códigos com números menores de bits serem atribuídos aos caracteres com frequências mais altas de aparição, podemos ver que a codificação é eficaz.</string>
    <string name="Huffman9">Entretanto, apenas 4 caracteres são usados na string de caracteres \"ABAABACD\". À primeira vista, poderíamos codificar estes 4 caracteres de um modo distinguível.</string>
    <string name="Huffman90" formatted="false">Para ser mais concreto, neste exemplo, \"C ou D\" (25%) tem uma menor frequência de aparição do que \"A\" (50%).</string>
    <string name="Huffman91">Além disso, mesmo que \"C ou D\" seja expressado como tendo 3 bits, expressar \"A\" com 1 bit é mais eficiente, o que é refletido nos resultados.</string>
    <string name="Huffman92">Vamos tentar codificar \"ABAABACD\" usando as regras que estabelecemos.</string>
    <string name="Huffman93">O resultado é 14 bits, que é ainda menor do que quando expressamos cada caractere como tendo 2 bits.</string>
    <string name="Huffman94">Vamos olhar para outro exemplo. Desta vez, não haverá uma grande diferença entre a frequência de aparição entre os caracteres.</string>
    <string name="Huffman95">Por convenção, a frequência de aparições diminui na mesma ordem que a string de caracteres. Por este motivo, não há motivos para rearranjá-los.</string>
    <string name="Huffman96">A seguir, os dois caracteres com as menores frequências são encontrados.</string>
    <string name="Huffman97" formatted="false">Neste caso, eles são \"C\" (22%) e \"D\" (18%).</string>
    <string name="Huffman98">Os dois caracteres são conectados com uma linha para criar uma estrutura de árvore.</string>
    <string name="Huffman99">Os dois caracteres são combinados em \"C ou D\", e suas frequências são somadas.</string>
    <string name="HuffmanDescription">A \"Codificação de Huffman\" é um algoritmo usado em arquivos de formatos como JPEG e ZIP. Você pode estudar este tópico após comprar todos os algoritmos.</string>
    <string name="HybridEncoding">Criptografia Híbrida</string>
    <string name="HybridEncoding0">Com a criptografia de chave privada, há o problema de como trocar de chaves de forma segura.</string>
    <string name="HybridEncoding1">Em contrapartida, com a criptografia de chave pública, há o problema de processamento lento durante criptografia e descriptografia.</string>
    <string name="HybridEncoding10">Ao criptografar esta chave com a criptografia de chave pública, ela pode ser mandada de forma segura para B.</string>
    <string name="HybridEncoding11">A parte B, o destinatário, cria as chaves pública e secreta.</string>
    <string name="HybridEncoding12">A chave pública é enviada para a parte A.</string>
    <string name="HybridEncoding13">A parte A usa a chave pública que ela recebeu da parte B...</string>
    <string name="HybridEncoding14">e criptografa a chave a ser usada com a criptografia de chave privada.</string>
    <string name="HybridEncoding15">A chave criptografada é enviada à parte B.</string>
    <string name="HybridEncoding16">A parte B usa sua chave secreta...</string>
    <string name="HybridEncoding17">e descriptografa o texto cifrado contendo a chave.</string>
    <string name="HybridEncoding18">Deste modo, a parte A foi capaz de enviar de forma protegida a chave usada na criptografia de chave pública para a parte B.</string>
    <string name="HybridEncoding19">A única coisa restante a fazer agora é usar a chave e enviar os dados criptografados.</string>
    <string name="HybridEncoding2">A \"criptografia híbrida\" é um sistema que combina as duas de modo a compensar os erros de cada uma.</string>
    <string name="HybridEncoding20">O processamento mais rápido da criptografia de chave privada é usado para criptografar os dados.</string>
    <string name="HybridEncoding21">A parte B foi capaz de obter os dados originais sem problema algum.</string>
    <string name="HybridEncoding22">Deste modo, a criptografia híbrida combina tanto segurança quanto processamento ágil.</string>
    <string name="HybridEncoding23">Como é usado em SSL, um sistema que torna possível a troca segura de informações pela internet, é um tipo de criptografia sem o qual não podemos viver.</string>
    <string name="HybridEncoding24">Isto conclui a explicação de criptografia híbrida.</string>
    <string name="HybridEncoding3">Ela usa criptografia de chave privada que processa rapidamente criptografia de dados.</string>
    <string name="HybridEncoding4">Contudo, as chaves usadas pela criptografia de chave privada são trocadas usando o método mais seguro, o de criptografia de chave pública.</string>
    <string name="HybridEncoding5">Vamos observar mais atentamente a criptografia híbrida em ação.</string>
    <string name="HybridEncoding6">Digamos que a parte A deseja enviar dados para a parte B pela internet.</string>
    <string name="HybridEncoding7">Os dados são criptografados com o processamento mais ágil da criptografia de chave privada.</string>
    <string name="HybridEncoding8">Pela chave necessária à criptografia ser também usada para descriptografia, a parte A precisa enviar a chave para a parte B.</string>
    <string name="HybridEncoding9">A chave também é uma forma de dados.</string>
    <string name="HybridEncodingDescription">A \"Criptografia Híbrida\" é um método que combina as criptografias de chave privada e chave pública. Você pode estudar este tópico após comprar todos os algoritmos.</string>
    <string name="IABSetUpFailed">A conexão com o Google Play falhou. Por favor, tenha certeza de que você está conectado na sua conta Google.</string>
    <string name="Inquiry">Feedback</string>
    <string name="InquiryConfirmation">Confirmar</string>
    <string name="InquiryEmail">E-mail</string>
    <string name="InquiryFailed">Um erro ocorreu ao enviar sua mensagem. Por favor, espere um pouco e tente novamente.</string>
    <string name="InquiryIsSendOK">Enviar feedback?</string>
    <string name="InquiryName">Nome</string>
    <string name="InquiryOptional">(opcional)</string>
    <string name="InquiryPleaseInput">Por favor, digite sua mensagem na caixa de feedback.</string>
    <string name="InquiryPleaseSmall">Por favor, digite sua mensagem usando 1000 caracteres ou menos.</string>
    <string name="InquirySend">Enviar</string>
    <string name="InquirySuccess">Muito obrigado pelo seu feedback. Ele será levado em consideração para futuras melhorias do app.</string>
    <string name="InquirySuccessTitle">Feedback enviado</string>
    <string name="InsertionSort">Ordenação por Inserção</string>
    <string name="InsertionSort0">A \"Ordenação por Inserção\" (insertion) é um algoritmo usado para ordenar uma sequência de números.</string>
    <string name="InsertionSort1">Para começar, o número mais à esquerda é considerado completamente ordenado.</string>
    <string name="InsertionSort10">e comparado com o número à sua esquerda.</string>
    <string name="InsertionSort11">5 é maior que 4, então os números trocam de lugar.</string>
    <string name="InsertionSort12">3 é menor que 4. Um número menor apareceu, então 4 para de se mover.</string>
    <string name="InsertionSort13">O número 4 é agora considerado totalmente ordenado.</string>
    <string name="InsertionSort14">As mesmas operações são repetidas até que todos os números sejam completamente ordenados.</string>
    <string name="InsertionSort18">Todos os números estão ordenados, então a ordenação está completa.</string>
    <string name="InsertionSort19">Isto conclui a explicação de ordenação por inserção.</string>
    <string name="InsertionSort2">Depois, dos números restantes, o número mais à esquerda é escolhido...</string>
    <string name="InsertionSort3">e comparado com o já ordenado número à esquerda dele.</string>
    <string name="InsertionSort4">Se o número já ordenado for maior, os dois números trocam de lugar.</string>
    <string name="InsertionSort5">Esta operação é repetida até que ou um número menor apareça, ou o número selecionado chegue até a ponta esquerda.</string>
    <string name="InsertionSort6">Neste caso, 5 é maior que 3, então os números trocam de lugar.</string>
    <string name="InsertionSort7">O número alcançou a ponta esquerda, então o número para de se mover.</string>
    <string name="InsertionSort8">O número 3 é agora considerado totalmente ordenado.</string>
    <string name="InsertionSort9">Como antes, o número mais à esquerda dos números remanescentes é escolhido...</string>
    <string name="KmeansClustering">Algoritmo K-Means</string>
    <string name="KmeansClustering0">O \"Algoritmo K-Means\" é um tipo de algoritmo usado em clusterização de grafos.</string>
    <string name="KmeansClustering1">Clusterização é uma operação onde, dado um grupo de dados...</string>
    <string name="KmeansClustering10">Os pontos centrais dos 3 clusters são colocados em localizações aleatórias.</string>
    <string name="KmeansClustering100">As distâncias mais curtas para pontos centrais são calculadas mais uma vez, e os pontos de dados são reagrupados em clusters.</string>
    <string name="KmeansClustering101">Em clusterização, cada grupo é chamado de \"cluster\".</string>
    <string name="KmeansClustering11">A partir de cada ponto de dado, calculamos a distância até o centro de cluster mais próximo.</string>
    <string name="KmeansClustering12">Cada ponto de dado é agrupado em um dos clusters predeterminados.</string>
    <string name="KmeansClustering13">A média entre os pontos de dados em cada cluster é calculada e o ponto central do cluster é movido para lá.</string>
    <string name="KmeansClustering14">Devido a esta realocação dos pontos centrais, é possível que o ponto central mais próximo possa mudar para alguns pontos de dados.</string>
    <string name="KmeansClustering15">Esse processo de atribuir cada ponto de dados a um cluster e mover o ponto central para a média do grupo se repete até que a convergência dos pontos centrais tenha sido alcançada.</string>
    <string name="KmeansClustering2">ocorre a classificação de dados similares em grupos.</string>
    <string name="KmeansClustering26">A convergência dos pontos centrais foi alcançada, então as operações são concluídas.</string>
    <string name="KmeansClustering27">É provado matematicamente que, à medida que a operação se repete, os pontos centrais convergirão em algum lugar.</string>
    <string name="KmeansClustering28">A clusterização está completa.</string>
    <string name="KmeansClustering29">Podemos ver que os pontos de dados foram devidamente agrupados com outros pontos similares.</string>
    <string name="KmeansClustering3">A base para a similaridade varia de acordo com o algoritmo, dependendo de fatores como distância entre pontos de dados ou suas coordenadas.</string>
    <string name="KmeansClustering30">Agora, vamos tentar usar o algoritmo K-Means com os mesmos dados usando apenas 2 clusters e ver o que acontece.</string>
    <string name="KmeansClustering31">Colocamos os pontos centrais aleatoriamente...</string>
    <string name="KmeansClustering32">e repetimos o processo de atribuir cada ponto de dado a um cluster e mover o ponto central para a média do grupo, até que a convergência dos pontos centrais seja alcançada.</string>
    <string name="KmeansClustering4">O algoritmo K-Means usa a distância do centro de cada cluster para classificar os dados.</string>
    <string name="KmeansClustering43">A convergência dos pontos centrais foi alcançada.</string>
    <string name="KmeansClustering44">Desta vez, 2 grupos de dados, o da esquerda e o de baixo, foram agrupados em um único cluster.</string>
    <string name="KmeansClustering45">Como você pode ver, em razão do número de clusters ser necessariamente definido antes do algoritmo K-Means começar, se o número não estiver configurado adequadamente, haverá momentos onde não obteremos resultados significativos.</string>
    <string name="KmeansClustering46">Há uma série de técnicas usadas para adivinhar o número apropriado de clusters, como analisar os dados antecipadamente, ou simplesmente executar o algoritmo várias vezes, alterando o número de clusters para cada vez.</string>
    <string name="KmeansClustering47">A seguir, vamos tentar executar o algoritmo K-Means mais uma vez usando os mesmos dados, mas com nossos pontos centrais iniciais em diferentes posições do que antes.</string>
    <string name="KmeansClustering48">Novamente, repetimos o processo de atribuição de cada ponto de dados a um cluster e movimentação do ponto central para a média do grupo até a convergência dos pontos centrais ter sido alcançada.</string>
    <string name="KmeansClustering5">Agora, vamos observar o algoritmo em ação.</string>
    <string name="KmeansClustering58">A convergência dos pontos centrais foi alcançada.</string>
    <string name="KmeansClustering59">Em contraste com a execução anterior, os dois grupos nos cantos superior e inferior direito foram agrupados em um único cluster.</string>
    <string name="KmeansClustering6">Primeiro, preparamos os dados para a clusterização.</string>
    <string name="KmeansClustering60">Como você pode ver, os resultados diferentes de agrupamentos, devido à colocação aleatória das localizações dos pontos centrais iniciais, são uma característica do algoritmo K-Means.</string>
    <string name="KmeansClustering61">Isto conclui a explicação de algoritmo K-Means.</string>
    <string name="KmeansClustering7">Depois, determinamos o número de clusters.</string>
    <string name="KmeansClustering8">Decidir o número de clusters precedentemente é uma característica do algoritmo K-Means.</string>
    <string name="KmeansClustering9">Desta vez, usaremos 3 clusters.</string>
    <string name="KmeansClusteringDescription">O \"Algoritmo K-Means\" é um simples mas amplamente usado método de análise de dados. Você pode estudar este tópico após comprar todos os algoritmos.</string>
    <string name="LangColon">Linguagem:</string>
    <string name="LetsUnlock">Com sua compra, você será capaz de estudar todos os tópicos. Vamos dominar os algoritmos juntos!</string>
    <string name="LinearSearch">Busca Linear</string>
    <string name="LinearSearch0">A \"Busca Linear\" é um algoritmo usado para buscar por elementos em um array.</string>
    <string name="LinearSearch1">Vamos tentar procurar pelo número 6.</string>
    <string name="LinearSearch2">Primeiro, examinamos o número do canto mais à esquerda do array.</string>
    <string name="LinearSearch3">Nós o comparamos com o número 6, e se houver correspondência, a procura é encerrada. Se os números não corresponderem, examinamos o próximo número à direita.</string>
    <string name="LinearSearch4">Repetimos as comparações até que o número 6 seja encontrado.</string>
    <string name="LinearSearch5">Encontramos o número 6, então a busca é encerrada.</string>
    <string name="LinearSearch6">Como você pode ver, a busca linear é uma técnica simples para realizar comparações repetidas na mesma ordem, a partir do início.</string>
    <string name="LinearSearch7">Quando há muitos dados, o número de comparações aumenta, tornando a busca mais demorada.</string>
    <string name="LinearSearch8">Isto conclui a explicação de busca linear.</string>
    <string name="List">Listas</string>
    <string name="List0">\"Listas\" são um tipo de estrutura de dados e podem armazenar múltiplos valores.</string>
    <string name="List1">Elas são únicas em como emparelham dados com \"ponteiros\" indicando a localização da memória do próximo dado (também chamadas de Listas Ligadas).</string>
    <string name="List12">Isto conclui a explicação de listas.</string>
    <string name="List2">Em listas, os dados são armazenados em várias posições não sequenciais da memória.</string>
    <string name="List4">Pelo fato dos dados serem armazenados em diferentes posições, cada pedaço de dado pode ser acessado apenas pelo ponteiro que o precede.</string>
    <string name="List9">A adição de dados é realizada simplesmente substituindo os ponteiros em ambos os lados da adição.</string>
    <string name="ListSearchSection">Busca em Lista</string>
    <string name="MAC">Autenticadores de Mensagem (MAC)</string>
    <string name="MAC0">\"Autenticadores de Mensagem (MAC)\" são um sistema que implementa duas funções: detecção de autenticação e falsificação.</string>
    <string name="MAC1">Primeiro, vamos dar uma olhada em uma situação onde autenticadores de mensagem são necessários.</string>
    <string name="MAC10">O texto cifrado é enviado para a parte B...</string>
    <string name="MAC11">que descriptografa o texto cifrado e obtém a mensagem contendo o código do produto.</string>
    <string name="MAC12">Não houve problemas neste caso, mas o que vem a seguir pode acontecer.</string>
    <string name="MAC13">Vamos voltar ao ponto onde a parte A envia o texto cifrado para a parte B.</string>
    <string name="MAC14">Digamos que a parte X maliciosa...</string>
    <string name="MAC15">falsificou o texto cifrado que a parte A estava tentando enviar para a parte B durante a transmissão.</string>
    <string name="MAC16">A parte B recebe o texto cifrado, mas não há como saber se ele foi falsificado.</string>
    <string name="MAC17">Quando a parte B descriptografa o texto cifrado, na mensagem lê-se \"xyz\".</string>
    <string name="MAC18">Acreditando que \"xyz\" é o código do produto requisitado, a parte B manda o produto incorreto para a parte A.</string>
    <string name="MAC19">Em razão da criptografia não ser mais que um processo de computar valores, cálculos de descriptografia ainda podem ser realizados sobre um texto cifrado que foi falsificado.</string>
    <string name="MAC2">A fim de comprar um produto da parte B, a parte A envia uma mensagem que mostra o código do produto \"abc\".</string>
    <string name="MAC20">Se a mensagem original foi uma mensagem longa, e a mensagem falsificada se torna uma sentença desprovida de significado, há a possibilidade de que alguém notará a falsificação.</string>
    <string name="MAC21">Entretanto, com dados sobre os quais os humanos não possuem entendimento direto, como códigos de produto, pode ser muito dificultoso identificar esses tipos de falsificação após a descriptografia.</string>
    <string name="MAC22">A fim de detectar falsificações, um cuidado extra além da criptografia é necessário.</string>
    <string name="MAC23">Se você usar autenticadores de mensagem, você conseguirá detectar falsificações. Vamos dar uma olhada em como eles funcionam.</string>
    <string name="MAC24">Retornamos novamente ao ponto onde a parte A envia o texto cifrado para a parte B.</string>
    <string name="MAC25">A parte A cria uma chave que será usada para criar um autenticador de mensagem...</string>
    <string name="MAC26">e envia a chave para a parte B usando um método seguro.</string>
    <string name="MAC27">Depois, a parte A cria um valor usando o texto cifrado e a chave...</string>
    <string name="MAC28">e o valor \"7f05\" é obtido.</string>
    <string name="MAC29">Este valor criado pela combinação da chave e o texto cifrado é chamado de \"código de autenticação de mensagem (autenticador de mensagem)\".</string>
    <string name="MAC3">A parte A criptografa a mensagem.</string>
    <string name="MAC30">É comumente abreviado como \"MAC\", e passará a ser escrito dessa forma pelo restante desta explicação.</string>
    <string name="MAC31">Um MAC pode ser imaginado como um \"código hash\" de uma string de caracteres compostas pela chave e pelo texto cifrado.</string>
    <string name="MAC32">Uma explicação mais detalhada de funções hash pode ser encontrada em \"Funções Hash\", na seção \"Segurança\".</string>
    <string name="MAC33">Há uma variedade de maneiras para se criar MACs, como \"HMAC\", \"OMAC\", e \"CMAC\". Hoje em dia, o método \"HMAC\" é o mais utilizado.</string>
    <string name="MAC34">A parte A envia à parte B o MAC que ela criou junto com o texto cifrado.</string>
    <string name="MAC35">A parte B recebe o texto cifrado e o MAC.</string>
    <string name="MAC36">Agora, a parte B precisa checar se o texto cifrado foi ou não falsificado.</string>
    <string name="MAC37">Como a parte A fez, a parte B também usa o texto cifrado e a chave para criar um MAC.</string>
    <string name="MAC38">A parte B foi capaz de confirmar que o MAC que ela criou combina com o MAC recebido da parte A.</string>
    <string name="MAC39">Portanto, a parte B sabe que o texto cifrado que ela recebeu não foi falsificado.</string>
    <string name="MAC4">Digamos que eles usem criptografia de chave privada para a encriptação.</string>
    <string name="MAC40">Só falta usar a chave do texto cifrado e descriptografar a mensagem.</string>
    <string name="MAC41">A mensagem contendo o código \"abc\" do produto que a parte A pediu foi extraída com sucesso.</string>
    <string name="MAC42">Vamos retornar ao ponto onde a parte A envia o texto cifrado para a parte B.</string>
    <string name="MAC43">Vamos ver o que acontece quando uma parte X maliciosa tenta falsificar a mensagem durante a transmissão.</string>
    <string name="MAC44">Digamos que entre o texto cifrado e o MAC que a parte A enviou para a parte B...</string>
    <string name="MAC45">a parte X tenha falsificado o texto cifrado.</string>
    <string name="MAC46">Contudo, quando a parte B calcula o MAC do seu lado novamente...</string>
    <string name="MAC47">ela descobre que não combina com o MAC recebido da parte A.</string>
    <string name="MAC48">Daí, a parte B sabe que o texto cifrado, o MAC, ou ambos podem ter sido falsificados.</string>
    <string name="MAC49">Neste caso, é melhor descartar o texto cifrado e o MAC e requisitar que a parte A os reenvie.</string>
    <string name="MAC5">A parte A passa essa chave para a parte B usando um método seguro.</string>
    <string name="MAC50">Então, é possível que a parte X falsifique o MAC também, de modo que seja consistente com o texto cifrado falsificado?</string>
    <string name="MAC51">Em razão da parte X não ter a chave usada para criar o MAC...</string>
    <string name="MAC52">mesmo que ela consiga falsificá-lo, ainda não é possível torná-lo consistente com o texto cifrado falsificado.</string>
    <string name="MAC53">Como esperado, quando a parte B recalcula o MAC e não coincide com o MAC emparelhado com o texto cifrado falsificado, fica claro que algum tipo de falsificação ocorreu durante a transmissão.</string>
    <string name="MAC55">Como você pode ver, ao usar autenticadores de mensagem, ou MACs, podemos prevenir falsificações durante transmissões.</string>
    <string name="MAC56">Contudo, há imperfeições até mesmo com autenticadores de mensagem.</string>
    <string name="MAC57">Vamos tentar simplificar o processo.</string>
    <string name="MAC58">Primeiro, ambas as partes A e B compartilham a chave usada para criptografar a mensagem e calcular o MAC.</string>
    <string name="MAC59">Por consequência...</string>
    <string name="MAC6">Métodos de troca de chaves usam protocolos como a criptografia de chave privada ou o a troca de chaves de Diffie-Hellman.</string>
    <string name="MAC60">assim que a parte A consegue criptografar a mensagem e calcular o MAC...</string>
    <string name="MAC63">a parte B também consegue criptografar a mensagem e calcular o MAC.</string>
    <string name="MAC66">Em outras palavras, você não consegue verificar de fato se foi a parte A ou a parte B quem criou a mensagem original.</string>
    <string name="MAC67">Por isso, se fosse o caso da parte A ser maliciosa...</string>
    <string name="MAC68">uma vez que a mensagem fosse enviada, ela poderia afirmar que foi fabricada pela parte B, permitindo-a \"repudiar\" o fato de que ela enviou a mensagem ela mesma.</string>
    <string name="MAC7">Tanto a criptografia de chave privada quanto a troca de chaves de Diffie-Hellman são explicadas mais detalhadamente em \"Criptografia de Chave Privada\" e \"Troca de Chaves de Diffie-Hellman\", respectivamente, na seção \"Segurança\".</string>
    <string name="MAC71">A fim de prevenir esse tipo de repudiação, faz-se necessário o uso de \"assinaturas digitais\", explicadas detalhadamente em \"Assinaturas Digitais\" nesta mesma seção, \"Segurança\".</string>
    <string name="MAC72">Isto conclui a explicação de autenticadores de mensagem.</string>
    <string name="MAC8">A parte A usa a chave privada e criptografa a mensagem.</string>
    <string name="MarkAllAsRead">Marcar todos como lido</string>
    <string name="MarkAllAsUnread">Marcar todos como não lido</string>
    <string name="MathSection">Matemática</string>
    <string name="MergeSort">Ordenação Mergesort</string>
    <string name="MergeSort0">A \"Ordenação Mergesort\" (ou Ordenação por Fusão) é um algoritmo usado para ordenar uma sequência de números.</string>
    <string name="MergeSort1">Primeiro, a sequência é dividida continuamente em metades.</string>
    <string name="MergeSort10">Quando os grupos com múltiplos números são combinados, os primeiros números são comparados.</string>
    <string name="MergeSort11">No diagrama, os primeiros números 4 e 3 serão comparados.</string>
    <string name="MergeSort12">4 é maior que 3, então o 3 é movido.</string>
    <string name="MergeSort13">As linhas restantes têm seus primeiros números comparados da mesma forma...</string>
    <string name="MergeSort14">4 é menor que 7, então o 4 é movido.</string>
    <string name="MergeSort15">6 é menor que 7, então o 6 é movido.</string>
    <string name="MergeSort16">O 7 que sobrou é movido.</string>
    <string name="MergeSort17">A combinação dos grupos é repetida recursivamente até que todos os números formem um único grupo.</string>
    <string name="MergeSort22">A combinação está completa, e a sequência foi ordenada.</string>
    <string name="MergeSort23">Isto conclui a explicação de ordenação mergesort.</string>
    <string name="MergeSort5">As divisões estão completas.</string>
    <string name="MergeSort6">Agora, os grupos divididos são combinados.</string>
    <string name="MergeSort7">Ao serem combinados, os números de cada grupo são organizados de modo que sejam ordenados do menor para o maior após a combinação.</string>
    <string name="MergeSortDescription">A \"Ordenação Mergesort\" é única em como consegue dividir uma sequência de números em grupos menores e, então, colocá-los em ordem. Você pode estudar este tópico após comprar todos os algoritmos.</string>
    <string name="NowBuying">Processando...</string>
    <string name="OK">OK</string>
    <string name="OthersSection">Outros</string>
    <string name="PKC">Criptografia de Chave Pública</string>
    <string name="PKC0">A \"criptografia de chave pública\" é um sistema de criptografia que usa chaves diferentes para encriptação e decriptação.</string>
    <string name="PKC1">A chave usada para encriptação é chamada de \"chave pública\", e a chave usada para decriptação é chamada de \"chave secreta\".</string>
    <string name="PKC10">O texto cifrado é enviado para a parte B.</string>
    <string name="PKC11">A parte B usa a chave secreta e descriptografa o texto cifrado recebido da parte A.</string>
    <string name="PKC12">Agora, a parte B possui os dados originais.</string>
    <string name="PKC13">Em razão de chaves públicas e o texto cifrado terem sido enviados pela internet...</string>
    <string name="PKC14">há uma chance de serem interceptadas por uma terceira parte maliciosa.</string>
    <string name="PKC15">Contudo, por efeito do texto cifrado não poder ser descriptografado com uma chave pública, a parte X não consegue obter os dados originais.</string>
    <string name="PKC16">Assim, ao contrário da criptografia de chave privada, o problema de entrega das chaves não ocorre com a criptografia de chave pública.</string>
    <string name="PKC17">A criptografia de chave pública possui um mérito adicional de tornar fácil a troca de informação entre números não especificados de partes. Vamos dar uma olhada mais atenta.</string>
    <string name="PKC18">Digamos que a parte B preparou uma chave pública e uma chave secreta antecipadamente.</string>
    <string name="PKC19">A chave pública ser conhecida por outros não é um problema.</string>
    <string name="PKC2">Comparada à criptografia de chave privada, a criptografia de chave pública tende a tomar mais tempo tanto para criptografia quanto para descriptografia.</string>
    <string name="PKC20">Assim, a parte B pode publicar a chave pública na internet.</string>
    <string name="PKC21">Por outro lado, a chave secreta não pode ser conhecida pelos outros, então ela precisa ser bem guardada.</string>
    <string name="PKC22">Digamos que há muitas pessoas querendo enviar dados para a parte B.</string>
    <string name="PKC23">As pessoas mandando dados obtém a chave pública compartilhada pela parte B...</string>
    <string name="PKC24">e criptografa os dados que elas querem enviar.</string>
    <string name="PKC25">Elas enviam o texto cifrado para a parte B.</string>
    <string name="PKC26">A parte B usa a chave secreta e descriptografa o texto cifrado delas.</string>
    <string name="PKC27">A parte B obteve os dados originais.</string>
    <string name="PKC28">Como você pode ver, não há a necessidade de preparar uma chave para cada pessoa que queira enviar dados.</string>
    <string name="PKC29">Além disso, em virtude do receptor dos dados ser a única parte que possui a chave que precisa ser privada, o método possui um grande nível de segurança.</string>
    <string name="PKC3">Apresentados no diagrama estão alguns cálculos usados na criptografia de chave pública.</string>
    <string name="PKC30">Contudo, há 2 problemas com a criptografia de chave pública.</string>
    <string name="PKC31">O 1º problema é que toma um tempo considerável tanto para encriptação quanto para decriptação.</string>
    <string name="PKC32">Por causa disso, não é adequada para trocar pequenas quantidades de dados, nesse sistema de \"vaivém\".</string>
    <string name="PKC33">Como uma solução para este problema, há a \"criptografia híbrida\", explicada mais detalhadamente na seção, \"Segurança\", em \"Criptografia Híbrida\".</string>
    <string name="PKC34">O 2º problema relaciona-se à confiabilidade das chaves públicas.</string>
    <string name="PKC35">Vamos voltar ao ponto onde a parte B criara as chaves pública e secreta.</string>
    <string name="PKC36">Por convenção, vamos representar a chave pública criada pela parte B como \"PB\", e a chave secreta como \"SB\".</string>
    <string name="PKC37">A parte X, que almeja interceptar os dados que a parte A está mandando para a parte B, cria uma chave pública \"PX\" e uma chave secreta \"SX\".</string>
    <string name="PKC38">Quando a parte B está para enviar a chave pública PB para a parte A...</string>
    <string name="PKC39">a parte X secretamente troca a chave pública PB pela chave pública PX que ela criou...</string>
    <string name="PKC4">Atualmente, a Criptografia RSA é amplamente utilizada, e é explicada em mais detalhes em outra parte deste aplicativo.</string>
    <string name="PKC40">e dá a chave pública PX para a parte A.</string>
    <string name="PKC41">Não há como saber quem criou uma chave pública.</string>
    <string name="PKC42">Sendo assim, a parte A é incapaz de notar que a chave pública que ela recebeu fora secretamente trocada.</string>
    <string name="PKC43">A parte A criptografa os dados com a chave pública PX.</string>
    <string name="PKC44">Quando a parte A está para enviar o texto cifrado para a parte B...</string>
    <string name="PKC45">a parte X recebe este texto cifrado.</string>
    <string name="PKC46">Por este texto cifrado ter sido criptografado com a chave pública PX que a parte X preparou...</string>
    <string name="PKC47">a parte X consegue descriptografá-la com a chave secreta SX em sua posse.</string>
    <string name="PKC48">Agora, a parte X conseguiu com sucesso interceptar os dados que a parte A estava tentando enviar para a parte B.</string>
    <string name="PKC49">A seguir, a parte X criptografa os dados com a chave pública PB da parte B.</string>
    <string name="PKC5">Vejamos a imagem mais ampla de como os dados são trocados usando a criptografia de chave pública.</string>
    <string name="PKC50">O texto cifrado resultante é dado à parte B.</string>
    <string name="PKC51">Como este texto cifrado foi criado com a chave pública PB que a parte B preparou, a parte B consegue descriptografá-la com a chave secreta SB em sua posse.</string>
    <string name="PKC52">Em razão da parte B ter sido capaz de descriptografar o texto cifrado, eles nem pensam sobre os dados terem sido interceptados por outra pessoa.</string>
    <string name="PKC53">Este método de ataque de interceptação de dados substituindo secretamente chaves públicas no ato da ação é chamado de \"ataque man-in-the-middle\" (ou \"ataque do homem do meio\").</string>
    <string name="PKC54">O problema está enraizado no fato de que a parte A não consegue verificar se a chave pública recebida foi ou não criada pela parte B.</string>
    <string name="PKC55">Para resolver este problema, um sistema de \"certificados digitais\" é usado. \"Certificados Digitais\" são explicados mais detalhadamente nesta seção, \"Segurança\".</string>
    <string name="PKC56">Isto conclui a explicação de criptografia de chave pública.</string>
    <string name="PKC6">Digamos que a parte A queira enviar dados para a parte B pela internet.</string>
    <string name="PKC7">Primeiro, o receptor (parte B) cria uma chave pública e uma chave secreta.</string>
    <string name="PKC8">A chave pública é enviada à parte A.</string>
    <string name="PKC9">A parte A usa a chave pública que recebeu da parte B e criptografa os dados.</string>
    <string name="PageRank">PageRank</string>
    <string name="PageRank0">O \"PageRank\" é um algoritmo usado para determinar a ordem dos resultados encontrados ao pesquisar um site.</string>
    <string name="PageRank1">A história do Google se tornar uma corporação global usando seu algoritmo em seus motores de pesquisa é bem famosa.</string>
    <string name="PageRank10">Daremos às páginas que não possuem ligações a pontuação 1.</string>
    <string name="PageRank100">Se visualizarmos esta atividade a partir do espaço da internet, parece que os internautas...</string>
    <string name="PageRank101">estão se teletransportando repetidamente para páginas completamente alheias depois de moverem-se entre um número indeterminado de páginas relacionadas.</string>
    <string name="PageRank11">A pontuação de uma página com ligações apontadas a ela é a combinação de pontos das páginas que estão apontando para ela.</string>
    <string name="PageRank12">Contudo, quando há ligações para múltiplas páginas...</string>
    <string name="PageRank13">a pontuação das ligações é distribuída igualmente entre elas.</string>
    <string name="PageRank14">Em PageRank, uma ligação de uma página com muitas ligações possui um alto valor.</string>
    <string name="PageRank15">A página no centro do diagrama possui ligações apontando para ela a partir de três páginas independentes, então sua pontuação é 3.</string>
    <string name="PageRank16">A página do topo possui uma pontuação alta porque ela possui uma ligação de uma página com pontuação 3.</string>
    <string name="PageRank17">Das seis páginas neste diagrama, foi determinado que a página mais importante é a do topo.</string>
    <string name="PageRank18">Esse é o pensamento básico por trás do PageRank.</string>
    <string name="PageRank19">Com este método, um problema acontece quando as ligações formam um loop.</string>
    <string name="PageRank2">Até aquele ponto, a ordem dos resultados de pesquisa era determinada focalizando nas palavras-chave de pesquisa e suas relações com frases dentro da página.</string>
    <string name="PageRank20">Se você calcular a pontuação de cada página na ordem...</string>
    <string name="PageRank24">como você pode ver, ela entra num loop infinito, e as pontuações das páginas no loop aumentam indefinidamente.</string>
    <string name="PageRank25">Este problema do loop (chamado de Rank Sink) é resolvido usando um cálculo chamado de \"fator de amortecimento\" (conhecido como \"random surfer model\").</string>
    <string name="PageRank26">Vamos pensar sobre como uma pessoa visualiza as páginas da web enquanto navega pela internet.</string>
    <string name="PageRank27">Digamos que em uma ocasião, ela visite uma página que soa interessante, mencionada em uma revista. A partir dessa página inferior esquerda...</string>
    <string name="PageRank28">ela segue uma ligação e move-se para uma página diferente...</string>
    <string name="PageRank29">Após ver algumas páginas, ela perde o interesse...</string>
    <string name="PageRank3">Com este método, não era levado em consideração se a página continha ou não informações úteis. Por isso, não poderia ser dito que os resultados de busca possuíam alta precisão.</string>
    <string name="PageRank30">e para de navegar por um tempo.</string>
    <string name="PageRank31">Então, em um outro dia, ela começa sua navegação numa página completamente diferente, recomendada por um amigo.</string>
    <string name="PageRank32">Seguindo uma ligação, ela se move para uma página diferente...</string>
    <string name="PageRank33">e para de navegar assim que perde o interesse.</string>
    <string name="PageRank34">E assim se repete a ação de começar a olhar para uma página e mover-se para um número de tantas outras antes de parar.</string>
    <string name="PageRank35">Se definirmos as ações dos internautas, obteremos algo como o seguinte.</string>
    <string name="PageRank36">Probabilidade 1-α é a probabilidade que 1 ligação, entre as ligações da página atual, tem de ser escolhida.</string>
    <string name="PageRank37">Probabilidade α é a probabilidade de a pessoa se teletransportar para outra página.</string>
    <string name="PageRank38">Como exemplo, nesta explicação faremos α, a probabilidade de teletransporte, ser 15%.</string>
    <string name="PageRank39">Vamos tentar simular a transição entre páginas de acordo com essa definição.</string>
    <string name="PageRank4">O PageRank é um algoritmo que calcula o valor de uma página da estrutura de links entre as páginas. Vamos dar uma olhada em como funciona até os cálculos serem feitos.</string>
    <string name="PageRank40">Como antes, consideraremos o que acontece quando as ligações formam um loop.</string>
    <string name="PageRank41">O número de cada página representa o número de vezes que o internauta visitou aquela página.</string>
    <string name="PageRank42">Atualmente, como não começamos a simulação, todos os números são 0.</string>
    <string name="PageRank43">Executando a simulação de acordo com a definição, uma diferença surge no número de visitas a cada página.</string>
    <string name="PageRank49">Vamos acelerar a passagem do tempo.</string>
    <string name="PageRank5">Digamos que os quadrados são páginas da web, e as setas representam as ligações entre elas.</string>
    <string name="PageRank50">Executamos a simulação até que o número total de páginas visitadas alcançou 1000.</string>
    <string name="PageRank51">Expressar os resultados como porcentagens nos dá os números no diagrama.</string>
    <string name="PageRank52">Podemos dizer que esses valores expressam a probabilidade de alguém estar visualizando uma das páginas em um determinado momento.</string>
    <string name="PageRank53">Usar esses valores para a pontuação das páginas é o fator de amortecimento.</string>
    <string name="PageRank54">Como você pode ver, ao usar este método, conseguimos calcular a pontuação mesmo se as ligações criam um loop.</string>
    <string name="PageRank55">Na realidade, métodos mais práticos de cálculo são usados ao invés de simulações. Agora vamos apresentá-los.</string>
    <string name="PageRank56">Vamos tentar calcular a pontuação para cada página em uma complexa rede de ligações como neste diagrama.</string>
    <string name="PageRank57">Primeiro, determinamos a pontuação inicial de cada página.</string>
    <string name="PageRank58">As pontuações são definidas igualmente para que todas elas resultem em 1.</string>
    <string name="PageRank59">Em seguida, encontraremos as probabilidades de um internauta estar em cada página após se mover uma vez.</string>
    <string name="PageRank6">Este diagrama mostra que as 3 páginas inferiores contêm ligações à página superior.</string>
    <string name="PageRank60">Expressaremos a probabilidade de estar em A depois de n movimentos como PAn. Semelhantemente, a probabilidade de estar em B após n movimentos é PBn.</string>
    <string name="PageRank61">Como exemplo, vamos achar a probabilidade de um internauta estar em A depois de se mover 1 vez (PA1).</string>
    <string name="PageRank62">Um cenário para estar em A é que a pessoa em C decide se mover, não se teletransportar...</string>
    <string name="PageRank63">e escolhe A, não B, como destino.</string>
    <string name="PageRank64">A probabilidade de alguém estar em C durante o estado inicial (quando 0 movimentos foram realizados) é PC0 (igual a 0,25).</string>
    <string name="PageRank65">Além disso, a probabilidade da pessoa em C mover é 1-α, e a probabilidade de escolher A entre A ou B é 0,5.</string>
    <string name="PageRank66">Por isso, a probabilidade de mover de C para A é PC0 x (1-α) x 0,5.</string>
    <string name="PageRank67">Outro cenário para estar em A é a pessoa, estando em qualquer página entre A-D, escolher se teletransportar...</string>
    <string name="PageRank68">e escolher A como seu destino de teletransporte.</string>
    <string name="PageRank69">A probabilidade de a pessoa em qualquer uma das páginas, A-D, escolher se teletransportar é α.</string>
    <string name="PageRank7">No algoritmo PageRank, quanto mais ligações uma página possuir, mais importante aquela página é considerada.</string>
    <string name="PageRank70">Além disso, a probabilidade de A ser escolhido como destino de teletransporte é 0,25.</string>
    <string name="PageRank71">Por isso, a probabilidade de teletransporte para A é α x 0,25.</string>
    <string name="PageRank72">A partir das probabilidades mencionadas acima, descobrimos que a probabilidade de estar em A depois de se mover 1 vez (PA1) é igual a PC0 x (1-α) x 0,5 + α x 0,25.</string>
    <string name="PageRank73">Fazendo as substituições PC0 = 0,25 e α = 0,15, calculamos PA1 = 0,14375.</string>
    <string name="PageRank74">Da mesma forma, calculamos as probabilidades de estar em B, C e D, e atualizamos os valores.</string>
    <string name="PageRank75">Os resultados são apresentados no diagrama.</string>
    <string name="PageRank76">Em seguida, encontraremos as probabilidades de um internauta estar em cada página após se mover 2 vezes.</string>
    <string name="PageRank77">Os resultados são apresentados no diagrama.</string>
    <string name="PageRank78">Repetimos os mesmos cálculos, e a probabilidade de alguém estar em cada página começa a se aproximar de um valor fixo.</string>
    <string name="PageRank79">Uma vez que os valores se estabeleceram, os cálculos estão completos.</string>
    <string name="PageRank8">Aqui, é determinado que a página do topo é a mais importante.</string>
    <string name="PageRank80">Os valores calculados deste modo são as pontuações para cada página.</string>
    <string name="PageRank81">Finalmente, verificamos se esses valores do PageRank correspondem aos cálculos das ligações que abordamos.</string>
    <string name="PageRank82">Usando os mesmos métodos de antes, tentaremos calcular as pontuações para a estrutura de ligações no diagrama.</string>
    <string name="PageRank83">Uma vez que os valores são arredondados, suas somas não resultam em 1, mas você pode ver que a relação está próxima dos resultados anteriores.</string>
    <string name="PageRank84">Vamos calcular as pontuações para essa estrutura de ligações também.</string>
    <string name="PageRank85">Estes também estão próximos dos índices que obtivemos antes.</string>
    <string name="PageRank86">Desta forma, o sistema PageRank, ao fazer cálculos, antecede ligações relacionadas a favor das probabilidades que as páginas da web têm de serem visitadas.</string>
    <string name="PageRank87">Na realidade, a ordem dos resultados de pesquisa do Google não é alcançada apenas pelo PageRank.</string>
    <string name="PageRank88">Contudo, isso não tira o fato de que o algoritmo PageRank foi revolucionário em seus dois conceitos...</string>
    <string name="PageRank89">de calcular valores de páginas a partir de estruturas de ligações e ser capaz de realizar cálculos mesmo quando as ligações formam loops.</string>
    <string name="PageRank9">Na realidade, a importância de cada página é calculada para um valor numérico. Primeiro, vamos explicar a ideia básica por trás do método de cálculo.</string>
    <string name="PageRank90">Isto conclui a explicação de PageRank.</string>
    <string name="PageRankDescription">\"PageRank\" é um indicador usado para determinar a ordem de exibição dos resultados de um mecanismo de pesquisa. Você pode estudar este tópico após comprar todos os algoritmos.</string>
    <string name="PrimalityTest">Teste de Primalidade</string>
    <string name="PrimalityTest0">O \"Teste de primalidade\" é um método usado para determinar se um número natural é ou não um número primo.</string>
    <string name="PrimalityTest1">Um número primo é um número natural (n > 1) que não possui divisor além do 1 e ele mesmo.</string>
    <string name="PrimalityTest100">Antes de entrarmos na explicação do que são testes de primalidade, vamos explicar a operação mod.</string>
    <string name="PrimalityTest101">A operação mod é uma operação que encontra o resto de uma divisão.</string>
    <string name="PrimalityTest102">Para A mod B, temos C, o resto de A dividido por B.</string>
    <string name="PrimalityTest103">Alguns exemplos de operações usando números concretos</string>
    <string name="PrimalityTest17">Em outras palavras, o resultado aponta que 3599 não é um número primo.</string>
    <string name="PrimalityTest18">Contudo, este método leva mais tempo à medida em que o número fica maior, tornando-o irrealista.</string>
    <string name="PrimalityTest19">O \"teste de primalidade de Fermat\" é um método que contorna este problema.</string>
    <string name="PrimalityTest2">A criptografia RSA, uma técnica de criptografia moderna comumente usada, lida com uma vasta quantidade de números primos.</string>
    <string name="PrimalityTest20">O teste de primalidade de Fermat é um método que determina possíveis primos, e determina se a probabilidade de primalidade é alta.</string>
    <string name="PrimalityTest21">Como pré-requisito, vamos olhar à natureza dos números primos.</string>
    <string name="PrimalityTest22">Como exemplo, vamos pensar na natureza do número primo 5.</string>
    <string name="PrimalityTest23">Os resultados para as operações de pegar cada número menor que 5 e potencializá-los a 5 são mostrados no diagrama.</string>
    <string name="PrimalityTest28">A seguir, realizamos a operação mod em cada número para encontrar seu resto quando dividido por 5...</string>
    <string name="PrimalityTest29">Os resultados dos cálculos são apresentados no diagrama.</string>
    <string name="PrimalityTest3">O teste de primalidade desempenha um papel crucial na criptografia RSA.</string>
    <string name="PrimalityTest30">Quando examinamos os números originais e seus restos, percebemos que eles são iguais.</string>
    <string name="PrimalityTest31">A partir disso, pelo menos para o número primo 5, vemos que a fórmula no diagrama funciona.</string>
    <string name="PrimalityTest32">Desta vez, consideraremos o número composto 6.</string>
    <string name="PrimalityTest33">Um \"número composto\" é um número natural que não é primo. O número 6 pode ser expressado como 2 x 3, não sendo um número primo.</string>
    <string name="PrimalityTest34">Quando realizamos os mesmos cálculos...</string>
    <string name="PrimalityTest4">Exemplificando, vamos julgar se 3599 é ou não um número primo.</string>
    <string name="PrimalityTest41">percebemos que nos casos 2 e 5, os números originais não combinam com seus respectivos restos.</string>
    <string name="PrimalityTest42">Isso prova que, como previsto, a fórmula no diagrama funciona não apenas para o número 5, mas para todos os primos p.</string>
    <string name="PrimalityTest43">Isso é chamado de \"pequeno teorema de Fermat\".</string>
    <string name="PrimalityTest44">Chamamos de teste de Primalidade de Fermat o método para determinar números primos. Este método determina se certos números primos satisfarão ou não o o pequeno teorema de Fermat.</string>
    <string name="PrimalityTest45">Vamos determinar se o número 113 é ou não um número primo usando o teste de primalidade de Fermat.</string>
    <string name="PrimalityTest46">Três números menores que 113 são escolhidos aleatoriamente.</string>
    <string name="PrimalityTest47">Após potencializar estes números por 113, nós os dividimos por 113 e pegamos seus respectivos restos.</string>
    <string name="PrimalityTest48">No caso de cada número, o número original combinou com o resto.</string>
    <string name="PrimalityTest49">Quanto mais vezes as combinações são confirmadas, maior é a probabilidade de primalidade.</string>
    <string name="PrimalityTest5">Um método possível é dividir 3599 por números maiores do que 2, em ordem, observando se é possível a divisão para cada um.</string>
    <string name="PrimalityTest50">Contudo, confirmar cada número menor que p leva muito tempo.</string>
    <string name="PrimalityTest51">Na prática, depois de checar uma certa quantia de números, se a probabilidade de primalidade é alta o bastante, o número é considerado um possível primo.</string>
    <string name="PrimalityTest52">Como exemplo, uma versão melhorada do teste de primalidade de Fermat, chamado de teste de primalidade de Miller-Rabin, é usado para determinar números primos na criptografia RSA...</string>
    <string name="PrimalityTest53">mas, se depois de repetir o teste, a probabilidade de um número não ser primo for inferior a 50% até a potência de 80, esse número é considerado um número primo.</string>
    <string name="PrimalityTest54">Além disso, mesmo que um número satisfaça totalmente o teste de primalidade de Fermat, não é garantido de que ele é um número primo.</string>
    <string name="PrimalityTest55">Se o número sendo testado for um número primo, ele satisfará totalmente o teste de primalidade de Fermat.</string>
    <string name="PrimalityTest56">Por outro lado, enquanto os números compostos geralmente serão capturados pelo teste de primalidade de Fermat quando testados...</string>
    <string name="PrimalityTest57">há números compostos que, mesmo sendo extremamente raro, satisfarão totalmente o teste de primalidade de Fermat como um número primo satisfaria.</string>
    <string name="PrimalityTest58">Por exemplo, consideremos o número 561.</string>
    <string name="PrimalityTest59">O número 561 é um número composto que pode ser expressado por 3 x 187, ou 11 x 51, e assim por diante, não sendo um número primo.</string>
    <string name="PrimalityTest6">\"Divisível\" significa que a operação mod, uma operação que encontra o resto de uma divisão, resulta em zero.</string>
    <string name="PrimalityTest60">Contudo, ele satisfaz o teste de primalidade de Fermat.</string>
    <string name="PrimalityTest63">Esse tipo de número composto é chamado de \"número de Carmichael\", ou \"número pseudoprimo\".</string>
    <string name="PrimalityTest64">O diagrama mostra alguns números de Carmichael em ordem, começando pelos menores, e podemos ver que há muito pouco deles.</string>
    <string name="PrimalityTest65">É correto dizer que números primos satisfazem plenamente o teste de primalidade de Fermat, mas não podemos dizer que um número é um número primo apenas porque satisfaz plenamente o teste de primalidade de Fermat.</string>
    <string name="PrimalityTest66">No máximo, o teste de primalidade de Fermat é um método para determinar possíveis primos.</string>
    <string name="PrimalityTest67">Contudo, é usado na maioria dos casos porque não há outros métodos mais eficientes.</string>
    <string name="PrimalityTest68">Isto conclui a explicação de teste de primalidade.</string>
    <string name="PrimalityTest7">A raiz quadrada de 3599 é 59,99..., então percorrendo os números 2 até 59 através da operação mod deve bastar.</string>
    <string name="PrimalityTest8">Como resultado, vemos que 3599 é divisível por 59.</string>
    <string name="PrimalityTestDescription">No \"Teste de Primalidade\", explicamos o teste de primalidade de Fermat, um método capaz de determinar primos prováveis. Você pode estudar este tópico após comprar todos os algoritmos.</string>
    <string name="Queue">Filas</string>
    <string name="Queue0">\"Filas\" são um tipo de estrutura de dados.</string>
    <string name="Queue1">Filas, como o próprio nome sugere, podem ser facilmente imaginadas como um grupo de pessoas esperando em linha.</string>
    <string name="Queue10">Isto conclui a explicação de filas.</string>
    <string name="Queue2">Em filas, quanto antes uma pessoa entra, maior é sua prioridade.</string>
    <string name="Queue3">Ao adicionar dados em uma fila, o dado é colocado no fim.</string>
    <string name="Queue5">Usamos o termo \"enfileirar\" (enqueue) para referir ao ato de adicionar dados em uma fila.</string>
    <string name="Queue6">Ao extrair dados de uma fila, o dado que esteve na fila por mais tempo é removido primeiro.</string>
    <string name="Queue8">Usamos o termo \"desenfileirar\" (dequeue) para referir ao ato de retirar dados de uma fila.</string>
    <string name="Queue9">Este método de extrair o primeiro dado inserido é chamado de \"First In First Out\" (FIFO, ou Primeiro que Entra, Primeiro que Sai).</string>
    <string name="QuickSort">Ordenação Quicksort</string>
    <string name="QuickSort0">A \"Ordenação Quicksort\" (ou Ordenação Rápida) é um algoritmo usado para ordenar uma sequência de números.</string>
    <string name="QuickSort1">Uma característica do quicksort é que há menos comparações e trocas do que outros algoritmos, sendo assim capaz de ordenar rapidamente em boa parte dos casos.</string>
    <string name="QuickSort100">Vamos observar o algoritmo em ação.</string>
    <string name="QuickSort101">Uma seta será colocada no pivô para facilitar a referência.</string>
    <string name="QuickSort102">Depois, uma seta esquerda será colocada no número mais à esquerda, e uma seta direita será colocada no número mais à direita.</string>
    <string name="QuickSort103">O algoritmo quicksort utiliza essas setas para realizar conjuntos de operações recursivas repetidamente.</string>
    <string name="QuickSort105">Desta forma, a seta esquerda atua para encontrar números maiores ou iguais ao pivô, e a seta direita encontra números menores que o pivô.</string>
    <string name="QuickSort106">Ao trocar os números, você pode juntar números que são menores que o pivô no lado esquerdo da sequência, e números que são maiores ou iguais ao pivô no lado direito.</string>
    <string name="QuickSort107">Isto conclui a primeira rodada de operações.</string>
    <string name="QuickSort11">4 é menor que 6, então a seta para de se mover.</string>
    <string name="QuickSort12">Quando ambas setas esquerda e direita pararem de se moverem, os números apontados pelas setas são trocados de lugar.</string>
    <string name="QuickSort13">Depois da troca, a seta esquerda continua movendo-se à direita.</string>
    <string name="QuickSort14">Como antes, a seta esquerda move-se até encontrar um número maior ou igual ao pivô.</string>
    <string name="QuickSort18">9 é maior ou igual ao 6, então a seta para de se mover.</string>
    <string name="QuickSort19">Mais uma vez, a seta direita move-se para a esquerda.</string>
    <string name="QuickSort2">A primeira operação envolve toda a sequência de números.</string>
    <string name="QuickSort21">O movimento também para quando a seta direita encontra a seta esquerda.</string>
    <string name="QuickSort22">Quando as duas setas param, estando na mesma posição, aquele número e o do pivô são trocados de lugar.</string>
    <string name="QuickSort23">O número ocupado por ambas as setas esquerda e direita é considerado totalmente ordenado.</string>
    <string name="QuickSort24">Com uma rodada de operações...</string>
    <string name="QuickSort25">fomos capazes de colocar números menores que o pivô à esquerda do pivô,</string>
    <string name="QuickSort26">e números maiores que o pivô à direita do pivô.</string>
    <string name="QuickSort27">Outra rodada de operações será realizada recursivamente em ambas sequências criadas pela divisão.</string>
    <string name="QuickSort28">A seguir, operações serão realizadas na sequência do lado esquerdo à divisão.</string>
    <string name="QuickSort29">As 3 setas são colocadas.</string>
    <string name="QuickSort3">Um número é escolhido como referência para a ordenação. Este número é chamado de \"pivô\".</string>
    <string name="QuickSort30">A mesma operação de antes é realizada.</string>
    <string name="QuickSort4">A seta esquerda se moverá à direita.</string>
    <string name="QuickSort40">A rodada de operações está concluída...</string>
    <string name="QuickSort41">e fomos capazes de separar a sequência de números menores que o pivô à esquerda do pivô...</string>
    <string name="QuickSort42">dos números maiores que o pivô à direita do pivô.</string>
    <string name="QuickSort43">Outra rodada de operações é repetida recursivamente.</string>
    <string name="QuickSort44">Agora, o lado esquerdo da divisão passará pela operação.</string>
    <string name="QuickSort45">Quando a sequência em destaque possuir apenas um número, ela será considerada totalmente ordenada.</string>
    <string name="QuickSort47">Agora, as operações serão realizadas no lado direito criado pela 2ª rodada de operações.</string>
    <string name="QuickSort48">As 3 setas são colocadas.</string>
    <string name="QuickSort49">A seta esquerda se moverá à direita.</string>
    <string name="QuickSort50">Mesmo quando a seta esquerda se encontrar com a seta direita, ela não parará. Neste aspecto, ela difere da seta direita.</string>
    <string name="QuickSort51">Quando a seta esquerda alcançar o canto direito da sequência em destaque, ela para.</string>
    <string name="QuickSort52">Isso significa que o número do pivô é o maior número da sequência em destaque.</string>
    <string name="QuickSort53">Em seguida, a seta direita seria movida, mas como foi ultrapassada pela seta esquerda, ela conclui seus movimentos, sem se mover novamente.</string>
    <string name="QuickSort54">Quando a seta esquerda tiver alcançado a ponta direita da sequência em destaque, o pivô é considerado totalmente ordenado, e a rodada de operações é encerrada.</string>
    <string name="QuickSort55">Daqui em diante, as mesmas operações serão repetidas até que todos os números tenham sido ordenados.</string>
    <string name="QuickSort6">Quando a seta esquerda alcançar um número maior ou igual ao número pivô, ela parará de se mover.</string>
    <string name="QuickSort7">Neste caso, 8 é maior ou igual a 6, então a seta para de se mover.</string>
    <string name="QuickSort8">Depois, a seta direita se moverá à esquerda.</string>
    <string name="QuickSort83">Todos os números foram ordenados.</string>
    <string name="QuickSort84">Isto conclui a explicação de quicksort.</string>
    <string name="QuickSort9">Quando a seta direita alcança um número menor que o número do pivô, ela para.</string>
    <string name="QuickSort99">O pivô costuma ser um número escolhido aleatoriamente. Desta vez, por convenção, o número mais à direita será escolhido como o pivô.</string>
    <string name="QuickSortDescription">A \"Ordenação Quicksort\" é única pelo número baixo de comparações e trocas que realiza. Você pode estudar este tópico após comprar todos os algoritmos.</string>
    <string name="Random">Aleatório</string>
    <string name="RateThisApp">Avaliar este app</string>
    <string name="RecursionSection">Recursividade</string>
    <string name="Restore">Restaurar histórico de compras</string>
    <string name="RestoreAlert">Os registros foram recuperados e as compras serão restauradas. Você não será cobrado novamente.</string>
    <string name="RestoreBuyingLog">Restaurar histórico de compras</string>
    <string name="RestoreSuccessed">Histórico de compras restaurado</string>
    <string name="Reversed">Inverso</string>
    <string name="ReviewConfirmation">Abra a App Store</string>
    <string name="ReviewConfirmationAndroid">Abra a loja Google Play</string>
    <string name="RunLength">Codificação Run-Length</string>
    <string name="RunLength0">Vamos tentar codificar uma imagem desenhada usando três cores em uma grade 5x5.</string>
    <string name="RunLength1">Primeiro, usaremos um método simples.</string>
    <string name="RunLength10">Essas operações são chamadas de \"compressão\" e \"descompressão\".</string>
    <string name="RunLength11">A codificação run-length é adequada para alguns tipos de dados, mas não tão recomendada para outros.</string>
    <string name="RunLength12">Se olharmos atentamente para a linha codificada, veremos que, como um todo, o número de caracteres foi diminuído...</string>
    <string name="RunLength13">mas as partes onde não há mesmas cores consecutivas acabaram por aumentar o número de caracteres após ser codificada pela run-length.</string>
    <string name="RunLength14">Por exemplo, se aplicarmos codificação run-length para dados como este, que possui poucos mesmos caracteres consecutivos...</string>
    <string name="RunLength15">os dados dobram para 50 caracteres.</string>
    <string name="RunLength16">Inversamente, quando aplicamos codificação run-length em dados com continuidade de caracteres como este...</string>
    <string name="RunLength17">os dados codificados ficam com 10 caracteres. Comparado ao original que era 25, foi comprimido uma quantia considerável.</string>
    <string name="RunLength18">Como você pode ver, dependendo do alvo, há vezes em que a compressão é eficaz, e vezes em que não é.</string>
    <string name="RunLength19">Por consequência, várias estratégias são necessárias, tais como usar codificação run-length apenas para dados cujo número de caracteres consecutivos for maior do que um número estabelecido.</string>
    <string name="RunLength2">Designamos uma letra para cada uma das cores, L para Laranja, V para Verde, e A para Azul.</string>
    <string name="RunLength20">Por exemplo, vamos considerar usar codificação run-length em um fax monocromático.</string>
    <string name="RunLength21">Se simplesmente designarmos o B para branco e o P para preto para expressar cada quadrado quando esta imagem for enviada, o resultado será de 25 caracteres.</string>
    <string name="RunLength22">Para reduzir a quantidade de tráfego, vamos comprimir os dados com codificação run-length.</string>
    <string name="RunLength23">O resultado nos dá 26 caracteres, um aumento de 1, então usar run-length aqui foi inexpressivo.</string>
    <string name="RunLength24">Contudo, uma imagem monocromática usa apenas duas cores, preto e branco.</string>
    <string name="RunLength25">Assim sendo, se alcançarmos o fim de uma sequência de brancos, o próximo quadrado sempre será preto.</string>
    <string name="RunLength26">Aparentemente, somos capazes de restaurar a imagem do código mesmo sem as letras B e P.</string>
    <string name="RunLength27">B e P foram omitidos, resultando num total de 13 caracteres, uma compressão com cerca da metade do tamanho anterior.</string>
    <string name="RunLength28">Contudo, precisamos estabelecer uma regra de modo que saibamos que o primeiro número do código se refere ao número de quadrados brancos consecutivos.</string>
    <string name="RunLength29">Com tal regra, podemos restaurar corretamente a imagem do código.</string>
    <string name="RunLength3">Como resultado da transformação das linhas em Ls, Vs e As, uma linha de cada vez começando pelo canto superior esquerdo, fomos capazes de codificar a figura em uma linha de 25 letras.</string>
    <string name="RunLength30">Então, como podemos fazer para codificar a seguinte imagem?</string>
    <string name="RunLength31">Contrastando com a imagem anterior, o primeiro quadrado é preto, não branco.</string>
    <string name="RunLength32">Por ora, tentaremos codificar a imagem usando o mesmo método que o anterior.</string>
    <string name="RunLength33">O primeiro número no código, 6, refere-se ao número consecutivo de quadrados pretos...</string>
    <string name="RunLength34">mas isto não segue a nossa regra que diz que \"o primeiro número do código se refere ao número de quadrados brancos consecutivos\".</string>
    <string name="RunLength35">Se restaurarmos a imagem do código atual, resultará em uma imagem com pretos e brancos invertidos.</string>
    <string name="RunLength36">Para que sigamos absolutamente a nossa regra de que \"o primeiro número no código se refere ao número de quadrados brancos consecutivos\", um 0 é adicionado no começo do código.</string>
    <string name="RunLength37">Isso nos diz de que há zero quadrados brancos, ou seja, não há quadrados brancos no começo da imagem.</string>
    <string name="RunLength38">Ao adicionar o zero no começo do código, o número de caracteres do código aumentou em um, mas fomos capazes de comprimir os dados seguindo a nossa regra estabelecida.</string>
    <string name="RunLength39">No geral, pode-se dizer que a codificação run-length é voltada mais para comprimir imagens do que textos, que possuem poucas repetições de dados.</string>
    <string name="RunLength4">Depois, usando codificação run-length na imagem, vamos tentar expressá-la em menos de 25 letras.</string>
    <string name="RunLength40">O desejado é uma estratégia que exiba resultados de compressão superiores em ambos os casos.</string>
    <string name="RunLength41">Isto conclui a explicação de codificação run-length.</string>
    <string name="RunLength5">\"Codificação run-length\" (ou RLE) é um método de codificação que transforma um código, e o número de vezes em que ele se repete, em um conjunto.</string>
    <string name="RunLength6">Por exemplo, podemos expressar os primeiros \"LLLL\" como \"L4\", que consegue reduzir dois caracteres.</string>
    <string name="RunLength7">As mesmas operações são repetidas, completando a codificação run-length.</string>
    <string name="RunLength8">Como resultado, o código ficou cinco caracteres mais curto, comprimido para 20.</string>
    <string name="RunLength9">Se sabemos que a imagem tem 5 quadrados por linha, a imagem original pode ser extraída do código.</string>
    <string name="SecurityBase">Básico de Criptografia</string>
    <string name="SecurityBase0">Por que exatamente precisamos de criptografia no mundo da internet moderna?</string>
    <string name="SecurityBase1">Vamos supor que a parte A esteja tentando enviar alguns dados pela internet para a parte B.</string>
    <string name="SecurityBase10">Se você criptografa os dados, não há nada a se preocupar, mesmo que uma terceira parte maliciosa intercepte-os.</string>
    <string name="SecurityBase11">Por isso, criptografia tem se tornado muito importante no mundo da internet atual.</string>
    <string name="SecurityBase12">A seguir, vamos dar uma olhada mais atenta para quais tipos exatos de operações são envolvidas em criptografia.</string>
    <string name="SecurityBase13">Primeiro, independentemente do tipo dos dados, o computador gerencia-os como binário, que usa os dígitos 0 e 1.</string>
    <string name="SecurityBase14">Há uma variedade de formatos de dados, tais como textos, músicas e vídeos...</string>
    <string name="SecurityBase15">mas dentro do computador, todos os dados são manipulados como valores binários.</string>
    <string name="SecurityBase150">Aqui explicamos a necessidade da criptografia, a ideia de que os dados são tratados como valores numéricos, e que a criptografia é um cálculo numérico.</string>
    <string name="SecurityBase16">Vamos pensar a respeito da criptografia de dados tendo isto em mente.</string>
    <string name="SecurityBase17">Para um computador, dados são uma sequência significativa de números.</string>
    <string name="SecurityBase18">Mesmo o texto cifrado sendo manipulado como uma sequência de números, são números aleatórios que o computador não consegue decifrar.</string>
    <string name="SecurityBase19">Criptografia significa realizar algum tipo de cálculo nos dados e torná-los números que o computador não consegue decifrar.</string>
    <string name="SecurityBase2">Os dados são entregues para a parte B, passando por uma variedade de redes e dispositivos na internet.</string>
    <string name="SecurityBase20">Uma \"chave\" é usada para os cálculos numéricos da criptografia.</string>
    <string name="SecurityBase21">Esta chave também é feita de valores numéricos.</string>
    <string name="SecurityBase22">Em outras palavras, ao usar uma chave para cálculos numéricos, a criptografia converte os dados em algo que não pode ser lido.</string>
    <string name="SecurityBase23">Inversamente, ao usar uma chave para cálculos numéricos, a descriptografia muda o texto cifrado de volta para seus dados originais.</string>
    <string name="SecurityBase24">Por exemplo, vamos dar uma olhada no que acontece quando o método de cálculo \"XOR\" é usado com os dados e os valores da chave representados.</string>
    <string name="SecurityBase25">XOR (Ou-Exclusivo) é uma operação que faz cálculos baseados nesta \"tabela verdade\".</string>
    <string name="SecurityBase26">Uma característica do XOR é que estas expressões resultam em verdadeiro.</string>
    <string name="SecurityBase27">Isso significa que se C é o resultado do cálculo de XOR sobre os valores A e B,</string>
    <string name="SecurityBase28">você pode realizar um cálculo XOR mais uma vez usando C ao invés de A ou B para obter o outro valor.</string>
    <string name="SecurityBase29">Usando a chave para realizar um cálculo XOR nos dados...</string>
    <string name="SecurityBase3">Portanto, se os dados são enviados como estão...</string>
    <string name="SecurityBase30">fomos capazes de obter este texto cifrado.</string>
    <string name="SecurityBase31">Agora, vamos tentar descriptografar este texto cifrado.</string>
    <string name="SecurityBase32">Usando a chave mais uma vez para realizar o cálculo XOR no texto cifrado...</string>
    <string name="SecurityBase33">fomos capazes de obter os dados originais.</string>
    <string name="SecurityBase34">Como você pode ver, a mesma chave é usada para criptografia e descriptografia ao usar o cálculo XOR para criptografar os dados.</string>
    <string name="SecurityBase35">Isto conclui a explicação de básico de criptografia.</string>
    <string name="SecurityBase4">há uma chance de serem interceptados por uma terceira parte maliciosa.</string>
    <string name="SecurityBase5">Por esta razão, faz-se necessário criptografar os dados que você deseja manter privados antes de enviá-los.</string>
    <string name="SecurityBase6">Dados que foram criptografados são chamados de \"textos cifrados\" (ou \"ciphertexts\").</string>
    <string name="SecurityBase7">O texto cifrado é enviado para a parte B.</string>
    <string name="SecurityBase8">A parte B descriptografa o texto cifrado recebido da parte A e obtém os dados originais.</string>
    <string name="SecurityBase9">Este processo de restaurar dados criptografados à sua forma original é chamado de \"descriptografia\".</string>
    <string name="SecurityBasic">Básico de Segurança</string>
    <string name="SecurityBasic0">Ao trocar dados pela internet, os dados chegam à outra parte após passar por uma variedade de redes e dispositivos.</string>
    <string name="SecurityBasic1">Por causa disso, a tecnologia da segurança se torna essencial para usar a internet de modo seguro.</string>
    <string name="SecurityBasic10">Este problema é chamado de \"spoofing\".</string>
    <string name="SecurityBasic11">\#3: Mesmo que a transmissão da mensagem da parte A para a parte B tenha sido concluída...</string>
    <string name="SecurityBasic12">há uma chance de que a parte X tenha sobrescrito a mensagem durante a transmissão.</string>
    <string name="SecurityBasic13">Este problema é chamado de \"falsificação\".</string>
    <string name="SecurityBasic14">Além da falsificação intencional por parte de terceiros, há também a possibilidade de que a mensagem entregue foi danificada por algum mau funcionamento durante a transmissão.</string>
    <string name="SecurityBasic15">\#4: Enquanto a parte B acredita que recebeu uma mensagem da parte A...</string>
    <string name="SecurityBasic16">se o remetente da mensagem, parte A, tinha alguma intenção maliciosa...</string>
    <string name="SecurityBasic17">há uma chance de que a parte A insista mais tarde \"Aquela não é a mensagem que eu enviei!\".</string>
    <string name="SecurityBasic18">Quando algo deste tipo acontece, a internet se torna um meio inviável para transações comerciais ou contratos.</string>
    <string name="SecurityBasic19">Este problema é chamado de \"repudiação\".</string>
    <string name="SecurityBasic2">Para começar, vamos dar uma olhada aos 4 problemas proeminentes que podem ocorrer quando os dados estão sendo enviados pela internet.</string>
    <string name="SecurityBasic20">Introduzimos os quatro problemas proeminentes.</string>
    <string name="SecurityBasic21">Ademais, esses problemas não são limitados para trocas de informações entre pessoas, podendo ocorrer também ao navegar em um site.</string>
    <string name="SecurityBasic22">A seguir, vamos dar uma breve olhada em quais tipos de tecnologias de segurança estão disponíveis para resolvermos esses problemas.</string>
    <string name="SecurityBasic23">Para prevenir o primeiro problema de interceptação, usamos \"criptografia\".</string>
    <string name="SecurityBasic24">Para prevenir o segundo problema de spoofing, podemos usar ou \"autenticadores de mensagens\"...</string>
    <string name="SecurityBasic25">ou \"assinaturas digitais\".</string>
    <string name="SecurityBasic26">Semelhantemente, para prevenir o terceiro problema de falsificação, usamos ou autenticadores de mensagens...</string>
    <string name="SecurityBasic27">ou assinaturas digitais.</string>
    <string name="SecurityBasic28">A tecnologia de assinatura digital também é útil para prevenir o 4º problema, repudiação.</string>
    <string name="SecurityBasic29">Colocando tudo isso em um gráfico, temos este diagrama.</string>
    <string name="SecurityBasic3">\#1: Quando a parte A tenta enviar uma mensagem para a parte B...</string>
    <string name="SecurityBasic30">Além disso, a tecnologia de \"certificado digital\" também serve para resolver o problema, inerente à tecnologia de assinatura digital, da incapacidade de verificar o proprietário da chave pública.</string>
    <string name="SecurityBasic31">Todas essas tecnologias de segurança são explicadas individualmente em mais detalhes nesta mesma seção, \"Segurança\".</string>
    <string name="SecurityBasic32">Isto conclui a explicação de básico de segurança.</string>
    <string name="SecurityBasic4">há a possibilidade de que os conteúdos das mensagens sejam interceptados pela parte X durante a transmissão.</string>
    <string name="SecurityBasic5">Este problema é chamado de \"interceptação\".</string>
    <string name="SecurityBasic6">\#2: Mesmo que a parte A quisesse que a mensagem fosse enviada para a parte B...</string>
    <string name="SecurityBasic7">há uma chance de que a parte X esteja se disfarçando de parte B.</string>
    <string name="SecurityBasic8">Inversamente, mesmo que a parte B acredite que tenha recebido uma mensagem vinda da parte A...</string>
    <string name="SecurityBasic9">há uma chance de que a parte X esteja se disfarçando de parte A.</string>
    <string name="SecuritySection">Segurança</string>
    <string name="SelectionSort">Ordenação por Seleção</string>
    <string name="SelectionSort0">A \"Ordenação por Seleção\" (selection) é um algoritmo usado para ordenar uma sequência de números.</string>
    <string name="SelectionSort1">Usando busca linear, o menor valor na sequência é localizado. Uma explicação mais detalhada de busca linear pode ser encontrada em \"Busca Linear\", na seção \"Busca em Lista\".</string>
    <string name="SelectionSort2">O menor valor é trocado de posição com o número mais à esquerda e é considerado totalmente ordenado.</string>
    <string name="SelectionSort3">Além disso, se o menor valor for o que está mais à esquerda, nenhuma operação é realizada.</string>
    <string name="SelectionSort4">As mesmas operações são repetidas até que todos os números sejam completamente ordenados.</string>
    <string name="SelectionSort6">A ordenação está completa.</string>
    <string name="SelectionSort7">Isto conclui a explicação de ordenação por seleção.</string>
    <string name="Setting">Configurações</string>
    <string name="SettingNotShowUnreadButtons">Omitir indicadores \"não lido\"</string>
    <string name="Share">Compartilhe e avalie este app</string>
    <string name="ShareOnFacebook">Compartilhar no Facebook</string>
    <string name="ShareOnTwitter">Compartilhar no Twitter</string>
    <string name="Shuffle">Misturar</string>
    <string name="SortSection">Ordenação</string>
    <string name="Stack">Pilhas</string>
    <string name="Stack0">\"Pilhas\" são um tipo de estrutura de dados.</string>
    <string name="Stack1">A estrutura de uma pilha pode ser facilmente imaginada como um monte de objetos empilhados verticalmente.</string>
    <string name="Stack10">Isto conclui a explicação de pilhas.</string>
    <string name="Stack2">Ao extrair esses objetos, eles são removidos do topo, em ordem.</string>
    <string name="Stack3">Ao adicionar dados à pilha, os dados são colocados na posição mais baixa possível.</string>
    <string name="Stack5">Usamos o termo \"empilhar\" (push) para nos referirmos ao ato de adicionar dados na pilha.</string>
    <string name="Stack6">Ao extrair dados da pilha, o dado colocado mais recentemente é o removido primeiro.</string>
    <string name="Stack8">Usamos o termo \"desempilhar\" (pop) para nos referirmos ao ato de extrair dados da pilha.</string>
    <string name="Stack9">Este método de extrair o dado mais recentemente adicionado é chamado de \"Last In First Out\" (LIFO, ou Último que Entra, Primeiro que Sai).</string>
    <string name="ThankYouForUnlocking">Muito obrigado por comprar Algoritmos: Explicados e Animados. Esperamos que goste de usá-lo!</string>
    <string name="ToSendUs">Para nos mandar uma requisição ou um relatório de bug, por gentileza usar a seção \"Feedback\".</string>
    <string name="Unlock">Adquira todos os algoritmos</string>
    <string name="UnlockSuccessed">Compra dos algoritmos finalizada</string>
    <string name="WEB">Redes</string>
    <string name="YouCanLearnAfter">\"%@\" pode ser estudado após a compra de todos os algoritmos.</string>
    <string name="YouCanLearnAfterAndroid">\"%s\" pode ser estudado após a compra de todos os algoritmos.</string>
    <string name="YouCanRestore">Se você já adquiriu todos os algoritmos, você pode visualizar todos os tópicos novamente restaurando seu histórico de compras.</string>
    <string name="abc_action_bar_home_description">Navegar para a página inicial</string>
    <string name="abc_action_bar_up_description">Navegar para cima</string>
    <string name="abc_action_menu_overflow_description">Mais opções</string>
    <string name="abc_action_mode_done">Concluído</string>
    <string name="abc_activity_chooser_view_see_all">Ver tudo</string>
    <string name="abc_activitychooserview_choose_application">Selecione um app</string>
    <string name="abc_capital_off">DESATIVAR</string>
    <string name="abc_capital_on">ATIVAR</string>
    <string name="abc_search_hint">Pesquisar...</string>
    <string name="abc_searchview_description_clear">Limpar consulta</string>
    <string name="abc_searchview_description_query">Consulta de pesquisa</string>
    <string name="abc_searchview_description_search">Pesquisar</string>
    <string name="abc_searchview_description_submit">Enviar consulta</string>
    <string name="abc_searchview_description_voice">Pesquisa por voz</string>
    <string name="abc_shareactionprovider_share_with">Compartilhar com</string>
    <string name="abc_shareactionprovider_share_with_application">Compartilhar com %s</string>
    <string name="abc_toolbar_collapse_description">Recolher</string>
    <string name="app_name">Algoritmos</string>
    <string name="en">Inglês</string>
    <string name="es">Espanhol</string>
    <string name="goal">META</string>
    <string name="ja">Japonês</string>
    <string name="ko">Coreano</string>
    <string name="min">min</string>
    <string name="pt">Português brasileiro</string>
    <string name="ru">Russo</string>
    <string name="search">busca</string>
    <string name="search_menu_title">Pesquisar</string>
    <string name="status_bar_notification_info_overflow">999+</string>
    <string name="zh">Chinês (simplificado)</string>
</resources>
