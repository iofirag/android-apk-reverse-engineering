<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="AStarSearch">El Algoritmo A*</string>
    <string name="AStarSearch0">El algoritmo \"A*\" (pronunciado A estar) fue un avance sobre el algoritmo de Dijkstra. Comencemos encontrando la ruta más corta en este laberinto usando el algoritmo de Dijkstra.</string>
    <string name="AStarSearch1">En este laberinto podemos inferir que el costo entre los nodos es de 1.</string>
    <string name="AStarSearch10">Puede ser más sencillo de entender si pensamos en la estimación como números que representan la altitud de cada punto.</string>
    <string name="AStarSearch100">Al definir una estimación de costo apropiada, basándose en lo que se conoce a priori, e implementándola como una estimación para el algoritmo, la búsqueda se puede volver más y más eficiente.</string>
    <string name="AStarSearch101">Tomando el costo actual desde el punto inicial hasta la ubicación actual + el costo estimado desde la ubicación actual hasta la meta nos da el costo total (estimado) desde el punto inicial hasta la meta.</string>
    <string name="AStarSearch11">La meta en la parte derecha inferior sería el punto más bajo, y el punto en la esquina superior izquierda con un costo de 8, sería el punto más alto. Caminar cuesta abajo siempre resulta más sencillo que cuesta arriba.</string>
    <string name="AStarSearch12">Al explorar este laberinto, si hacemos que sea más fácil o menos costos moverse en dirección al costo más bajo (moverse cuesta abajo), deberíamos estar alcanzando la meta más rápidamente.</string>
    <string name="AStarSearch13">Ahora intentemos solucionar el laberinto con A*</string>
    <string name="AStarSearch14">Primero, consideramos que la ubicación inicial ya ha sido explorada.</string>
    <string name="AStarSearch15">Luego calculamos el costo de cada punto al que podemos movernos desde la ubicación de inicio.</string>
    <string name="AStarSearch16">El costo es calculado como el total del costo de moverse hasta el punto evaluado, mas el costo estimado hasta la meta.</string>
    <string name="AStarSearch17">Elegimos el que tenga el menor costo total estimado.</string>
    <string name="AStarSearch18">El punto elegido es considerado ya explorado por completo.</string>
    <string name="AStarSearch19">Luego calculamos el costo desde cada punto al que podemos movernos desde el punto actual.</string>
    <string name="AStarSearch2">Bajo esta premisa, usaremos el algoritmo de Dijkstra para encontrar la ruta más corta.</string>
    <string name="AStarSearch20">Y una vez más elegimos el que tiene el menor costo total estimado.</string>
    <string name="AStarSearch21">El punto elegido es considerado ya explorado por completo.</string>
    <string name="AStarSearch22">En adelante, se repite la misma operación hasta que la meta es alcanzada.</string>
    <string name="AStarSearch24">Comparándolo con el algoritmo de Dijkstra, pudimos explorar este laberinto más eficientemente.</string>
    <string name="AStarSearch25">¿Qué se puede hacer para resolver el laberinto aún más eficientemente?</string>
    <string name="AStarSearch26">Intentemos el costo real de la ruta más corta en lugar de la distancia lineal como medida de estimación.</string>
    <string name="AStarSearch28">Esta vez, alcanzamos la meta tomando la ruta más corta sin tomar ningún camino innecesario en absoluto.</string>
    <string name="AStarSearch29">Pero siendo realistas, si ya conocemos el costo de la ruta más corta es porque de hecho conocemos la ruta más corta, así que no necesitaríamos buscarla, pues ya la conocemos...</string>
    <string name="AStarSearch30">Entonces, se vuelve evidente que el uso de la heurística de costo es crucial como factor de ajuste del algoritmo A*</string>
    <string name="AStarSearch31">Mientras mejor aproximada sea esta medida de costo estimado de la ruta más corta, más eficiente será la búsqueda de la solución al laberinto.</string>
    <string name="AStarSearch32">Por otro lado, miremos qué sucede cuando esta estimación falla.</string>
    <string name="AStarSearch33">Aquí, a manera de un ejemplo extremo, hemos dejado la heurística de costo sobre la ruta más corta, y hemos restaurado todos los demás valores a 0.</string>
    <string name="AStarSearch35">La eficiencia de la búsqueda fue peor que la del algortimo de Dijkstra. Sin embargo, la ruta más corta fue encontrada correctamente.</string>
    <string name="AStarSearch36">Con el algoritmo A*, mientras la heurística de costo estimado sea menor o igual que el costo del punto inicial, está garantizado que se hallará la solución, sin importar qué tan eficiente sea la búsqueda.</string>
    <string name="AStarSearch37">Como un mal ejemplo, intentemos que la heurística de costo estimado sea mayor que el costo más bajo desde el punto inicial.</string>
    <string name="AStarSearch38">Aquí tenemos sólo la heurística de costo estimado de la ruta más corta y la hemos definido con el doble de su valor original, excediendo por mucho el costo más bajo desde el punto inicial hasta la meta.</string>
    <string name="AStarSearch4">La ruta más corta fue encontrada, pero implicó atravesar prácticamente todos los caminos.</string>
    <string name="AStarSearch40">El algoritmo ha decidido que ha terminado la búsqueda, pero la ruta encontrada fue totalmente diferente a la ruta más corta.</string>
    <string name="AStarSearch41">Así, se puede ver que el algoritmo A* es bueno o malo según cómo se determinan sus parámetros.</string>
    <string name="AStarSearch42">Este algoritmo es comúnmente usado en la programación de juegos, en instancias como las de un enemigo artificialmente inteligente que sigue al jugador real en el juego.</string>
    <string name="AStarSearch43">Sin embargo, el gran número de cálculos requeridos frecuentemente tiene un efecto negativo en la velocidad del juego. Es necesario pensar bien cómo usarlo, por ejemplo combinándolo con otros algoritmos o restringiendo su uso.</string>
    <string name="AStarSearch44">Esto concluye la explicación del Algoritmo A*.</string>
    <string name="AStarSearch5">El algoritmo de Dijkstra sólo toma en cuenta el costo desde el punto inicial antes de decidir moverse al siguiente nodo.</string>
    <string name="AStarSearch6">A causa de eso, revisa caminos como los marcados con las flechas, sin darse cuenta de que van más allá de la meta.</string>
    <string name="AStarSearch7">A* considera no sólo el costo desde el punto inicial, sino también la estimación de costo desde el punto actual hasta la meta.</string>
    <string name="AStarSearch8">La estimación del costo puede ser establecida libremente. En este caso, los valores usados fueron determinados al aproximar la distancia lineal hasta la meta ubicada abajo a la derecha.</string>
    <string name="AStarSearch9">Esta estimación de costo es ingresada manualmente, y es conocida como la \"Heurística de Costo\".</string>
    <string name="AStarSearchDescription">El algoritmo \"A*\" es la versión avanzada del \"Algoritmo de Dijkstra\". Podrá estudiar este tema al comprar todos los algoritmos.</string>
    <string name="AboutDev">Acerca de esta app</string>
    <string name="AlgorithmText1">Encriptación RSA</string>
    <string name="AlgorithmText2">Criptografía de Curva Elíptica</string>
    <string name="AlreadyBought">Adquirido</string>
    <string name="AlreadyBoughtRestore">Si usted ha reinstalado la app o la ha instalado en otro dispositivo iOS, por favor use la opción \"Restaurar Registro de Compra\"</string>
    <string name="AlreadyBoughtRestoreAndroid">Si usted ha reinstalado la app o la ha instalado en otro dispositivo, por favor use la opción \"Restaurar Registro de Compra\"</string>
    <string name="AppTitle">Algoritmos: Explicados y Animados</string>
    <string name="Array">Formaciones</string>
    <string name="Array0">Las \"Formaciones\", o \"Arrays\" en Inglés, son un tipo de estructura de datos que puede almacenar múltiples valores.</string>
    <string name="Array1">Cada elemento es accesible a través de su índice (un número que denota el orden de cada elemento dentro de la formación).</string>
    <string name="Array10">Primero aseguramos espacio adicional al final de la Formación.</string>
    <string name="Array11">Para lograr asegurar este espacio al final necesario para agregar el nuevo dato, todos los elementos son movidos uno a uno.</string>
    <string name="Array13">Ahora \"Verde\" es agregado en el espacio vacío, completando el proceso de adición.</string>
    <string name="Array14">De manera contraria, al borrar el segundo elemento de datos,</string>
    <string name="Array15">Primero borramos ese elemento de datos,</string>
    <string name="Array16">y luego llenamos el espacio vacío moviendo uno a uno los demás elementos de esta Formación.</string>
    <string name="Array18">Al final, el espacio vacío restante es borrado, completando el proceso de borrado.</string>
    <string name="Array19">Esto concluye la explicación de las Formaciones.</string>
    <string name="Array2">La información es almacenada secuencialmente en la memoria en ubicaciones consecutivas.</string>
    <string name="Array3">Ya que los datos son almacenados en ubicaciones consecutivas, las ubicaciones en la memoria pueden ser calculadas usando los índices de cada elemento, permitiendo el acceso aleatorio a los datos,</string>
    <string name="Array8">Otra característica de las Formaciones es que agregar o borrar datos en una ubicación específica implica altos costos, comparado con las Listas.</string>
    <string name="Array9">Imaginemos que agregamos \"Verde\" en la segunda ubicación.</string>
    <string name="BellmanFord">Algoritmo de Bellman-Ford</string>
    <string name="BellmanFord0">El \"Algoritmo Bellman-Ford\" es un algoritmo que encuentra la ruta más corta en un grafo.</string>
    <string name="BellmanFord1">Un valor de costo inicial es asignado a cada punto. El punto del inicio es definido como costo cero (0) y todos los demás puntos son definidos con costo infinito.</string>
    <string name="BellmanFord10">Continuando, calculamos el costo de la dirección opuesta, o sea, de B a A.</string>
    <string name="BellmanFord11">El Costo del punto B es 9, así que el costo desde B hacia A es 9 + 9 = 18.</string>
    <string name="BellmanFord12">Cuando se compara esto con el valor del punto A, el valor actual resulta siendo menor (9&lt;18), por lo que el costo no es actualizado</string>
    <string name="BellmanFord13">Cuando nos movemos de un punto con costo mayor hacia uno con costo menor, ese eje no es actualizado mientras el costo sea positivo.</string>
    <string name="BellmanFord14">Las mismas operaciones serán llevadas a cabo en todos los ejes. El orden de los ejes es irrelevante, pero esta vez, por conveniencia, haremos los cálculos comenzando con los ejes a la izquierda.</string>
    <string name="BellmanFord15">Seleccionamos un eje...</string>
    <string name="BellmanFord150">Por ejemplo, la ruta más corta desde A hasta C (1 movimiento) y hasta D (2 movimientos) han sido encontradas.</string>
    <string name="BellmanFord16">y actualizamos el costo.</string>
    <string name="BellmanFord17">De igual manera, seleccionamos otro eje</string>
    <string name="BellmanFord18">y actualizamos el costo.</string>
    <string name="BellmanFord19">Ahora vemos que para ir del punto A al B, es mejor pasar a través del punto C para ir a B que ir a B directamente.</string>
    <string name="BellmanFord2">Uno de los ejes es seleccionado. Hemos seleccionado A-B por conveniencia en esta ocasión.</string>
    <string name="BellmanFord20">Los costos son actualizados en todos los ejes.</string>
    <string name="BellmanFord21">Una ronda de actualizaciones es llevada a cabo.</string>
    <string name="BellmanFord22">La operación de actualizaciones es realizada hasta que ninguna otra actualización sucede.</string>
    <string name="BellmanFord24">No suceden más actualizaciones, así que detenemos la operación.</string>
    <string name="BellmanFord25">En este punto, la búsqueda del algoritmo termina, y la ruta más corta desde el punto inicial a cada otro punto es encontrada.</string>
    <string name="BellmanFord26">Revisemos por qué la ruta más corta es encontrada con este tipo de operaciones.</string>
    <string name="BellmanFord27">La escena ha sido restablecida a su estado inicial.</string>
    <string name="BellmanFord28">Esta vez, haremos las actualizaciones en el orden contrario, es decir que comenzaremos con los ejes a la derecha, de tal manera que los ejes que salen de A serán actualizados al final.</string>
    <string name="BellmanFord3">El costo de atravesar cada eje de extremo a extremo en el eje seleccionado es calculado. El cálculo se hace tomando el costo del punto inicial + el costo del movimiento,</string>
    <string name="BellmanFord30">Una ronda de actualizaciones es llevada a cabo.</string>
    <string name="BellmanFord31">Como se puede ver luego de una ronda de actualizaciones, sólo los costos de los puntos accesibles desde el punto A en un solo movimiento, han sido actualizados.</string>
    <string name="BellmanFord32">Intentaremos una segunda ronda de actualizaciones.</string>
    <string name="BellmanFord34">La segunda ronda de actualización ha finalizado.</string>
    <string name="BellmanFord35">Se puede observar que luego de 2 rondas de actualización, sólo se ha actualizado los costos de los puntos que son accesibles desde el punto A en dos movimientos.</string>
    <string name="BellmanFord36">De hecho, luego de realizar las actualizaciones n-veces, está garantizado que la ruta más corta será encontrada para todos los puntos que son accesibles desde A en n-movimientos o menos.</string>
    <string name="BellmanFord37">El diagrama ha tenido dos rondas de operación, así que como mínimo las rutas más cortas desde A hasta todos los puntos accesibles desde A dos movimientos o menos, han sido encontradas.</string>
    <string name="BellmanFord38">Sólo las rutas para puntos que están lejos 2 movimientos o menos han sido encontradas hasta ahora. Así que, aunque la ruta hasta el punto F a través de A- [C-D-F] tiene un costo menor, no ha sido considerada aún pues se necesitan 3 rondas para descubrirla formalmente.</string>
    <string name="BellmanFord39">También, aunque la ruta más corta hasta el punto B toma 3 movimientos, ha sido descubierta dado el orden en que los ejes fueron actualizados.</string>
    <string name="BellmanFord4">El cálculo se realiza en una dirección cada vez. A pesar de que cada dirección es correcta, por conveniencia, en esta explicación calcularemos primero la dirección del punto con el menor costo hacia el punto con mayo costo.</string>
    <string name="BellmanFord40">En otras palabras, descubrir las rutas más cortas en ocasiones es posible en menos rondas de actualización dependiendo del orden en que se revisen los ejes.</string>
    <string name="BellmanFord41">Entonces, dado que las rutas más cortas hasta puntos que están a n-movimientos son encontradas al ejecutar n-rondas, ¿cuántas rondas de actualizaciones deberemos ejecutar?</string>
    <string name="BellmanFord42">Dados n-puntos, y teniendo en cuenta que nunca regresaremos al punto inicial, se puede asumir que podremos llegar cualquier punto en n-1 movimientos.</string>
    <string name="BellmanFord43">en otras palabras, si llevamos a cabo n-1 rondas de actualización como máximo, la ruta más corta desde el inicio hasta todos los puntos será encontrada.</string>
    <string name="BellmanFord44">También, si en el curso de las n-1 rondas de actualización no se ejecutan más actualizaciones, se puede determinar que la ruta más corta ya ha sido encontrada.</string>
    <string name="BellmanFord45">Ahora continuemos con las operaciones de actualización en el diagrama hasta que las rutas más cortas a todos los puntos hayan sido encontradas.</string>
    <string name="BellmanFord47">No hay más actualizaciones, así que la operación se detiene.</string>
    <string name="BellmanFord48">Hemos logrado derivar la ruta más corta a todos los puntos, igual que antes.</string>
    <string name="BellmanFord49">Además, incluso si los costos direccionales entre A y B son diferentes (el costo de ir es diferente al de volver entre A y B) como se ve en el diagrama, y aún si existen ejes que permiten sólo una dirección...</string>
    <string name="BellmanFord5">El costo actual del punto A es menor, así que calcularemos la travesía del punto A al punto B.</string>
    <string name="BellmanFord50">el algoritmo Bellman-Ford es capaz de encontrar correctamente la ruta más corta.</string>
    <string name="BellmanFord51">Los grafos en que la dirección de flujo entre los ejes son fijas son llamados \"Grafos Dirigidos\", y los que no tienen dirección fija son llamados \"Grafos no Dirigidos\".</string>
    <string name="BellmanFord52">¿Qué sucede cuando también hay \"costos negativos\"?</string>
    <string name="BellmanFord53">Un \"Costo Negativo\" hace referencia a un caso como el -3 del eje C-B en el diagrama.</string>
    <string name="BellmanFord54">Es difícil imaginar lo que significa un costo negativo...</string>
    <string name="BellmanFord55">Por ejemplo, imaginemos un automóvil moviéndose desde el punto A hasta el punto G. El costo podría expresarse en términos de consumo de combustible.</string>
    <string name="BellmanFord56">En ese caso, si pensamos en una estación de gasolina donde el costo de combustible es negativo ubicada en uno de los caminos, es más fácil de imaginar.</string>
    <string name="BellmanFord57">Con el algoritmo Bellman-Ford es posible encontrar las rutas más cortas correctamente incluso en situaciones que incluyen costos negativos.</string>
    <string name="BellmanFord58">Entonces, ¿qué pasa si el valor negativo del costo de C-B cambiara de -3 a -6?</string>
    <string name="BellmanFord59">Pareciera que la ruta más corta podría encontrarse sin problema,</string>
    <string name="BellmanFord6">El costo del punto A es 0, así que el costo de atravesar de A a B es 0 + 9 = 9.</string>
    <string name="BellmanFord60">pero el costo total de la travesía entre A-C-B es -1.</string>
    <string name="BellmanFord61">Rutas como estas son llamadas \"Ciclos Negativos\".</string>
    <string name="BellmanFord62">Cuando existe un ciclo negativo, se puede hacer el costo cada vez más bajo por medio de continuar girando en círculos en la misma ruta.</string>
    <string name="BellmanFord63">En casos como este no hay manera de encontrar la ruta más corta.</string>
    <string name="BellmanFord64">Cuando aplicamos el algoritmo Bellman-Ford en situaciones como esta, las actualizaciones continúan presentándose siempre, y el proceso nunca se detiene sin importar cuántas rondas de actualización ejecutemos.</string>
    <string name="BellmanFord65">De hecho, con el algoritmo Bellman-Ford, las actualizaciones deberían completarse después de n-1 operaciones cuando hay n puntos, así que...</string>
    <string name="BellmanFord66">Si las actualizaciones de costos continúan sucediendo después de n rondas de actualización, esto significa que hay un ciclo negativo en alguna parte en el sistema.</string>
    <string name="BellmanFord67">Como pudimos observar, el algoritmo Bellman-Ford es un algoritmo con un gran número de cálculos, pero es capaz de encontrar la ruta más corta incluso en sistemas con costos negativos...</string>
    <string name="BellmanFord68">y también es capaz de detectar la presencia de ciclos negativos.</string>
    <string name="BellmanFord69">Esto concluye la explicación del Algoritmo de Bellman-Ford.</string>
    <string name="BellmanFord7">Si el resultado calculado es menor que el valor actual, el costo es actualizado al nuevo valor.</string>
    <string name="BellmanFord8">El punto B tiene un costo actual infinito, así que es actualizado a 9.</string>
    <string name="BellmanFord9">Cuando un valor es evaluado, registramos la ruta y el punto del que se proviene. En el diagrama esta ruta está mostrada en color naranja.</string>
    <string name="BinarySearch">Búsqueda Binaria</string>
    <string name="BinarySearch0">La \"Búsqueda Binaria\" es un algoritmo para buscar elementos a través de una estructura ordenada de datos.</string>
    <string name="BinarySearch1">Busquemos el número 6.</string>
    <string name="BinarySearch10">De nuevo evaluamos el número ubicado en el centro del conjunto restante. Esta vez ese número es 6.</string>
    <string name="BinarySearch11">6 = 6, así que hemos encontrado el número que buscábamos.</string>
    <string name="BinarySearch12">De esta forma, la búsqueda binaria usa estructuras pre-ordenadas de datos y divide constantemente el espacio de búsqueda para buscar de manera más eficiente.</string>
    <string name="BinarySearch13">Esto concluye la explicación de la Búsqueda Binaria.</string>
    <string name="BinarySearch2">Primero, evaluamos el número ubicado en el centro del conjunto de datos. En este caso es 5.</string>
    <string name="BinarySearch3">Comparamos el número en el centro, para ver si es el que buscamos. 5 es menor que 6, así que sabemos que 6 estará necesariamente a la derecha de 5.</string>
    <string name="BinarySearch4">De todos los candidatos, removemos los números que ya no es necesario evaluar.</string>
    <string name="BinarySearch6">De nuevo evaluamos el número ubicado en el centro del conjunto restante. Esta vez ese número es 7.</string>
    <string name="BinarySearch7">comparamos 7 y 6, y encontramos que 6 es menor que 7, por lo que el número buscado necesariamente estará en alguna parte a la izquierda de 7.</string>
    <string name="BinarySearch8">De todos los candidatos, removemos los números que ya no es necesario evaluar.</string>
    <string name="BinaryTree">Árboles Binarios de Búsqueda</string>
    <string name="BinaryTree0">Los \"Árboles Binarios de Búsqueda\" son un tipo de estructura de datos.</string>
    <string name="BinaryTree1">Los puntos numerados son llamados \"Nodos\".</string>
    <string name="BinaryTree10">Por el contrario, el mayor nodo de un árbol binario de búsqueda está ubicado en el extremo del sub-árbol derecho, ramificándose desde el nodo ubicado en la parte superior.</string>
    <string name="BinaryTree11">Ahora revisemos el proceso de agregar nodos a un árbol binario de búsqueda.</string>
    <string name="BinaryTree12">Por ejemplo, comenzaremos agregando el número 1.</string>
    <string name="BinaryTree13">Comenzamos por el nodo en el extremo superior del árbol binario de búsqueda para encontrar la ubicación correcta del nodo adicional.</string>
    <string name="BinaryTree14">1 es menor que 15, así que se procede a la izquierda.</string>
    <string name="BinaryTree16">1 es menor que 9, así que se procede a la izquierda.</string>
    <string name="BinaryTree18">1 es menor que 3, así que se procede a la izquierda una vez más, pero como no hay un nodo a cuál moverse para continuar, el nodo es agregado en esa posición.</string>
    <string name="BinaryTree2">Los árboles binarios de búsqueda tienen dos propiedades.</string>
    <string name="BinaryTree20">La inclusión del 1 está completa.</string>
    <string name="BinaryTree21">Ahora intentemos agregar el 4.</string>
    <string name="BinaryTree22">Igual que antes, comenzamos por el nodo ubicado en el extremo superior del árbol binario de búsqueda para encontrar su ubicación adecuada.</string>
    <string name="BinaryTree23">4 es menor que 15, así que se procede a la izquierda.</string>
    <string name="BinaryTree25">4 es menor que 9, así que se procede a la izquierda.</string>
    <string name="BinaryTree27">4 es mayor que 3, así que se procede a la derecha.</string>
    <string name="BinaryTree29">4 es menor que 8, así que se procede a la izquierda, pero como no existe otro nodo hacia dónde continuar, el 4 es agregado como nuevo nodo.</string>
    <string name="BinaryTree3">La primera propiedad es que los nodos son mayores en el sub-árbol izquierdo.</string>
    <string name="BinaryTree31">La inclusión del 4 está completa.</string>
    <string name="BinaryTree32">Ahora revisemos el proceso de borrar nodos de un árbol binario de búsqueda.</string>
    <string name="BinaryTree33">Por ejemplo, intentemos borrar el 28.</string>
    <string name="BinaryTree34">Cuando un nodo no tiene hijos,</string>
    <string name="BinaryTree35">el nodo objetivo es simplemente borrado y el proceso se considera completo.</string>
    <string name="BinaryTree36">Ahora intentemos borrar el 8.</string>
    <string name="BinaryTree37">Cuando el nodo a ser borrado sólo tiene un hijo,</string>
    <string name="BinaryTree38">el nodo objetivo es borrado,</string>
    <string name="BinaryTree39">y al mover el hijo a la posición del nodo borrado, el proceso se completa.</string>
    <string name="BinaryTree4">Por ejemplo, el nodo 9 es mayor que los otros números en su sub-árbol izquierdo.</string>
    <string name="BinaryTree40">Por último, intentemos borrar el 9.</string>
    <string name="BinaryTree41">Al borrar un nodo que tiene dos hijos,</string>
    <string name="BinaryTree42">primero se borra el nodo objetivo...</string>
    <string name="BinaryTree43">y del sub-árbol del nodo borrado, encontramos el nodo más grande,</string>
    <string name="BinaryTree44">y lo movemos a la posición del nodo que ha sido borrado.</string>
    <string name="BinaryTree45">Al hacer esto, fuimos capaces de borrar un nodo mientras preservamos la integridad del árbol binario de búsqueda.</string>
    <string name="BinaryTree46">Más aún, si el nodo que ha sido movido también tiene hijos, el mismo proceso se repite recursivamente.</string>
    <string name="BinaryTree47">Además, a pesar de que en este caso usamos el nodo más grande del sub-árbol izquierdo, también pudimos haber usado el nodo más pequeño del sub-árbol derecho y funcionaría igual de bien.</string>
    <string name="BinaryTree48">Ahora, revisemos el proceso de buscar por un nodo dentro del árbol binario de búsqueda.</string>
    <string name="BinaryTree49">Por ejemplo, intentemos buscar el 12.</string>
    <string name="BinaryTree5">De igual manera, el nodo 15 es mayor que los demás números en su sub-árbol izquierdo.</string>
    <string name="BinaryTree50">Comenzamos por el nodo ubicado en el extremo superior del árbol.</string>
    <string name="BinaryTree51">12 es menor que 15, así que procedemos a la izquierda.</string>
    <string name="BinaryTree53">12 es mayor que 4, así que procedemos a la derecha.</string>
    <string name="BinaryTree55">Encontramos el 12.</string>
    <string name="BinaryTree56">Como puede verse, fuimos capaces de buscar eficientemente usando el árbol binario de búsqueda.</string>
    <string name="BinaryTree57">Sin embargo, si el árbol se acerca a una forma de línea recta, su eficiencia se torna extremadamente pobre, como una búsqueda lineal.</string>
    <string name="BinaryTree58">Por otro lado, los árboles binarios de búsqueda que siempre están balanceados, llamados \"árboles binarios de búsqueda auto-balanceados\" son capaces de mantener la eficiencia de búsqueda.</string>
    <string name="BinaryTree59">Esto concluye la explicación de los árboles binarios de búsqueda.</string>
    <string name="BinaryTree6">Por el contrario, su segunda propiedad es que todos los nodos son más pequeños que aquellos ubicados en su sub-árbol derecho.</string>
    <string name="BinaryTree7">Por ejemplo, el nodo 15 es menor que los otros números en su sub-árbol derecho.</string>
    <string name="BinaryTree8">Debido a estas propiedades, los siguiente se mantiene como cierto:</string>
    <string name="BinaryTree9">Primero, el menor nodo de un árbol binario de búsqueda está ubicado en el extremo del sub-árbol izquierdo, ramificándose desde el nodo ubicado en la parte superior.</string>
    <string name="BinaryTreeDescription">Los \"Árboles binarios de búsqueda\" son los más básicos de los árboles de búsqueda. Podrá estudiar este tema al comprar todos los algoritmos.</string>
    <string name="BreadthFirstSearch">Búsqueda de Primero en Amplitud</string>
    <string name="BreadthFirstSearch0">La \"Búsqueda de Primero en Amplitud\" es un algoritmo que busca a través de grafos.</string>
    <string name="BreadthFirstSearch1">Comenzaremos la búsqueda con A como punto inicial, y nuestra meta es G.</string>
    <string name="BreadthFirstSearch11">De los candidatos, C y D fueron agregados en primer lugar. De entre todos los candidatos, se elige en primera instancia de ellos dos (C y D), y ahora elegiremos C del lado izquierdo.</string>
    <string name="BreadthFirstSearch12">Nos movemos al punto seleccionado.</string>
    <string name="BreadthFirstSearch13">H, accesible desde el punto actual ( C ) es agregado como nuevo candidato.</string>
    <string name="BreadthFirstSearch14">En adelante, la misma operación será repetida hasta que todos los puntos han sido evaluados.</string>
    <string name="BreadthFirstSearch2">Los puntos B, C y D, que son accesibles desde A, son considerados como candidatos para nuestro siguiente movimiento.</string>
    <string name="BreadthFirstSearch3">Un punto es seleccionado de entre los candidatos. La base para la selección del punto es cuál de ellos fue agregado como candidato en primer lugar.</string>
    <string name="BreadthFirstSearch38">La meta ha sido alcanzada, y la búsqueda termina.</string>
    <string name="BreadthFirstSearch39">Como se puede observar, la búsqueda de primero amplitud es única en la forma en que busca ampliamente desde los puntos más cercanos al punto inicial.</string>
    <string name="BreadthFirstSearch4">Para puntos agregados como candidatos al mismo tiempo, no importa cuál es seleccionado. Esta vez, por conveniencia, seleccionaremos puntos del lado izquierdo.</string>
    <string name="BreadthFirstSearch40">Esto concluye la explicación de la Búsqueda de Primero en Amplitud.</string>
    <string name="BreadthFirstSearch5">Ya que todos ellos se convirtieron en candidatos al mismo tiempo, seleccionaremos B.</string>
    <string name="BreadthFirstSearch6">Nos movemos al punto seleccionado.</string>
    <string name="BreadthFirstSearch7">E y F son accesibles desde el punto actual (B) y son agregados como nuevos candidatos.</string>
    <string name="BreadthFirstSearch8">Los candidatos son gestionados bajo la regla \"First In First Out\" (FIFO) que en español es \"Primero en Entrar Primero en Salir\" (PEPS). Esto hace que sea posible construir una estructura de datos en \"cola\".</string>
    <string name="BreadthFirstSearch9">Las \"Colas\" son explicadas en detalle en otra sección de esta app.</string>
    <string name="BubbleSort">Ordenado Burbuja</string>
    <string name="BubbleSort0">El \"Ordenado Burbuja\" es un algoritmo usado para ordenar secuencias de números.</string>
    <string name="BubbleSort1">Las escalas al extremo derecho de la secuencia compararán los números en sus dos lados.</string>
    <string name="BubbleSort16">La escala ha alcanzado el extremo de la secuencia.</string>
    <string name="BubbleSort2">En este caso compararán 7 y 6.</string>
    <string name="BubbleSort20">En una ronda de operaciones, el valor más bajo ha sido movido hasta el extremo izquierdo de la secuencia.</string>
    <string name="BubbleSort21">Este número a la izquierda es considerado ya ordenado...</string>
    <string name="BubbleSort22">ahora la escala se mueve de nuevo al extremo derecho.</string>
    <string name="BubbleSort23">La misma operación es repetida hasta que todos los números han sido ordenados completamente.</string>
    <string name="BubbleSort25">El orden de la secuencia está completo.</string>
    <string name="BubbleSort26">Esto concluye la explicación del Ordenado Burbuja o Bubble Sort.</string>
    <string name="BubbleSort3">Luego de compararlos, si el número a la derecha resulta ser menor, los números serán intercambiados.</string>
    <string name="BubbleSort4">6 es menor que 7, así que los números son intercambiados.</string>
    <string name="BubbleSort5">Al terminar la comparación, la escala se mueve una posición a la izquierda.</string>
    <string name="BubbleSort6">Los números son comparados de nuevo.</string>
    <string name="BubbleSort7">Esta vez, 6 es mayor que 4, así que los números no se intercambian.</string>
    <string name="BubbleSort8">La escala se mueve una posición a la izquierda.</string>
    <string name="BubbleSort9">Esta operación es repetida hasta que la escala alcanza el extremo izquierdo de la secuencia.</string>
    <string name="BuyAllAlgorithms">Comprar todos los algoritmos: %@</string>
    <string name="BuyAllAlgorithmsAndroid">Comprar todos los algoritmos</string>
    <string name="CKC">Criptosistema de Clave compartida</string>
    <string name="CKC0">El \"Criptosistema de Clave Compartida\" es un sistema de encriptación que usa la misma clave (o llave) para la encriptación y la decriptación de los datos.</string>
    <string name="CKC1">Revisemos el panorama general de cómo los datos son intercambiados usando el sistema de clave compartida.</string>
    <string name="CKC10">El agente B desencripta el texto cifrado recibido de A,</string>
    <string name="CKC11">y ahora puede obtener el mensaje original.</string>
    <string name="CKC12">Si la información está encriptada, no hay nada de qué preocuparse aún si es interceptada por un tercero.</string>
    <string name="CKC13">Usar la misma llave para encriptación y decriptación es una característica del criptosistema de llave compartida.</string>
    <string name="CKC14">En el diagrama se muestran algunos métodos de cálculo usados en los sistemas de llave compartida.</string>
    <string name="CKC15">Hoy en día, el método conocido como \"AES\" es ampliamente usado.</string>
    <string name="CKC16">Ahora, pensemos en varios asuntos relacionados a los sistemas criptográficos de llave compartida</string>
    <string name="CKC17">Retornaremos brevemente a la situación anterior. Ahora, el agente B ha recibido un mensaje cifrado enviado por A.</string>
    <string name="CKC18">Es posible que el mensaje haya sido interceptado por X.</string>
    <string name="CKC19">Y, como A y B no están en contacto directo ni comunicación personal,</string>
    <string name="CKC2">Digamos que el agente A intenta enviar un mensaje al agente B por Internet</string>
    <string name="CKC20">pensemos en qué pasaría si B no tiene la llave usada para la encriptación.</string>
    <string name="CKC21">El Agente A necesita entregarle la llave de encriptación a B de alguna manera.</string>
    <string name="CKC22">Tal como se hizo con el texto cifrado, A envía la llave a B por medio de internet.</string>
    <string name="CKC23">B, usando la llave proporcionada por A</string>
    <string name="CKC24">es capaz de descifrar el texto.</string>
    <string name="CKC25">Sin embargo, es posible que el agente X intercepte la llave también.</string>
    <string name="CKC26">Si ese es el caso, es posible que X también sea capaz de descifrar el texto.</string>
    <string name="CKC27">Claramente puede verse que el problema es la manera en que la llave es transmitida.</string>
    <string name="CKC28">Así que A piensa en encriptar la llave misma, para que si X la intercepta no haya ningún problema.</string>
    <string name="CKC29">Para un computador, una llave no es más que un conjunto de datos.</string>
    <string name="CKC3">Los datos son entregados a B luego de pasar por varias redes y dispositivos en internet.</string>
    <string name="CKC30">Por eso...</string>
    <string name="CKC31">se puede encriptar con una nueva llave.</string>
    <string name="CKC32">El texto cifrado contendría la llave inicial</string>
    <string name="CKC33">Y se envía a B.</string>
    <string name="CKC34">Ahora B tiene ambas cosas: el texto cifrado y la llave para descifrarlo.</string>
    <string name="CKC35">Aún así, existe la posibilidad de que X intercepte la llave encriptada.</string>
    <string name="CKC36">Sólo resta enviar la segunda llave a B para que pueda descifrar la primera...</string>
    <string name="CKC37">Pero ¿cómo enviársela?</string>
    <string name="CKC38">Sin encriptarla, X podría interceptarla también, descifrando todo.</string>
    <string name="CKC39">Si la encripta, sería necesaria una nueva llave y el problema se repite nuevamente.</string>
    <string name="CKC4">De esa manera, si se intenta enviar la información tal y como es...</string>
    <string name="CKC40">En resumen, un sistema criptográfico de llave compartida requiere un método seguro de encriptación de llaves.</string>
    <string name="CKC41">Este es llamado el \"Problema de Entrega de Llaves\".</string>
    <string name="CKC42">Existen dos tipos de soluciones a este problema. 1) métodos que usan llaves de intercambio de protocolos y 2) métodos que usan sistemas de llave pública. Ambos serán explicados en detalle en otras secciones de esta app.</string>
    <string name="CKC43">Esto concluye la explicación del Criptosistema de Clave compartida.</string>
    <string name="CKC5">Es posible que un tercero con malas intenciones intercepte la información</string>
    <string name="CKC6">Por esta razón es necesario encriptar la información antes de enviarla, para que permanezca privada.</string>
    <string name="CKC7">Usando una llave o clave...</string>
    <string name="CKC8">La información es encriptada en lo que se llama \"texto cifrado\".</string>
    <string name="CKC9">El texto cifrado es enviado a B.</string>
    <string name="Cancel">Cancelar</string>
    <string name="CannotPayAlert">Las compras están restringidas. Por favor cambie la configuración en su dispositivo.</string>
    <string name="CannotRestoreAlert">El registro de compra no puede ser comprobado. Por favor, asegúrese de estar usando la misma cuenta de iTunes con la que se realizó la compra.</string>
    <string name="CannotRestoreAlertAndroid">El registro de compra no puede ser comprobado. Por favor, asegúrese de estar usando la misma cuenta de Google Play con la que se realizó la compra.</string>
    <string name="ChangeConfirmation">¿Está seguro de querer realizar estos cambios?</string>
    <string name="ClusteringSection">Agrupar</string>
    <string name="CompressionSection">Compresión de datos</string>
    <string name="Config">Configuración</string>
    <string name="DataStructureSection">Estructuras de datos</string>
    <string name="DepthFirstSearch">Búsqueda de Primero en Profundidad</string>
    <string name="DepthFirstSearch0">La \"Búsqueda de Primero en Profundidad\" es un algoritmo que busca a través de grafos.</string>
    <string name="DepthFirstSearch1">Comenzaremos la búsqueda con A como punto inicial, y nuestra meta es G.</string>
    <string name="DepthFirstSearch11">De entre los candidatos, C y D fueron agregados más recientemente. Entre ellos dos, elegimos E por estar al lado izquierdo.</string>
    <string name="DepthFirstSearch12">Nos movemos al punto seleccionado.</string>
    <string name="DepthFirstSearch13">K, accesible desde el punto actual ( E ) es agregado como nuevo candidato.</string>
    <string name="DepthFirstSearch14">en adelante, la misma operación es repetida hasta que la meta es alcanzada y todos los puntos han sido evaluados por completo.</string>
    <string name="DepthFirstSearch2">Los puntos B, C y D, que son accesibles desde A, son considerados como candidatos para nuestro siguiente movimiento.</string>
    <string name="DepthFirstSearch28">La meta ha sido alcanzada, y la búsqueda termina.</string>
    <string name="DepthFirstSearch29">Como se puede observar la búsqueda de primero en profundidad es única en la manera en que busca al ir cada vez más profundo en un grafo.</string>
    <string name="DepthFirstSearch3">Un punto es seleccionado de entre los candidatos. La base para la selección del punto es cuál de ellos fue agregado como candidato en primer lugar.</string>
    <string name="DepthFirstSearch30">Esto concluye la explicación de la Búsqueda de Primero en Profundidad.</string>
    <string name="DepthFirstSearch4">Para puntos agregados como candidatos al mismo tiempo, no importa cuál es seleccionado. Esta vez, por conveniencia, seleccionaremos puntos del lado izquierdo.</string>
    <string name="DepthFirstSearch5">Ya que todos ellos se convirtieron en candidatos al mismo tiempo, seleccionaremos B.</string>
    <string name="DepthFirstSearch6">Nos movemos al punto seleccionado.</string>
    <string name="DepthFirstSearch7">E y F son accesibles desde el punto actual (B) y son agregados como nuevos candidatos.</string>
    <string name="DepthFirstSearch8">Los candidatos son gestionados bajo la regla \"Last In First Out\" (LIFO) que en español es \"Último en Entrar Primero en Salir\" (UEPS). Esto hace que sea posible construir una estructura de datos en \"Pila\".</string>
    <string name="DepthFirstSearch9">Las \"Pilas\" están explicadas en detalle en otra sección de esta app.</string>
    <string name="DiffieHellman">Intercambio de Claves Diffie-Hellman</string>
    <string name="DiffieHellman0">El \"Intercambio de claves Diffie-Hellman\" es un método para compartir de forma segura claves entre 2 usuarios.</string>
    <string name="DiffieHellman1">Antes de usar fórmulas matemáticas para explicarlo, comencemos con un entendimiento conceptual usando un diagrama.</string>
    <string name="DiffieHellman10">puede ser usada como elemento inicial para sintetizar una nueva llave compartida.</string>
    <string name="DiffieHellman11">En el ejemplo en el diagrama vemos que usando las llaves P y P-S, ha sido sintetizada una nueva llave P-P-S.</string>
    <string name="DiffieHellman12">En otras palabras, cualquier llave sintetizada puede ser combinada posteriormente también.</string>
    <string name="DiffieHellman13">Intentemos intercambiar llaves de forma segura entre los agentes A y B usando este método.</string>
    <string name="DiffieHellman14">Primero, el agente A prepara la llave P. Esta llave P puede ser conocida por cualquiera sin ningún problema.</string>
    <string name="DiffieHellman15">El agente A envía la llave P al agente B.</string>
    <string name="DiffieHellman16">Luego, tanto A como B preparan las llaves secretas SA y SB, respectivamente.</string>
    <string name="DiffieHellman17">Las llaves SA y SB deben ser manejadas de tal forma que nadie pueda poner sus manos sobre ellas.</string>
    <string name="DiffieHellman18">El agente A sintetiza una nueva llave P-SA desde la llave P y su llave secreta SA.</string>
    <string name="DiffieHellman19">De igual forma, B sintetiza una llave P-SB desde la llave P y su llave secreta SB.</string>
    <string name="DiffieHellman2">Digamos que existe un método especial para combinar 2 llaves.</string>
    <string name="DiffieHellman20">Ahora A envía la llave P-SA al agente B.</string>
    <string name="DiffieHellman21">El agente B envía también su llave P-SB al agente A.</string>
    <string name="DiffieHellman22">El agente A combina su llave secreta SA con la llave recibida P-SB para obtener una nueva llave P-SA-SB.</string>
    <string name="DiffieHellman23">B hace lo mismo, y combina su propia llave secreta SB con la llave que recibió de A, P-SA, para obtener la llave P-SA-SB.</string>
    <string name="DiffieHellman24">Ahora tanto A como B poseen juntos la llave P-SA-SB.</string>
    <string name="DiffieHellman25">Esta será la llave usada para la encriptación y decriptación de los datos que intercambiarán entre ellos.</string>
    <string name="DiffieHellman26">Verifiquemos la seguridad de este método de intercambio de llaves.</string>
    <string name="DiffieHellman27">Ya que las llaves P, P-SA y P-SB son enviadas a través de internet,</string>
    <string name="DiffieHellman28">existe la posibilidad de que hayan sido interceptadas por un agente malicioso X.</string>
    <string name="DiffieHellman29">Sin embargo, el agente X no es capaz de sintetizar la llave P-SA-SB de las llaves que obtuvo al interceptar las comunicaciones.</string>
    <string name="DiffieHellman3">Con este método, cuando las llaves P y S son combinadas,</string>
    <string name="DiffieHellman30">Además, ya que las llaves no pueden ser deconstruidas, no es posible obtener las llaves secretas SA y SB.</string>
    <string name="DiffieHellman31">Entonces, ya que X no es capaz de sintetizar la llave P-SA-SB, este método de intercambio de llaves se considera seguro.</string>
    <string name="DiffieHellman32">Ahora intentemos expresar este método de intercambio de llaves en términos matemáticos.</string>
    <string name="DiffieHellman33">Primero, explicaremos la operación \"mod\".</string>
    <string name="DiffieHellman34">La operación \"mod\" encuentra el remanente de una división.</string>
    <string name="DiffieHellman35">Para A mod B, obtendremos C, que es el remanente de dividir A entre B.</string>
    <string name="DiffieHellman36">veamos algunos ejemplos de operaciones usando números concretos.</string>
    <string name="DiffieHellman37">Ahora, pensemos en el método de intercambio de llaves en términos matemáticos.</string>
    <string name="DiffieHellman38">La llave P, que fue hecha al comienzo puede hacerse pública, y será expresada como dos números: P y G en la fórmula.</string>
    <string name="DiffieHellman39">P es un número primo extremadamente grande. G será elegido de entre los denominados generadores del número P, o también conocidos como números raíz primitiva.</string>
    <string name="DiffieHellman4">una nueva llave P-S es construida desde los componentes de la llave P y la llave S.</string>
    <string name="DiffieHellman40">Un número exacto de raíces primitivas existe para todos los números primos P.</string>
    <string name="DiffieHellman41">Primero, el agente A preparará el número primo P y el primitivo G. Estos dos números pueden ser conocidos por cualquiera sin ningún inconveniente.</string>
    <string name="DiffieHellman42">El agente A envía los números P y G al agente B.</string>
    <string name="DiffieHellman43">Luego, el agente A prepara el número secreto X, y el agente B prepara el número secreto Y.</string>
    <string name="DiffieHellman44">Además, los números secretos X y Y deben ser menores que el número P-2.</string>
    <string name="DiffieHellman45">Tanto el agente A como el agente B calculan la siguiente operación: (raíz primitiva G elevado a la potencia de su número secreto) mod P = (G^X) mod P</string>
    <string name="DiffieHellman46">Esta operación es a lo que nos referíamos conceptualmente como Síntesis.</string>
    <string name="DiffieHellman47">Los agentes A y B intercambian los resultados de sus operaciones.</string>
    <string name="DiffieHellman48">Los agentes A y B ahora calculan: (el número sintetizado recibido de su contraparte elevado a la potencia de su propio número secreto) mod P.</string>
    <string name="DiffieHellman49">La ejecución de esta operación arroja exactamente el mismo resultado para ambos.</string>
    <string name="DiffieHellman5">Este método tiene dos características especiales.</string>
    <string name="DiffieHellman50">De esta forma, los agentes A y B pudieron compartir de forma segura números que pueden ser usados como claves.</string>
    <string name="DiffieHellman51">Intentemos verificar la seguridad de este método de intercambio de llaves o claves.</string>
    <string name="DiffieHellman52">Dado que los números son enviados a través de internet,</string>
    <string name="DiffieHellman53">existe la posibilidad de que hayan sido interceptadas por un agente malicioso X.</string>
    <string name="DiffieHellman54">Sin embargo, los números compartidos entre A y B no pueden ser calculados desde los números que X pudo haber obtenido al interceptarlos.</string>
    <string name="DiffieHellman55">Además, los números secretos X y Y no pueden ser resueltos ni deducidos de ninguna forma.</string>
    <string name="DiffieHellman56">El método para resolver por X en la operación [ (G^X) mod P ] se llama \"Logaritmo Discreto\" y aún no ha sido descubierto.</string>
    <string name="DiffieHellman57">Se puede decir que el método de intercambio de llaves Diffie-Hellman es un método que utiliza el problema del logaritmo discreto.</string>
    <string name="DiffieHellman58">Esto concluye la explicación del Intercambio de Claves Diffie-Hellman.</string>
    <string name="DiffieHellman6">La primera característica es que si alguien posee la llave P con la cual fue construida la llave P-S,</string>
    <string name="DiffieHellman7">es imposible extraer o descifrar la llave S.</string>
    <string name="DiffieHellman8">En otras palabras, aún si es posible sintetizar una llave, no es posible deconstruirla.</string>
    <string name="DiffieHellman9">La segunda característica es que cualquier llave construida combinando otras llaves,</string>
    <string name="DiffieHellmanDescription">El \"Intercambio de claves Diffie-Hellman\" es un método para compartir de forma segura claves entre 2 usuarios. Podrá estudiar este tema al comprar todos los algoritmos.</string>
    <string name="DigitalCertification">Certificados Digitales</string>
    <string name="DigitalCertification0">El sistema criptográfico de llave pública tiene el problema de no garantizar a quién pertenece una llave.</string>
    <string name="DigitalCertification1">Por esto, cuando un agente A intenta enviar la llave pública a B,</string>
    <string name="DigitalCertification10">Una autoridad de certificación tiene sus propias llaves públicas (PC) y llaves secretas (SC) que prepara por sí misma.</string>
    <string name="DigitalCertification11">El agente A prepara su propia información personal, incluyendo la llave pública (PA) y una dirección de correo electrónico,</string>
    <string name="DigitalCertification12">y las envía a la autoridad de certificación.</string>
    <string name="DigitalCertification13">Una vez la confirmación ha sido llevada a cabo, la autoridad de certificación usa su llave secreta (SC) y crea una firma digital a partir de la información del agente A.</string>
    <string name="DigitalCertification14">Una explicación más detallada acerca de las \"Firmas Digitales\" está disponible en otra parte de esta app.</string>
    <string name="DigitalCertification15">Luego, la firma digital creada y la demás información son incluidas en un mismo archivo,</string>
    <string name="DigitalCertification16">y es enviado al agente A.</string>
    <string name="DigitalCertification17">Este archivo se convierte en el Certificado Digital de A.</string>
    <string name="DigitalCertification18">En lugar de una llave pública, a envía este archivo conteniendo el certificado digital al agente B.</string>
    <string name="DigitalCertification19">B confirma que la dirección de correo electrónico en el certificado digital pertenece a A.</string>
    <string name="DigitalCertification2">un agente malicioso podría interponer una llave diferente sin que nadie se entere.</string>
    <string name="DigitalCertification20">Luego, B obtiene la llave pública de la autoridad de certificación,</string>
    <string name="DigitalCertification21">y verifica que la firma digital en el certificado digital proviene de la autoridad de certificación.</string>
    <string name="DigitalCertification22">La firma digital que viene dentro del certificado digital sólo puede verificarse usando la llave pública (PC) de la autoridad de certificación.</string>
    <string name="DigitalCertification23">En otras palabras, si los resultados del proceso de verificación no tienen ningún inconveniente, entonces este certificado digital fue creado sin ninguna duda por la autoridad de certificación.</string>
    <string name="DigitalCertification24">Ya que se ha confirmado que la forma digital pertenece a A, y que fue emitida por una autoridad de certificación, la llave pública (PA) es extraída de la firma digital.</string>
    <string name="DigitalCertification25">Con esto se completa la entrega de una llave pública entre A y B.</string>
    <string name="DigitalCertification26">Veamos si existe algún problema con este tipo de entrega de llave pública.</string>
    <string name="DigitalCertification27">Sigamos que un agente malicioso X, haciéndose pasar por A, intenta pasar su propia llave pública.</string>
    <string name="DigitalCertification28">Sin embargo, B ni tiene ninguna razón para desconfiar una llave que fue enviada como un certificado digital.</string>
    <string name="DigitalCertification29">Así que, ¿qué pasa si X se hace pasar por A e intenta registrar su propia llave pública ante una autoridad de certificación?</string>
    <string name="DigitalCertification3">AL usar un sistema de \"Certificado Digital\", se puede garantizar quién es el creador de una llave pública.</string>
    <string name="DigitalCertification30">En tal caso, X no tiene acceso a la cuenta de correo electrónico de A, así que no logra finalizar la certificación y el certificado no es emitido.</string>
    <string name="DigitalCertification31">El agente X sólo puede crear certificados digitales que usan su propia cuenta de correo electrónico. Entonces, no puede obtener la certificación de A.</string>
    <string name="DigitalCertification32">Como queda claro, al usar un sistema de certificación digital es posible verificar el dueño de una llave pública.</string>
    <string name="DigitalCertification33">Ahora, anteriormente habíamos mencionado que B recibió la llave pública de la autoridad de certificación...</string>
    <string name="DigitalCertification34">lo que eleva una pregunta.</string>
    <string name="DigitalCertification35">¿Acaso fue la llave pública (PC) que recibió B, realmente creada por la autoridad de certificación?</string>
    <string name="DigitalCertification36">A raíz de esto, no existe manera de confirmar quién creó esa llave, y puede haber sido creada por X haciéndose pasar por la autoridad de certificación.</string>
    <string name="DigitalCertification37">En otras palabras, el problema que hemos visto con las llaves públicas ocurre aquí también.</string>
    <string name="DigitalCertification38">En la práctica, la llave pública de la autoridad de certificación (PC),</string>
    <string name="DigitalCertification39">también es entregada en forma de certificado digital.</string>
    <string name="DigitalCertification4">Revisemos en detalle cómo funciona el sistema de certificados digitales.</string>
    <string name="DigitalCertification40">Y quien \"firma\" este certificado digital,</string>
    <string name="DigitalCertification41">es una autoridad de certificación de aún más alto rango.</string>
    <string name="DigitalCertification42">Las autoridades de certificación crean una estructura de árbol, con las autoridades más altas creando firmas digitales para las de rango más bajo.</string>
    <string name="DigitalCertification43">Para ver cómo funciona esta estructura de árbol de las autoridades de certificación.,</string>
    <string name="DigitalCertification44">Tomemos por ejemplo una autoridad de certificación llamada Y que es altamente respetada por la sociedad.</string>
    <string name="DigitalCertification45">Aún si una empresa llamada G desea convertirse en autoridad de certificación y prestar los mismos servicios, no tiene la misma credibilidad en la sociedad.</string>
    <string name="DigitalCertification46">Entonces, la empresa G adquiere un certificado emitido por Y. Por supuesto, Y auditará y supervisará los procesos de G para asegurar que sea capaz de prestar sus servicios como autoridad de certificación.</string>
    <string name="DigitalCertification48">Como resultado, la empresa G puede promocionarse a sí misma como una empresa que ha logrado la confianza y el respaldo de Y.</string>
    <string name="DigitalCertification49">Al hacer esto, las empresas más grandes y seguras respaldan la confianza de las más pequeñas, organizadas bajo una estructura de árbol.</string>
    <string name="DigitalCertification5">Digamos que el agente A, en posesión de la llave pública (PA) y la llave secreta (SA),</string>
    <string name="DigitalCertification50">Entonces, ¿quién está en el tope de esa estructura de árbol?</string>
    <string name="DigitalCertification51">La autoridad de certificación que mantiene la posición más alta se llama \"Autoridad de Certificación Raíz\", en inglés \"Root certification authority (rootCA)\", y certifica su propia validez.</string>
    <string name="DigitalCertification52">Además, los certificados que emite una autoridad raíz se llaman \"Certificados Raíz\".</string>
    <string name="DigitalCertification53">Si una autoridad raíz no es confiable y la sociedad lo sabe, sus certificados no serán usados.</string>
    <string name="DigitalCertification54">De esta forma, un número considerable de ellas son quienes ya tienen la aceptación y la confianza del público, como grandes empresas y agencias gubernamentales.</string>
    <string name="DigitalCertification55">Hasta ahora hemos tratado el tema de la transferencia de llaves públicas entre individuos,</string>
    <string name="DigitalCertification56">pero los certificados digitales también son usados al comunicarse un sitio web.</string>
    <string name="DigitalCertification57">Al obtener un certificado digital que incluye la llave pública de un sitio web, podemos estar seguros de que el sitio no está siendo infiltrado por un tercero.</string>
    <string name="DigitalCertification58">Este certificado se llama \"Certificado de Servidor\" o \"Server Certificate\", y también es emitido por una autoridad de certificación.</string>
    <string name="DigitalCertification59">En el caso de un individuo, el certificado está enlazado a una dirección de correo electrónico,</string>
    <string name="DigitalCertification6">está listo para enviar la llave pública (PA) al agente B.</string>
    <string name="DigitalCertification60">pero en el caso del certificado de servidor, está ligado a un dominio.</string>
    <string name="DigitalCertification61">Un certificado de servidor garantiza que la llave pública fue emitida por la organización que gestiona el dominio al cual está ligada la llave.</string>
    <string name="DigitalCertification62">En otras palabras, se puede confirmar que la organización que maneja el dominio y el contenido del sitio web en cuestión, son de hecho la organización verídica.</string>
    <string name="DigitalCertification63">De esta forma, los certificados digitales son un sistema de garantizarle a la sociedad quiénes son los creadores de una llave pública, a través de autoridades de certificación.</string>
    <string name="DigitalCertification64">Esto concluye la explicación de los Certificados Digitales.</string>
    <string name="DigitalCertification7">Primero, el agente A debe solicitar a una autoridad de certificación que genere un certificado que evidencia que es dueño o dueña de su llave pública (PA).</string>
    <string name="DigitalCertification8">Una autoridad de certificación es una organización que maneja certificados digitales. Básicamente, cualquiera puede convertirse en una organización como esta, y existen en grandes números.</string>
    <string name="DigitalCertification9">Así que, lo mejor es utilizar organizaciones confiables como gobiernos y grandes compañías que son constantemente auditadas.</string>
    <string name="DigitalCertificationDescription">Los \"Certificados Digitales\" son sistemas que certifican el creador de una llave pública. Podrá estudiar este tema al comprar todos los algoritmos.</string>
    <string name="DigitalSignature">Firmas Digitales</string>
    <string name="DigitalSignature0">Un sistema de \"Firmas Digitales\" garantiza evitar el repudio de mensajes...</string>
    <string name="DigitalSignature1">en adición a la detección de autenticación y falsificación, que son las dos funciones implementadas por el uso de códigos de autenticación de mensajes.</string>
    <string name="DigitalSignature10">Por ejemplo, luego de recibir el mensaje de parte de A, el agente B puede decir que es él el creador original del mensaje.</string>
    <string name="DigitalSignature100">Estrictamente hablando, también existen otras instancias donde el método de cálculo para la creación de la firma digital es diferente del de la encriptación.</string>
    <string name="DigitalSignature101">Sin embargo, estos métodos comparten la característica de las llaves compartidas para la creación de firmas, y las llaves públicas para su verificación; lo estamos explicando de esta manera por conveniencia.</string>
    <string name="DigitalSignature11">También, al estar usando llaves compartidas, el agente A necesitará crear una nueva llave para enviar información a otro destinatario que no sea B.</string>
    <string name="DigitalSignature12">Por el contrario, en lugar de usar MACs, el sistema de firmas digitales usa datos que sólo el emisor original puede crear, ya que es la esencia de su identificación. Estos datos únicos se llaman \"Firmas Digitales\".</string>
    <string name="DigitalSignature13">Demos un vistazo a la estructura del proceso.</string>
    <string name="DigitalSignature14">La \"Sig\" en la imagen es la firma digital, que sólo puede ser creada por A.</string>
    <string name="DigitalSignature15">Entonces, cuando un mensaje al que ha sido asignada la firma digital de A es recibido, está garantizado que el emisor de ese mensaje de hecho es A.</string>
    <string name="DigitalSignature16">El receptor del mensaje, el agente B, es capaz de confirmar que la firma digital pertenece a A, pero no es capaz de replicarla por sí mismo.</string>
    <string name="DigitalSignature17">En contraste a los códigos de autenticación de mensajes, ya que la llave compartida no es usada, A puede enviar mensajes a diferentes destinos y receptores con la misma firma digital.</string>
    <string name="DigitalSignature2">Revisemos los códigos de autenticación de mensajes.</string>
    <string name="DigitalSignature20">Revisemos más en detalle cómo se crea una firma digital.</string>
    <string name="DigitalSignature21">Mientras la llave usada en la creación de los MACs es una llave compartida,</string>
    <string name="DigitalSignature22">al crear una firma digital estamos usando un proceso perteneciente al \"sistema criptográfico de llave pública\".</string>
    <string name="DigitalSignature23">En otra parte de esta app se encuentra una descripción detallada del \"sistema criptográfico de llave pública\". Aquí sólo lo revisaremos superficialmente.</string>
    <string name="DigitalSignature24">El agente A ha encriptado la información y está listo para enviarla a B.</string>
    <string name="DigitalSignature25">Primero, el receptor, que es B, prepara una llave pública P y una llave secreta S.</string>
    <string name="DigitalSignature26">B pasa la llave pública (P) a su contraparte A.</string>
    <string name="DigitalSignature27">El agente A usa la llave pública proporcionada por B para encriptar los datos.</string>
    <string name="DigitalSignature28">Envía los datos encriptados al agente B.</string>
    <string name="DigitalSignature29">B desencripta los datos usando su propia llave secreta, obteniendo el mensaje original y completando el intercambio.</string>
    <string name="DigitalSignature3">El sistema de código de autenticación de mensajes asigna un MAC a un mensaje para identificar que el emisor del mensaje es el dueño de la llave de encriptación.</string>
    <string name="DigitalSignature30">Así, con el sistema criptográfico de llave pública, se usó la llave pública para encriptar los datos, y se usó la llave secreta para desencriptarlos.</string>
    <string name="DigitalSignature31">Entonces, cualquiera puede encriptar los datos usando la llave pública,</string>
    <string name="DigitalSignature32">pero como sólo B posee la llave secreta, se garantiza que sólo B puede desencriptarla.</string>
    <string name="DigitalSignature33">Ahora, ¿qué pasa si reversamos el proceso, usando la llave secreta para encriptar y la pública para desencriptar?</string>
    <string name="DigitalSignature34">En este caso, cómo sólo A tiene la llave secreta, sólo A puede encriptar la información, y el texto cifrado creado puede ser desencriptado por cualquiera que posea la llave pública.</string>
    <string name="DigitalSignature35">Esto no tiene ningún sentido como forma de encriptación, pero viéndolo desde otra perspectiva, es claro que el creador del texto cifrado necesariamente es A.</string>
    <string name="DigitalSignature36">En una firma digital, este texto cifrado que sólo A puede crear es usado como la firma.</string>
    <string name="DigitalSignature37">Revisemos ahora cómo funciona el intercambio de un mensaje en el que ha sido usada una firma digital.</string>
    <string name="DigitalSignature38">Primero, el agenta A prepara el mensaje que desea enviar, al igual que las llaves secreta y pública.</string>
    <string name="DigitalSignature39">La diferencia entre este tema y el sistema criptográfico de llave pública radica en que es el emisor, y no el receptor, quien prepara las llaves pública y secreta.</string>
    <string name="DigitalSignature4">Aquí, por conveniencia, enviaremos el mensaje sin encriptar.</string>
    <string name="DigitalSignature40">El agente A pasa la llave pública al agente B.</string>
    <string name="DigitalSignature41">Luego, se encripta el mensaje usando la llave secreta.</string>
    <string name="DigitalSignature42">El texto cifrado servirá como firma digital, y será marcado con \"Sig.\" en el diagrama de aquí en adelante.</string>
    <string name="DigitalSignature43">El agente A envía el mensaje y la firma digital a B.</string>
    <string name="DigitalSignature44">B desencripta el texto cifrado usando la llave pública.</string>
    <string name="DigitalSignature45">Se confirma que el mensaje desencriptado coincide con el mensaje recibido, completando así el intercambio.</string>
    <string name="DigitalSignature46">El texto cifrado, que puede ser desencriptado con la llave pública, pudo solamente ser creado por A, quien tiene la llave secreta.</string>
    <string name="DigitalSignature47">Así se confirma que el mensaje sí fue creado y enviado por A, y que no ha sido falsificado.</string>
    <string name="DigitalSignature48">También, dado que la firma de A no puede ser recreada por B, quien sólo cuenta con la llave pública y no la secreta, el problema del repudio de mensajes se evade con éxito.</string>
    <string name="DigitalSignature49">Sin embargo, dado que el sistema criptográfico de llave pública toma tiempo para encriptar y desencriptar información,</string>
    <string name="DigitalSignature5">El agente A envía el mensaje y el MAC, junto a la clave de encriptación usada para crear el MAC, al agente B.</string>
    <string name="DigitalSignature50">en lugar de encriptar el mensaje directamente,</string>
    <string name="DigitalSignature51">y para reducir el tiempo de cálculo necesario, en primer lugar se determina el Valor Hash del mensaje,</string>
    <string name="DigitalSignature52">y es ese valor hash lo que se encripta y se usa como firma.</string>
    <string name="DigitalSignature53">La explicación detallada del proceso y los Valores Hash se encuentran en otra parte de esta app.</string>
    <string name="DigitalSignature54">El mensaje y la firma digital son enviados al agente B.</string>
    <string name="DigitalSignature55">De la misma manera, el agente B recalcula el valor hash del mensaje recibido.</string>
    <string name="DigitalSignature56">B también desencripta la firma usando la llave pública, y de ahí se obtiene un valor hash.</string>
    <string name="DigitalSignature57">Al comprar ambos valores hash, el que B ha calculado del mensaje y el que ha logrado desencriptar de la firma, se confirma que ambos valores coinciden perfectamente y se considera terminado en intercambio.</string>
    <string name="DigitalSignature58">Las Firmas Digitales proporcionan detección de autenticación y falsificación, y eliminan el problema del repudio de mensajes, pero existe un problema.</string>
    <string name="DigitalSignature59">El agente B cree que usando la firma digital de A puede estar seguro de que sí es A quien ha enviado el mensaje,</string>
    <string name="DigitalSignature6">B recrea el MAC usando el mensaje y la llave recibidas, confirmando que el MAC coincide con el que recibió de A.</string>
    <string name="DigitalSignature60">pero en realidad no puede descartarse por completo que algún agente malicioso X se haya hecho pasar por A.</string>
    <string name="DigitalSignature61">Este problema fundamental radica en el hecho de que los sistemas criptográficos de llave pública no permiten saber quién ha emitido una llave pública, o a quién le pertenece.</string>
    <string name="DigitalSignature62">No hay un solo fragmento de información en la llave pública que permita determinar quién la ha creado.</string>
    <string name="DigitalSignature63">Entonces, existe la posibilidad de que esa llave pública haya sido creada por alguien que está suplantando al agente A...</string>
    <string name="DigitalSignature64">al igual que la posibilidad de que la llave en realidad es creada por A, pero ninguna se sabe con certeza.</string>
    <string name="DigitalSignature66">Este problema puede ser resuelto usando lo que se conoce como \"Certificado Digital\".</string>
    <string name="DigitalSignature67">En un Certificado Digital, la información acerca del creador de una llave pública es parte de la llave misma, y es manejada como un solo certificado.</string>
    <string name="DigitalSignature68">La explicación detallada de los \"Certificados Digitales\" se encuentra en otra parte de esta app.</string>
    <string name="DigitalSignature69">Esto concluye la explicación de las Firmas Digitales.</string>
    <string name="DigitalSignature8">Esto verifica que A es el emisor del mensaje y que no ha sido falsificado.</string>
    <string name="DigitalSignature9">Sin embargo, como los códigos de autenticación de mensajes usan llaves compartidas, cualquiera que tenga acceso a la llave puede suplantar al verdadero emisor del mensaje.</string>
    <string name="DigitalSignatureDescription">Las \"Firmas Digitales\" son sistemas para solucionar los problemas de Spoofing, falsificación, y repudio. Podrá estudiar este tema al comprar todos los algoritmos.</string>
    <string name="Dijkstra">Algoritmo de Dijkstra</string>
    <string name="Dijkstra0">El \"Algoritmo de Dijkstra\" es usado para determinar la ruta más corta en un grafo, de manera más eficiente que el Algoritmo Bellman-Ford.</string>
    <string name="Dijkstra1">Para comenzar, el costo inicial de cada punto es definido. El punto inicial se define con costo cero ( 0 ) y todos los demás se definen con costo infinito.</string>
    <string name="Dijkstra10">Tomando el camino que se ha determinado como el más corto, nos movemos hacia B.</string>
    <string name="Dijkstra100">La razón es el hecho de que elegir otro camino requeriría pasar a través de C, resultando en un costo mayor que el costo actual de A-B.</string>
    <string name="Dijkstra101">La ruta A-B-D es el resultado de elegir los puntos candidatos con los menores costos. De esa manera, sabemos que pasar por cualquier otro punto para llegar a D resultará en un mayor costo, con toda seguridad.</string>
    <string name="Dijkstra102">En este caso, B y C se convierten en candidatos.</string>
    <string name="Dijkstra11">Los puntos accesibles desde el punto actual son agregados como candidatos, en este caso los puntos C, D y E.</string>
    <string name="Dijkstra12">Usando el mismo método que antes, calculamos el costo de cada candidato.</string>
    <string name="Dijkstra13">El costo total de moverse al punto C desde B es 2 + 6 = 8, que es mayor que el valor actual de 5, así que no se hace una actualización.</string>
    <string name="Dijkstra14">El costo de los puntos restantes, D y E, fueron actualizados.</string>
    <string name="Dijkstra15">De los puntos candidatos, elegimos el que tiene el menor costo, en este caso es D.</string>
    <string name="Dijkstra16">A este punto, hemos determinado que la ruta elegida A-B-D es la ruta más corta desde el punto inicial hasta D.</string>
    <string name="Dijkstra17">De esta manera, el algoritmo de Dijkstra busca a través del grafo para determinar la ruta más corta hasta cada punto, una ruta a la vez.</string>
    <string name="Dijkstra18">La misma operación es repetida hasta que llegamos al punto G.</string>
    <string name="Dijkstra2">Comenzamos desde el primer punto.</string>
    <string name="Dijkstra3">Comenzando en la ubicación actual, buscamos por puntos que no han sido explorados. Una vez encontrados, se convierten en puntos candidatos para el siguiente movimiento.</string>
    <string name="Dijkstra35">Hemos llegado al punto G, así que la búsqueda finaliza.</string>
    <string name="Dijkstra36">Al final, los árboles resaltados en naranja, llamados \"árboles de rutas más cortas\", muestran la ruta más corta desde cada punto en el grafo.</string>
    <string name="Dijkstra37">La ruta resaltada más gruesa, es la ruta más corta hasta el último punto, G.</string>
    <string name="Dijkstra38">Como se puede ver, comparado con el algoritmo Bellman-Ford que compara repetidamente y actualiza el costo para cada eje, el algoritmo de Dijkstra busca eficientemente la ruta más corta al identificar qué punto agregar luego a la ruta más corta ya encontrada.</string>
    <string name="Dijkstra39">Igual que el algoritmo Bellman-Ford, incluso si hay ejes direccionados o con costos diferentes según el sentido de recorrido...</string>
    <string name="Dijkstra4">El costo de cada ruta es calculado. El método de cálculo es igual al costo de la posición actual mas el costo de moverse hasta cada candidato.</string>
    <string name="Dijkstra40">El algoritmo de Dijkstra encuentra la ruta más corta.</string>
    <string name="Dijkstra41">Los grafos donde la dirección es fija, como en el diagrama, se llaman \"Sistemas direccionados\", y donde no hay restricciones de tráfico se llaman \"Grafos o Sistemas No Direccionados\".</string>
    <string name="Dijkstra42">Las ocasiones donde el Algoritmo de Dijkstra no puede encontrar correctamente la ruta más corta son los sistemas donde existen \"costos negativos\". En esto, este algoritmo se diferencia del algoritmo Bellman-Ford.</string>
    <string name="Dijkstra43">En este grafo, la ruta A-C-B-G es la ruta más corta e incluye el trayecto C-B, que contiene un costo negativo.</string>
    <string name="Dijkstra44">Como una prueba, intentemos usar el Algoritmo de Dijkstra.</string>
    <string name="Dijkstra45">Los puntos B y C, que son accesibles desde el punto inicial A y no han sido explorados aún, tienen costos de 2 y 4 respectivamente.</string>
    <string name="Dijkstra46">En este punto, el algoritmo de Dijkstra determina la ruta más corta desde el punto A al punto B es el trayecto A-B.</string>
    <string name="Dijkstra47">Por esta razón, usar cualquier otro camino requiere pasar por C, y la ruta A-C tiene costo más alto que la ruta A-B.</string>
    <string name="Dijkstra48">Como ya se ha dicho, se asume que todos los ejes tendrán costo mayor que 0, en otra palabras, no debe existir ejes sin costo o con costo negativo.</string>
    <string name="Dijkstra49">El algoritmo ha determinado que la ruta más corta desde el punto A hasta el punto G es la ruta A-B-G, con un costo de 3. Esto, como se mencionó antes, es un error.</string>
    <string name="Dijkstra5">Por ejemplo, en el caso de moverse hasta B, el costo inicial es 0, así que el costo de movimiento es 0 + 2 = 2. De igual manera, el costo de moverse a C es 0 + 5 = 5</string>
    <string name="Dijkstra52">Aún así, con un grafo como este...</string>
    <string name="Dijkstra53">que contiene un \"ciclo negativo\" que resulta en un costo negativo cuando se toman ciertas rutas...</string>
    <string name="Dijkstra54">se llegará a una solución errónea usando el algoritmo de Dijkstra, aún si de hecho existe una ruta más corta.</string>
    <string name="Dijkstra55">Entonces, el Algoritmo de Dijkstra no puede ser usado en sistemas que contengan un ciclo negativo.</string>
    <string name="Dijkstra56">Por el contrario, para grafos que no contienen costos negativos, puede decirse que el Algoritmo de Dijkstra es capaz de encontrar la ruta más corta con menos cálculos que el Algoritmo Bellman-Ford.</string>
    <string name="Dijkstra57">Esto concluye la explicación del Algoritmo de Dijkstra.</string>
    <string name="Dijkstra6">Si el costo calculado es menor que el valor actual de cada punto evaluado, el costo es actualizado.</string>
    <string name="Dijkstra7">Ya que el costo actual de B y C es infinitamente alto, los costos calculados son menores y B y C son actualizados con sus nuevos costos, 2 y 5 respectivamente.</string>
    <string name="Dijkstra8">De los puntos candidatos, elegimos el que ofrece un menor costo, que en este caso es B.</string>
    <string name="Dijkstra9">Para este momento, ya hemos determinado que la ruta A-B es elegida como la ruta más corta desde el punto inicial hasta B.</string>
    <string name="DijkstraDescription">El \"Algoritmo de Dijkstra\" es usado para determinar la ruta más corta de forma eficiente. Podrá estudiar este tema al comprar todos los algoritmos.</string>
    <string name="Euclidean">Algoritmo de Euclides</string>
    <string name="Euclidean0">El \"Algoritmo de Euclides\" es un algoritmo que encuentra el mayor divisor común entre dos números.</string>
    <string name="Euclidean1">Descubierto por Euclides alrededor de la mitad del siglo IV antes de cristo, muchas veces es conocido como el algoritmo más antiguo del mundo.</string>
    <string name="Euclidean10">Para A mod B, obtendremos C, que es el remanente de dividir A entre B.</string>
    <string name="Euclidean11">Veamos ejemplos de la operación usando números concretos.</string>
    <string name="Euclidean12">Ahora, conozcamos el Algoritmo de Euclides en acción.</string>
    <string name="Euclidean13">Primero encontramos el remanente de dividir el número más grande entre el número más pequeño.</string>
    <string name="Euclidean14">En otras palabras, llevamos a cabo la operación mod entre el número más grande y el número más pequeño que estamos estudiando.</string>
    <string name="Euclidean15">El resultado fue de 417 como remante.</string>
    <string name="Euclidean16">En esta ocasión calculamos mod entre el divisor anterior (695) y el resultado anterior (417).</string>
    <string name="Euclidean17">Obtenemos 278.</string>
    <string name="Euclidean18">Repetimos la misma operación, calculando la operación mod entre 417 y 278.</string>
    <string name="Euclidean19">Obtenemos 139.</string>
    <string name="Euclidean2">Por ejemplo, consideremos el mayor denominador común de 1112 y 695.</string>
    <string name="Euclidean20">Repetimos la misma operación, calculando la operación mod entre 278 y 139.</string>
    <string name="Euclidean21">Obtenemos 0.</string>
    <string name="Euclidean22">En otras palabras, 278 es divisible por 139.</string>
    <string name="Euclidean23">Cuando el remanente es 0, el divisor de la última operación mod llevada a acabo (139 en este caso) es el mayor divisor común entre los dos números estudiados. Eso quiere decir que 139 es el mayor divisor común entre 1112 y 695.</string>
    <string name="Euclidean24">¿Cómo es que el Algoritmo de Euclides encontró el mayor divisor común? Consideremos esa pregunta usando el diagrama.</string>
    <string name="Euclidean25">Intentemos expresar 1112 y 695 en términos de longitud de una barra.</string>
    <string name="Euclidean26">Agregaremos segmentos en incrementos de n, el mayor divisor común.</string>
    <string name="Euclidean27">Se ha determinado que 139 es el mayor divisor común, así que por conveniencia, 1112 \"ha agregado 8 segmentos\" y 695 \"ha agregado 5 segmentos\".</string>
    <string name="Euclidean28">En realidad no se sabe cuántos segmentos hay en cada barra.</string>
    <string name="Euclidean29">Sin embargo, sí sabemos que ambos números (1112 y 695) son divisibles por un común divisor n.</string>
    <string name="Euclidean3">Con el método usual, factorizamos los dos números en números primos...</string>
    <string name="Euclidean30">Aquí, como en la operación anterior, encontraremos el remanente número mayor (1112) dividido entre el número menor (695).</string>
    <string name="Euclidean31">Obtuvimos 417. En el diagrama puede verse que 417 es fácilmente divisible en segmentos de amplitud n.</string>
    <string name="Euclidean32">Repetimos la operación anterior.</string>
    <string name="Euclidean35">Esta vez, 695 mod 417 arroja un resultado de 278.</string>
    <string name="Euclidean36">Este remanente de 278 también es un múltiplo de n, en otras palabras, contiene también el mayor divisor común.</string>
    <string name="Euclidean37">Repetimos la operación anterior.</string>
    <string name="Euclidean38">Como 278 mod 139 = 0, sabemos que 278 es divisible por 139.</string>
    <string name="Euclidean39">Aquí es cuando encontramos que el mayor divisor común n = 139.</string>
    <string name="Euclidean4">y encontramos el mayor divisor común de los números primos que comparten.</string>
    <string name="Euclidean40">En esta forma es que el Algoritmo de Euclides es capaz de encontrar el mayor divisor común simplemente repitiendo divisiones.</string>
    <string name="Euclidean41">Una gran ventaja es que incluso si se trata de dos números muy grandes, el algoritmo es capaz de encontrar el mayor divisor común con un procedimiento estándar.</string>
    <string name="Euclidean42">Esto concluye la explicación del Algoritmo de Euclides.</string>
    <string name="Euclidean5">Sabemos que el mayor divisor común entre 1112 y 695 es 139.</string>
    <string name="Euclidean6">Sin embargo, con este método, la factorización en números primos se vuelve más y más difícil a medida que los números a comparar son más grandes.</string>
    <string name="Euclidean7">Con el Algoritmo de Euclides, podemos encontrar el mayor divisor común de manera más eficiente.</string>
    <string name="Euclidean8">Antes de explicar el Algoritmo de Euclides, explicaremos lo que es la operación mod.</string>
    <string name="Euclidean9">La operación mod es una operación que encuentra el remanente de una división.</string>
    <string name="ExperimentalModeTitle">Simular</string>
    <string name="FewUnique">Few Unique</string>
    <string name="GetItemInfoFailed">La obtención de información ha fallado. Por favor, verifique su conexión a internet.</string>
    <string name="GraphSearchSection">Búsqueda en gráfico</string>
    <string name="Hanoi">Torre de Hanoi</string>
    <string name="Hanoi0">La \"Torre de Hanoi\" es un rompecabezas de mover discos.</string>
    <string name="Hanoi1">El diagrama muestra 3 varas, A,B y C con dos discos en la vara A.</string>
    <string name="Hanoi101">Veamos el ejemplo de cómo se mueven los discos dadas las condiciones ya mencionadas.</string>
    <string name="Hanoi102">Usando el mismo principio que antes, movemos los discos de la vara B a la vara C.</string>
    <string name="Hanoi15">El disco más pequeño está encima, así que podemos moverlo a la vara B.</string>
    <string name="Hanoi16">Movemos el disco grande a la vara C.</string>
    <string name="Hanoi17">Al mover el disco pequeño de la vara B a la vara C, terminamos los movimientos. Fuimos capaces de confirmar que alcanzar la meta es posible cuando tenemos dos discos.</string>
    <string name="Hanoi18">¿Qué tal con tres discos?</string>
    <string name="Hanoi19">Ignoremos el disco más grande y pensemos en cómo mover los dos discos restantes a la vara B.</string>
    <string name="Hanoi2">El objetivo es mover los discos a la vara C manteniendo los discos en el mismo orden en que están en A.</string>
    <string name="Hanoi20">Si movemos el disco restante en la misma forma general que antes, cuando había sólo dos discos, podemos moverlos a la vara B.</string>
    <string name="Hanoi21">Movemos el disco más grande a la vara C.</string>
    <string name="Hanoi22">Nuestros movimientos han terminado. Pudimos confirmar que se puede alcanzar la meta cuando hay tres discos.</string>
    <string name="Hanoi23">De hecho, es posible alcanzar la meta en este juego sin importar cuántos discos hay en juego.</string>
    <string name="Hanoi24">Intentemos probar esto usando inducción matemática.</string>
    <string name="Hanoi25">Fuimos capaces de alcanzar la meta cuando había un disco.</string>
    <string name="Hanoi27">Asumamos que podemos alcanzar la meta cuando hay n discos.</string>
    <string name="Hanoi29">Ahora pensemos en mover n+1 discos.</string>
    <string name="Hanoi30">Ignoraremos el disco más grande.</string>
    <string name="Hanoi31">Basados en nuestras asunciones de que pudimos mover n discos, movemos n discos a la vara B.</string>
    <string name="Hanoi32">Ahora movemos el disco más grande a la vara C.</string>
    <string name="Hanoi33">Movemos los n discos de la vara B a la vara C. Ahora hemos terminado nuestros movimientos.</string>
    <string name="Hanoi34">Usando inducción matemática, probamos que la meta puede alcanzarse con cualquier número de discos.</string>
    <string name="Hanoi35">Ahora intentaremos pensar en la solución de la Torre de Hanoi.</string>
    <string name="Hanoi36">Al resolver la Torre de Hanoi con n discos, puede usarse la solución de la misma Torre de Hanoi con n-1 discos.</string>
    <string name="Hanoi37">Para resolver la Torre de Hanoi con n-1 discos, puede usarse la solución para n-2 discos, y así sucesivamente hasta que sólo hay un disco, llevándonos a la solución.</string>
    <string name="Hanoi38">Este método recursivo de pensamiento es usado en muchos algoritmos, como los llamados \"Algoritmos Recursivos\".</string>
    <string name="Hanoi39">Esto concluye la explicación de la Torre de Hanoi.</string>
    <string name="Hanoi4">Hay dos condiciones para mover los discos. La primera es que sólo puede moverse un disco a la vez.</string>
    <string name="Hanoi5">Mover un disco así no es un problema...</string>
    <string name="Hanoi6">pero no se puede mover dos discos al mismo tiempo, como en el diagrama.</string>
    <string name="Hanoi9">La segunda condición es que no puede ponerse un disco mayor encima de uno menor.</string>
    <string name="Hash">Tablas Hash</string>
    <string name="Hash0">Las \"Tablas Hash\"son un tipo de estructura de datos.</string>
    <string name="Hash1">Las Tablas Hash son buenas para almacenar conjuntos de datos hechos de \"Llaves\" y \"Valores\"</string>
    <string name="Hash10">La caja 2 tampoco fue Ally.</string>
    <string name="Hash11">La caja 3 tampoco fue Ally.</string>
    <string name="Hash12">La llave para la información contenida en la caja 4 corresponde con Ally.</string>
    <string name="Hash13">Al extraer el valor correspondiente, identificamos que el sexo de Ally es femenino (F).</string>
    <string name="Hash14">Así, la operación de búsqueda lineal implica un costo proporcional al tamaño de los datos.</string>
    <string name="Hash15">Toma tiempo buscar información en datos organizados como una Formación, haciéndola una opción inviable.</string>
    <string name="Hash16">Una Tabla Hash resuelve este problema.</string>
    <string name="Hash17">Prepararemos una Formación con algunos datos. Por conveniencia, usaremos 5 cajas en esta formación.</string>
    <string name="Hash18">Ahora almacenemos algunos datos.</string>
    <string name="Hash19">Al almacenar los datos de \"Joe\",</string>
    <string name="Hash2">En este caso, un nombre es la llave, y el sexo es el valor.</string>
    <string name="Hash20">calculamos el valor hash de la llave usando una función hash. El resultado obtenido en este caso es 4928.</string>
    <string name="Hash21">Una explicación más detallada de la \"Función Hash\" está disponible en esta app. Se trata de una función que convierte datos en valores de longitud fija.</string>
    <string name="Hash22">El valor hash buscado es dividido en el número de cajas en la formación, 5, para encontrar el remanente de la división.</string>
    <string name="Hash23">Esta operación es posible gracias a la operación \"mod\", que encuentra el remanente de una operación.</string>
    <string name="Hash24">El resultado de la operación mod es el valor 3.</string>
    <string name="Hash25">La información de \"Joe\" es almacenada en la caja número 3, coincidiendo con el resultado.</string>
    <string name="Hash26">Esta operación será repetida para almacenar todos los demás datos.</string>
    <string name="Hash27">Al almacenar los datos de \"Sue\",</string>
    <string name="Hash28">encontramos el valor hash de la llave, y llevamos a cabo la operación mod usando el número de cajas de la formación, 5. El resultado es 1.</string>
    <string name="Hash29">Los datos de \"Sue\" son almacenados en la caja 1 de la formación.</string>
    <string name="Hash3">Por ejemplo, imaginemos los datos en el diagrama almacenados como una Formación.</string>
    <string name="Hash30">Al almacenar los datos de \"Dan\",</string>
    <string name="Hash31">encontramos el valor hash de la llave, y llevamos a cabo la operación mod usando el número de cajas de la formación, 5. El resultado es 4.</string>
    <string name="Hash32">Los datos de \"Dan\" son almacenados en la caja 4 de la formación.</string>
    <string name="Hash33">Al almacenar los datos de \"Nell\",</string>
    <string name="Hash34">encontramos el valor hash de la llave, y llevamos a cabo la operación mod usando el número de cajas de la formación, 5. El resultado es 1.</string>
    <string name="Hash35">Cuando intentamos almacenar los datos de \"Nell\" en la caja 1 de la Formación,</string>
    <string name="Hash36">los datos de \"Sue\" ya han sido almacenados allí. Cuando un caso como este se presenta,</string>
    <string name="Hash37">los nuevos datos son conectados a los existentes como una Lista.</string>
    <string name="Hash38">Existen distintos tipos de estructuras de tablas hash, pero el método que usa listas se llama \"método de cadena\"-</string>
    <string name="Hash39">Al almacenar la información de \"Ally\",</string>
    <string name="Hash4">Preparamos 6 cajas para la Formación y almacenamos los datos en ellas.</string>
    <string name="Hash40">encontramos el valor hash de la llave, y llevamos a cabo una operación mod sobre ella usando el número de cajas existentes de la formación: 5. El resultado es 3.</string>
    <string name="Hash41">Como los datos de \"Joe\" ya están en la caja 3, los datos de \"Ally\" son conectados como una lista.</string>
    <string name="Hash42">Al almacenar la información de \"Bob\",</string>
    <string name="Hash43">encontramos el valor hash de la llave, y llevamos a cabo una operación mod sobre ella usando el número de cajas existentes de la formación: 5. El resultado es 3.</string>
    <string name="Hash44">Como los datos de \"Joe\" y \"Ally\" ya están en la caja 3, los datos de \"Bob\" son conectados como una lista.</string>
    <string name="Hash45">Toda la información ha sido almacenada con éxito, y la tabla hash está completa.</string>
    <string name="Hash46">Ahora imaginemos que buscamos saber el sexo de Dan.</string>
    <string name="Hash47">Para encontrar en qué caja ha sido almacenada esta información,</string>
    <string name="Hash48">encontramos el valor hash de la llave, y llevamos a cabo una operación mod sobre ella usando el número de cajas existentes de la formación: 5. El resultado es 4.</string>
    <string name="Hash49">La llave encontrada en la caja 4 de la formación corresponde con \"Dan\".</string>
    <string name="Hash5">Ahora imaginemos que queremos buscar el sexo de Ally.</string>
    <string name="Hash50">Al extraer su valor correspondiente, encontramos que el sexo de Dan es masculino (M).</string>
    <string name="Hash51">Así que ¿qué pasa cuando buscamos la información sobre el sexo de \"Ally\"?</string>
    <string name="Hash52">Para encontrar en qué caja ha sido almacenada esta información,</string>
    <string name="Hash53">encontramos el valor hash de la llave, y llevamos a cabo una operación mod sobre ella usando el número de cajas existentes de la formación: 5. El resultado es 3.</string>
    <string name="Hash54">La llave encontrada en la caja 3 corresponde a \"Joe\", no a \"Ally\".</string>
    <string name="Hash55">Entonces, una búsqueda lineal es llevada a cabo en la lista que comienza con los datos de \"Joe\".</string>
    <string name="Hash56">Datos con la llave \"Ally\" han sido encontrados.</string>
    <string name="Hash57">Al extraer su valor correspondiente, encontramos que el sexo de Ally es femenino (F).</string>
    <string name="Hash58">Como puede verse, las tablas hash permiten acceder rápidamente a información almacenada en una Formación, por medio del uso de la función hash.</string>
    <string name="Hash59">Cuando los valores hash se sobrelapan, se usan listas haciendo posible el uso flexible de una cantidad indeterminada de información.</string>
    <string name="Hash6">No sabemos en qué número de caja contiene la información de Ally en la Formación.</string>
    <string name="Hash60">Cuando el tamaño de una Formación usada por una tabla hash es demasiado pequeño, existen más casos donde se sobrelapan los valores hash, haciendo más prevalentes las listas.</string>
    <string name="Hash61">Al contrario, si el tamaño de la formación es demasiado grande, existirán muchas cajas en la formación sin usar, desperdiciando memoria. Se requiere pertinencia al definir esto.</string>
    <string name="Hash62">Las tablas hash, con su almacenamiento flexible y rápida búsqueda, son usadas en las formaciones asociativas de los lenguajes de programación.</string>
    <string name="Hash63">Esto concluye la explicación de las Tablas Hash.</string>
    <string name="Hash7">Entonces, necesitamos realizar una búsqueda desde el comienzo. Esta operación se llama \"Búsqueda Lineal\".</string>
    <string name="Hash8">La llave para los datos almacenados en la caja número 0 es Joe, que no corresponde a Ally.</string>
    <string name="Hash9">La caja 1 tampoco fue Ally.</string>
    <string name="HashFunction">Funciones Hash</string>
    <string name="HashFunction0">Una \"Función Hash\" es una función que convierte los datos que le son proporcionados en un valor irregular de longitud fija.</string>
    <string name="HashFunction1">Una función hash puede ser más fácil de entender si la imaginamos como una licuadora.</string>
    <string name="HashFunction10">Veamos algunas de las características de las funciones hash desde esta premisa.</string>
    <string name="HashFunction11">La primera característica es que los valores que arroja la función hash son de longitud fija.</string>
    <string name="HashFunction12">La longitud de dichos valores varía de acuerdo al tipo función hash. En el caso de SHA-1, por ejemplo, los valores hash siempre son de 20 bytes.</string>
    <string name="HashFunction13">Incluso cuando cantidades extremadamente grandes de información son entradas en la función, la longitud del valor hash resultante no cambia.</string>
    <string name="HashFunction16">De la misma manera, incluso cuando se procesan pequeñas cantidades de información, el valor hash permanece igual en longitud.</string>
    <string name="HashFunction19">La segunda característica es que si se ingresa la misma información, el valor hash resultante será replicado nuevamente sin excepción y sin cambio alguno.</string>
    <string name="HashFunction2">Cuando introducimos datos en una función hash,</string>
    <string name="HashFunction25">La tercera característica es que si se ingresa información similar, pero con pequeñas diferencias (incluso de 1 solo bit), el valor hash resultante será ampliamente diferente.</string>
    <string name="HashFunction3">la función nos arroja un valor irregular.</string>
    <string name="HashFunction31">No es verdad que si se entran datos similares los valores hash resultantes también serán similares.</string>
    <string name="HashFunction32">La cuarta característica es que incluso si se ingresa información totalmente diferente en una función hash, es matemáticamente posible que dos valores hash idénticos sean producidos; aunque la probabilidad de esto es minúscula.</string>
    <string name="HashFunction38">Esto se conoce como \"Colisión Hash\".</string>
    <string name="HashFunction39">La quinta característica es que restablecer los valores hash a su constitución original es verdaderamente imposible.</string>
    <string name="HashFunction4">Si imaginamos esta función como una función que licúa y mezcla datos, tal vez sea más fácil de entender.</string>
    <string name="HashFunction41">El flujo de input y output es unidireccional, lo que constituye una enorme diferencia respecto a la \"encriptación\".</string>
    <string name="HashFunction43">Una última característica que vale la pena mencionar es que los cálculos involucrados en una función hash son relativamente sencillos.</string>
    <string name="HashFunction46">Existen varios algoritmos para llevar a cabo funciones hash, pero el más comúnmente usado es \"SHA-2\".</string>
    <string name="HashFunction47">Se puede decir que las funciones hash arrojan un resumen de los datos que procesan, y suelen ser usadas en muchas situaciones y aplicaciones.</string>
    <string name="HashFunction48">Algunos ejemplos del uso de las funciones hash son explicadas en detalle en las secciones \"Códigos de Autenticación de Mensajes\" y \"Tablas Hash\" de esta app.</string>
    <string name="HashFunction49">Esto concluye la explicación de las Funciones Hash.</string>
    <string name="HashFunction5">El valor irregular que arroja la función hash se llama \"hash value\" o \"valor hash\".</string>
    <string name="HashFunction6">Los valores hash son número, pero frecuentemente están expresados en valores hexadecimales.</string>
    <string name="HashFunction7">Un computador maneja todos los datos en binarios, que son unos y ceros (1,0).</string>
    <string name="HashFunction8">Los valores hash también son datos y son procesados en binario.</string>
    <string name="HashFunction9">Lo que la función hash está haciendo en realidad es llevar a cabo ciertos cálculos en el computador.</string>
    <string name="Heap">Montones</string>
    <string name="Heap0">Los \"Montones\" son estructuras de datos ordenados usadas para implementar una \"Cola de Prioridades\".</string>
    <string name="Heap1">Una cola de prioridades es un tipo de estructura de datos.</string>
    <string name="Heap10">Dado que el padre (6) es mayor que el hijo (5), los números se intercambian.</string>
    <string name="Heap11">Esta operación se repite hasta que no existan más intercambios.</string>
    <string name="Heap12">Ahora el padre (1) es menor que el hijo (5), y en consecuencia no hay intercambio.</string>
    <string name="Heap13">La inclusión de un nuevo número en el montón está completada.</string>
    <string name="Heap14">Al extraer un número de un montón, el número de encima es removido.</string>
    <string name="Heap15">En un montón, el valor más bajo es mantenido en la ubicación superior.</string>
    <string name="Heap16">Ya que el número ha sido removido, la estructura del montón necesita ser reorganizada.</string>
    <string name="Heap17">El número al final se mueve al inicio del montón.</string>
    <string name="Heap18">Cuando uno de los hijos es menor que el padre, el menor de los números hijos adyacentes se intercambia con el padre.</string>
    <string name="Heap19">El padre (6) fue mayor que el hijo a la derecha (5), que a su vez fue mayor que el hijo a la izquierda (3), así que el hijo izquierdo y el padre intercambian posiciones.</string>
    <string name="Heap2">En una cola de prioridades, los datos pueden ser agregados en cualquier orden.</string>
    <string name="Heap20">Esta operación se repite hasta que no sucedan más intercambios.</string>
    <string name="Heap22">El hijo a la derecha (8) fue mayor que el padre (6), quien a su vez fue mayor que el hijo a la izquierda (4), así que el hijo a la izquierda intercambio con el padre.</string>
    <string name="Heap23">La extracción del número del montón se considera completada.</string>
    <string name="Heap24">De esta manera los montones pueden ser usados para extraer rápidamente los datos más pequeños.</string>
    <string name="Heap25">Sin embargo, la extracción de un dato ubicado en el medio del árbol no puede realizarse.</string>
    <string name="Heap26">Los montones son usados, por ejemplo, para colas de prioridad y el algoritmo de Dijkstra.</string>
    <string name="Heap27">Esto concluye la explicación de los Montones.</string>
    <string name="Heap3">Al contrario, al extraer los datos, los datos con valores más bajos son elegidos primero.</string>
    <string name="Heap4">Ser capaces de agregar datos libremente y luego extraerlos en orden de los valores más bajos, define una cola de prioridades,</string>
    <string name="Heap5">Ahora, continuemos conociendo la estructura de los montones.</string>
    <string name="Heap6">Como regla para los montones, un número hijo siempre es mayor que su número padre.</string>
    <string name="Heap7">Intentemos agregar un número al montón.</string>
    <string name="Heap8">El número que se ha agregado primero es ubicado en el final de la línea.</string>
    <string name="Heap9">Si el número padre es mayor, el hijo y el padre se intercambian.</string>
    <string name="HeapDescription">Los \"Montones\" son estructuras de datos ordenados usadas para extraer rápidamente los valores más bajos. Podrá estudiar este tema al comprar todos los algoritmos.</string>
    <string name="HeapSort">Ordenado de Montones</string>
    <string name="HeapSort0">El \"Ordenado de Montones\" es un algoritmo usado para ordenar secuencias de números, y particularmente usa la estructura de datos denominada \"Montones\".</string>
    <string name="HeapSort1">Para comenzar, los datos están ordenados en montones. Los Montones están construidos de tal manera que los números están ordenados en orden descendente. Una explicación detallada de esto se encuentra en la sección \"Montones\" de esta app.</string>
    <string name="HeapSort10">Para dar un ejemplo más concreto, los elementos del montón (nodos) y la formación</string>
    <string name="HeapSort105">Además, a pesar de existir métodos más óptimos para construir montones, hemos escogido esta vez un método fácil de entender.</string>
    <string name="HeapSort11">tienen una relación de correspondencia como se muestra en el diagrama.</string>
    <string name="HeapSort15">Como se puede ver, podría decirse que el montón está simplemente \"embutido\" en la formación</string>
    <string name="HeapSort16">Ahora, intentemos ordenar la formación usando el método de intercambiar los números.</string>
    <string name="HeapSort17">Para un mejor entendimiento, mantendremos visible la estructura del montón.</string>
    <string name="HeapSort18">Igual que antes, comenzaremos guardando los números en un montón.</string>
    <string name="HeapSort20">De la misma manera en que los números se intercambian en la estructura de árbol del montón, también lo hacen los números correspondientes en la formación.</string>
    <string name="HeapSort21">Todos los números están completamente ordenados. Al mismo tiempo pudimos ordenar la formación en una estructura de montón descendiente.</string>
    <string name="HeapSort22">Luego, los números guardados en el montón son sacados uno por uno</string>
    <string name="HeapSort23">Los datos de los montones descendentes son removidos en orden, comenzando por los valores más grandes.</string>
    <string name="HeapSort24">El primer número de la formación es el más grande del montón.</string>
    <string name="HeapSort25">El primer número del montón es intercambiado con el número que corresponde al último elemento del montón, completando la operación.</string>
    <string name="HeapSort26">El montón es reorganizado de tal manera que mantenga su estructura.</string>
    <string name="HeapSort27">Esta operación se repite hasta que todos los números han sido ordenados correctamente.</string>
    <string name="HeapSort28">El ordenado está completo.</string>
    <string name="HeapSort29">Esto concluye la explicación del Ordenado de Montones.</string>
    <string name="HeapSort3">Todos los números han sido guardados en un montón</string>
    <string name="HeapSort4">Luego, los números guardados en el montón son sacados uno por uno</string>
    <string name="HeapSort5">Una propiedad de los montones descendentes es que los números son removidos del mayor al menor, así que si se organizan en el mismo orden que son removidos, el orden ya está dado y completo.</string>
    <string name="HeapSort7">Una vez todos los número han sido removidos del montón, el ordenado está completo.</string>
    <string name="HeapSort8">A pesar de preparar una estructura de datos extra aparte de la secuencia de números en esta ocasión...</string>
    <string name="HeapSort9">...normalmente, el montón es incorporado en la misma formación conteniendo los números, y el ordenado es llevado a cabo simplemente intercambiando los números. Al contrario.</string>
    <string name="Huffman">Codificación Huffman</string>
    <string name="Huffman0">La \"Codificación Huffman\" es un algoritmo de codificación de datos.</string>
    <string name="Huffman1">Se usa para cosas como la compresión de imágenes y datos en formatos JPEG y ZIP.</string>
    <string name="Huffman10">Como un ejemplo simple, llegamos a una regla de codificación en el diagrama. Un carácter es expresado con 2 bits.</string>
    <string name="Huffman100">La misma operación se realiza con \"C ó D\", esta vez considerándolo como un único carácter.</string>
    <string name="Huffman101">Dos caracteres son encontrados en el orden menor de frecuencia, de los restantes que son \"A\", \"B\" y \"C ó D\".</string>
    <string name="Huffman102" formatted="false">Esta vez, los dos con menor frecuencia son \"A\" (35%) y \"B\" (25%)</string>
    <string name="Huffman103">Ambos caracteres son conectados con una línea para crear una estructura de árbol.</string>
    <string name="Huffman104">Los dos caracteres son combinados en \"A ó B\", y sus frecuencias son agregadas.</string>
    <string name="Huffman105">\"A ó B\" es considerado como un solo carácter.</string>
    <string name="Huffman106">En la misma manera, los dos únicos caracteres restantes son elegidos, aún siendo los últimos restantes: \"A ó B\" y \"C ó D\".</string>
    <string name="Huffman107">Ambos caracteres son conectados con una línea para crear una estructura de árbol.</string>
    <string name="Huffman108">Todos los caracteres originales ahora conforman uno solo, \"A ó B ó C ó D\", con una frecuencia de aparición de 100%.</string>
    <string name="Huffman109">La estructura que facilita la codificación Huffmann ahora está completa.</string>
    <string name="Huffman11">Al codificar \"ABAABACD\" según nuestras reglas, resulta una nueva cadena de 16 bits, que es una reducción considerable.</string>
    <string name="Huffman110">La frecuencia de cada carácter se despliega de nuevo.</string>
    <string name="Huffman111">Códigos de \"0\" y \"1\" son asignados extendiéndose hacia arriba y hacia abajo a lo largo de todas las ramas.</string>
    <string name="Huffman112">Luego, el árbol es invertido desde sus raíces a cada carácter, asignándose un código correspondiente a cada uno.</string>
    <string name="Huffman113">En el caso de \"A\", el código que le es asignado es \"00\".</string>
    <string name="Huffman114">En el caso de \"B\", el código que le es asignado es \"01\".</string>
    <string name="Huffman115">En el caso de \"C\", el código que le es asignado es \"10\".</string>
    <string name="Huffman116">En el caso de \"D\", el código que le es asignado es \"11\".</string>
    <string name="Huffman117">Ahora la codificación Huffman está completa.</string>
    <string name="Huffman118">La estructura de este árbol es diferente de la del ejemplo anterior ya que no hay diferencias sustanciales en las frecuencias de aparición de los caracteres. Todos los caracteres en este caso han sido codificados con 2 bits.</string>
    <string name="Huffman119">Por ejemplo, incluso si intentamos expresar \"C\"y \"D\" con 3 bits para expresar la mayor frecuencia de aparición de estos caracteres, \"A\" con un bit...</string>
    <string name="Huffman12">Por supuesto, ya que son reglas que nosotros mismos inventamos, necesitaremos comunicar esas reglas de codificación para que quien reciba la información pueda decodificarla.</string>
    <string name="Huffman120" formatted="false">dado que la frecuencia de \"C ó D\" de 40% es más alta que la de \"A\" (35%) el resultado de la codificación sería peor que la que realizamos con 2 bits.</string>
    <string name="Huffman121">Es evidente ahora que la codificación Huffman es capaz de lograr codificación simple y eficiente basándose en la frecuencia de aparición de los caracteres a ser codificados.</string>
    <string name="Huffman122">Esto concluye la explicación de la Codificación Huffman.</string>
    <string name="Huffman13">Por conveniencia, en esta explicación ignoraremos qué tanto tráfico en red tomaría comunicar dicha regla para decodificar la información.</string>
    <string name="Huffman14">Para que el receptor decodifique la cadena de caracteres...</string>
    <string name="Huffman15">si divide la cadena en segmentos de dos caracteres,</string>
    <string name="Huffman16">y decodifica cada segmento comparándolo con las reglas, es posible extraer y decodificar la cadena original \"ABAABACD\".</string>
    <string name="Huffman17">Ahora consideremos codificar la cadena \"ABAABACD\" incluso más pequeña.</string>
    <string name="Huffman18">Con las reglas anteriores expresamos cada carácter con 2 bits...</string>
    <string name="Huffman19">Pero parece que al expresar \"A\" y \"B\" con 1 bit, podemos codificar la cadena aún más pequeña.</string>
    <string name="Huffman2">Por ejemplo, imaginemos que queremos enviar la cadena de caracteres \"ABAABACD\" por una red.</string>
    <string name="Huffman20">Además, en la cadena \"ABAABACD\" los caracteres \"A\" y \"B\" son usados más veces que \"C\" y \"D\".</string>
    <string name="Huffman21">Entonces, es evidente que sería mejor expresar \"A\" y \"B\" con un dígito en lugar de \"C\" y \"D\".</string>
    <string name="Huffman22">Tratamos de codificar \"ABAABACD\" de acuerdo a nuestras reglas. El resultado es un conjunto de datos de 10 bits, que es aún una mejor reducción.</string>
    <string name="Huffman23">Para que sea posible decodificar el mensaje por parte del receptor,</string>
    <string name="Huffman24">cada carácter debe ser comparado con la regla de conversión para ser decodificado.</string>
    <string name="Huffman25">pero el código \"10\" podría al mismo tiempo significar \"BA\" o \"C\".</string>
    <string name="Huffman26">Debido a esto, un carácter diferente fue extraído</string>
    <string name="Huffman27">Existen varias cadenas de caracteres diferentes que pueden ser extraídas de esta manera, y el mensaje original no puede ser extraído correctamente.</string>
    <string name="Huffman28">Cuando un mensaje original no puede ser decodificado sin ambigüedades, se llama un \"Mensaje Ambiguo\" o \"no decodificable únicamente\".</string>
    <string name="Huffman29">Consideremos otro ejemplo. Por conveniencia, asumamos que los dos caracteres \"A\" y \"B\" serán codificados como en el diagrama.</string>
    <string name="Huffman3">Los datos serán codificados en binario como ceros (0) y unos (1).</string>
    <string name="Huffman30">Ahora consideremos los pasos para decodificar \"000001\" según las reglas de codificación.</string>
    <string name="Huffman31">Cuando decodificamos, revisamos los números en orden desde el comienzo.</string>
    <string name="Huffman32">El primer número es \"0\", pero no podemos determinar si ese número representa \"A\" o si hace parte de una \"B\".</string>
    <string name="Huffman33">Los dos primeros números son \"00\", pero no podemos determinar si representan \"AA\" o si son parte de una \"B\".</string>
    <string name="Huffman34">Los dos primeros números son \"000\", pero no podemos determinar si representan \"AAA\" o si son parte de una \"B\".</string>
    <string name="Huffman35">De igual manera, no podemos determinar si los primeros 4 números...</string>
    <string name="Huffman36">ni los 5 primeros números...</string>
    <string name="Huffman37">Finalmente, vemos el sexto número, \"1\", y determinamos que el primer \"0\" es una \"A\", y que el \"00001\" que le sigue es una \"B\".</string>
    <string name="Huffman38">Podemos decodificar sin ambigüedad los números \"000001\" en la cadena \"AB\". A este punto no hay problemas.</string>
    <string name="Huffman39">Los códigos en una tabla de conversión cuyos caracteres originales pueden ser determinados tan pronto como aparecen son denominados \"códigos instantáneos\".</string>
    <string name="Huffman4">Por ejemplo, en el código ASCII de caracteres, los caracteres \"A\", \"B\", \"C\" y \"D\" son codificados como se muestra en el diagrama.</string>
    <string name="Huffman40">Pero en este ejemplo, aquellos cuyos caracteres originales no pueden ser determinados sin revisar los caracteres siguientes son códigos no instantáneos.</string>
    <string name="Huffman41">Por lo tanto, decodificarlos toma tiempo.</string>
    <string name="Huffman42">Por el bien de la codificación y decodificación eficientes, los códigos que son decodificables sin ambigüedades e instantáneamente son preferidos.</string>
    <string name="Huffman43">Ahora consideremos donde los problemas yacen en las 2 reglas de codificación usadas como ejemplos para los diagramas.</string>
    <string name="Huffman44">Si tratamos de visualizar el primer conjunto de reglas de codificación...</string>
    <string name="Huffman45">si el primer carácter que se nos da es \"0\" entonces determinamos que es una \"A\".</string>
    <string name="Huffman46">Sin embargo, si se trata de un \"1\", podría ser una \"B\" o parte de \"C\" o \"D\".</string>
    <string name="Huffman47">Ahora tratemos de visualizar el segundo conjunto de reglas en la misma forma.</string>
    <string name="Huffman48">Dado cualquier código, el primer carácter puede ser sólo \"0\".</string>
    <string name="Huffman49">Sin embargo, ese \"0\" puede ser parte de \"A\" o de \"B\".</string>
    <string name="Huffman5">En ASCII cada carácter es expresado con 8 bits.</string>
    <string name="Huffman50">Para garantizar que algo sea únicamente decodificable, sin ambigüedad e instantáneamente, debe existir la condición de que \"ningún código puede ser la parte inicial de otro\".</string>
    <string name="Huffman51">Los ejemplos previos no cumplían con dicha condición.</string>
    <string name="Huffman52">La codificación Huffman es un algoritmo que nos permite fácilmente llegar a códigos decodificables instantáneamente y sin ambigüedades.</string>
    <string name="Huffman53">Revisemos algo de la verdadera codificación Huffman.</string>
    <string name="Huffman54">La codificación Huffman produce códigos decodificables instantáneamente y sin ambigüedades.</string>
    <string name="Huffman55">Primero, la frecuencia de aparición de cada carácter es calculada. Las frecuencias para la cadena \"ABAABACD\" aparecen en el diagrama.</string>
    <string name="Huffman56">Luego, los caracteres son organizados en orden de mayor frecuencia. En este ejemplo, el orden de mayor frecuencia es \"ABCD\".</string>
    <string name="Huffman57">Luego, dos caracteres se encuentran en el menor orden de frecuencia.</string>
    <string name="Huffman58">En este caso son \"C\" y \"D\" con 12.5% cada uno.</string>
    <string name="Huffman59">Los dos caracteres se conectan con una línea, para crear una estructura de árbol.</string>
    <string name="Huffman6">Usando ASCII, codificamos la cadena de caracteres\"ABAABACD\" y el resultado es una cadena de 64 bits de tamaño.</string>
    <string name="Huffman60">Los dos caracteres se combinan en \"C ó D\", y sus frecuencias son sumadas.</string>
    <string name="Huffman61">La misma operación se realiza, esta vez teniendo en cuenta a \"C ó D\" como un solo carácter.</string>
    <string name="Huffman62">Dos de los tres caracteres se encuentran ahora en el orden inferior de frecuencia.</string>
    <string name="Huffman63" formatted="false">Esta vez, son \"B\" (25%) y \"C ó D\" (25%)</string>
    <string name="Huffman64">Los dos caracteres son conectados con una línea para crear una estructura de árbol.</string>
    <string name="Huffman65">Y se combinan para crear el nuevo carácter \"B ó C ó D\", y sus frecuencias son sumadas.</string>
    <string name="Huffman66">\"B ó C ó D\" será considerado como un solo carácter.</string>
    <string name="Huffman67">De igual manera, los dos caracteres restantes son elegidos como los últimos restantes.</string>
    <string name="Huffman68">Estos dos caracteres restantes se unen como antes, para crear una estructura de árbol.</string>
    <string name="Huffman69">Todos los caracteres conforman ahora uno solo: \"A ó B ó C ó D\" y su frecuencia, por supuesto, es de 100%.</string>
    <string name="Huffman7">Para minimizar el tráfico en la red, consideramos codificar esa cadena de 64 bits, llegando a algo más compacto.</string>
    <string name="Huffman70">Ahora la estructura que facilita la codificación Huffman está completa.</string>
    <string name="Huffman71">La frecuencia de cada carácter se despliega de nuevo.</string>
    <string name="Huffman72">Ahora, continuaremos con la codificación usando ceros y unos (0 y 1).</string>
    <string name="Huffman73">Los códigos \"0\" y \"1\" se asignan a las ramas extendiéndose hacia arriba y abajo.</string>
    <string name="Huffman74">No importa si la asignación de ceros y unos se hace en el orden contrario. Sin embargo, si se decide que las ramas superiores serán \"1\", ya no se puede cambiar a medio camino hacia las ramas inferiores.</string>
    <string name="Huffman75">Todos los códigos se han asignado.</string>
    <string name="Huffman76">Luego, el árbol es invertido desde sus raíces a cada carácter, asignándose un código correspondiente a cada uno.</string>
    <string name="Huffman77">En el caso de \"A\"...</string>
    <string name="Huffman78">El código asignado es \"0\".</string>
    <string name="Huffman79">En el caso de \"B\"...</string>
    <string name="Huffman8">Para distinguir y manejar grandes cantidades de caracteres, ASCII expresa un carácter con 8 bits.</string>
    <string name="Huffman80">El código asignado es \"10\".</string>
    <string name="Huffman81">En el caso de \"C\"...</string>
    <string name="Huffman82">El código asignado es \"110\".</string>
    <string name="Huffman83">En el caso de \"D\"...</string>
    <string name="Huffman84">El código asignado es \"111\".</string>
    <string name="Huffman85">El proceso de codificación Huffman está completo.</string>
    <string name="Huffman86">Esto significa que la cadena de caracteres \"ABAABACD\" debe ser codificada usando estas reglas.</string>
    <string name="Huffman87">Desde esta estructura resulta evidente que se cumple la regla de \"ningún código será parte del comienzo de otro\"</string>
    <string name="Huffman88">Así, este código es decodificable instantáneamente y sin ambigüedades.</string>
    <string name="Huffman89">También, al ser asignados los códigos con menor número de bits a los caracteres que aparecen con mayor frecuencia, vemos que es una codificación eficiente.</string>
    <string name="Huffman9">Sin embargo, sólo 4 caracteres están siendo usados en la cadena de caracteres \"ABAABACD\". Al parecer podemos codificar esos 4 caracteres en una manera inteligible.</string>
    <string name="Huffman90">Para ser concretos, en este ejemplo vemos que \"C ó D\" tiene una frecuencia menor que \"A\", que aparece 50% de las veces.</string>
    <string name="Huffman91">Por lo tanto, incluso si \"C ó D\" se expresa con 3 bits, expresar \"A\" con uno sólo es mucho más eficiente, lo cual se refleja en los resultados.</string>
    <string name="Huffman92">Intentemos codificar \"ABAABACD\" usando las reglas obtenidas.</string>
    <string name="Huffman93">El resultado es de 14 bits, que es incluso más pequeño que al expresar el código sobre caracteres de 2 bits.</string>
    <string name="Huffman94">Intentemos revisar otro ejemplo. Esta vez, no habrá mayor diferencia entre los caracteres en cuanto a la frecuencia de aparición.</string>
    <string name="Huffman95">Por conveniencia, en este caso la frecuencia de aparición corresponde al orden de la cadena de caracteres. Por lo tanto, no hay necesidad de reordenarlos.</string>
    <string name="Huffman96">Luego, dos caracteres con las frecuencias más bajas son encontrados.</string>
    <string name="Huffman97" formatted="false">En este caso son \"C\" (22%) y \"D\" (18%).</string>
    <string name="Huffman98">Ambos caracteres son conectados con una línea para crear una estructura de árbol.</string>
    <string name="Huffman99">Los dos caracteres son combinados en \"C ó D\", y sus frecuencias son agregadas.</string>
    <string name="HuffmanDescription">El \"Huffman Coding\" es un algoritmo usado en formatos de archivo como JPEG y ZIP. Podrá estudiar este tema al comprar todos los algoritmos.</string>
    <string name="HybridEncoding">Sistema Criptográfico Híbrido</string>
    <string name="HybridEncoding0">Existe el problema de la entrega de la llave y cómo intercambiarla de manera segura al usar el Sistema Criptográfico de Llave Compartida.</string>
    <string name="HybridEncoding1">Por otro lado, el sistema criptográfico de llave pública tiene el problema del procesamiento lento durante la encriptación y decriptación de los datos.</string>
    <string name="HybridEncoding10">Al encriptar la llave usando el sistema criptográfico de llave pública, puede ser enviada de manera segura a B.</string>
    <string name="HybridEncoding11">El agente B, quien recibirá la información, crea una llave pública y una llave secreta,</string>
    <string name="HybridEncoding12">La llave pública es enviada a A.</string>
    <string name="HybridEncoding13">El agente A usa la llave pública proporcionada por B,</string>
    <string name="HybridEncoding14">y encripta la llave compartida que usó para encriptar sus propios datos, aquellos que desea enviar a B.</string>
    <string name="HybridEncoding15">La llave compartida, ahora encriptada, es enviada a B.</string>
    <string name="HybridEncoding16">El agente B usa su propia llave secreta,</string>
    <string name="HybridEncoding17">y desencripta el texto cifrado que contiene la llave para luego usarla para desencriptar el mensaje original de A.</string>
    <string name="HybridEncoding18">De esta manera, A pudo enviar de forma segura la llave compartida usada para encriptar su información, gracias al sistema de llave pública usado por B.</string>
    <string name="HybridEncoding19">Lo único que falta ahora es enviar esta llave compartida de A para encriptar los datos.</string>
    <string name="HybridEncoding2">El \"Sistema Criptográfico Híbrido\" es un sistema que combina ambas aproximaciones para sobreponerse a cada uno de sus inconvenientes.</string>
    <string name="HybridEncoding20">El sistema criptográfico de llave compartida es más rápido para encriptar información.</string>
    <string name="HybridEncoding21">Ahora B pudo obtener el mensaje original si ningún problema.</string>
    <string name="HybridEncoding22">De esta forma, el sistema criptográfico híbrido combina tanto seguridad como velocidad de procesamiento.</string>
    <string name="HybridEncoding23">Tal como es usado en SSL, que permite la transferencia de datos de forma segura vía internet, es un sistema criptográfico sin el que podríamos vivir.</string>
    <string name="HybridEncoding24">Esto concluye la explicación del Sistema Criptográfico Híbrido</string>
    <string name="HybridEncoding3">Utiliza un sistema de llave compartida que procesa la encriptación rápidamente.</string>
    <string name="HybridEncoding4">Sin embargo, la llave compartida es intercambiada usando el sistema de llave pública, que ofrece mayor seguridad.</string>
    <string name="HybridEncoding5">Revisemos en concreto el sistema criptográfico de llave compartida en acción.</string>
    <string name="HybridEncoding6">Digamos que el Agente A quiere enviar información al Agente B vía internet.</string>
    <string name="HybridEncoding7">Los datos son encriptados con el procesamiento rápido del sistema criptográfico de llave compartida.</string>
    <string name="HybridEncoding8">Dado que la llave usada para la encriptación también es necesaria para la desencriptación de los datos, A necesita enviarle la llave a B.</string>
    <string name="HybridEncoding9">La llave en sí misma también es información.</string>
    <string name="HybridEncodingDescription">El \"Criptosistema Híbrido\" es un método que combina los métodos crípticos de \"clave compartida\" y de \"clave pública\". Podrá estudiar este tema al comprar todos los algoritmos.</string>
    <string name="IABSetUpFailed">La conexión con Google Play ha fallado. Asegúrese de estar conectado con su cuenta de Google Play.</string>
    <string name="Inquiry">Comentarios y retroalimentación</string>
    <string name="InquiryConfirmation">Confirmar</string>
    <string name="InquiryEmail">Dirección de correo electrónico</string>
    <string name="InquiryFailed">Ocurrió un error al enviar sus comentarios. Por favor espere un poco e intente de nuevo.</string>
    <string name="InquiryIsSendOK">¿Enviar comentarios?</string>
    <string name="InquiryName">Nombre</string>
    <string name="InquiryOptional">(Opcional)</string>
    <string name="InquiryPleaseInput">Por favor, deje su mensaje en el recuadro de comentarios.</string>
    <string name="InquiryPleaseSmall">Por favor, escriba su mensaje en 1000 caracteres o menos.</string>
    <string name="InquirySend">Enviar</string>
    <string name="InquirySuccess">Muchas gracias por sus comentarios, serán tomados en cuenta para las apps futuras</string>
    <string name="InquirySuccessTitle">Comentarios enviados</string>
    <string name="InsertionSort">Ordenado por Inserción</string>
    <string name="InsertionSort0">El \"Ordenado por Inserción\" es un algoritmo usado para ordenar una secuencia de números</string>
    <string name="InsertionSort1">Inicialmente, el número del extremo izquierdo es considerado como ya ordenado.</string>
    <string name="InsertionSort10">y es comparado con el número a su izquierda.</string>
    <string name="InsertionSort11">5 es mayor que 4, así que los número se intercambian.</string>
    <string name="InsertionSort12">3 es menor que 4, y esto significa que un número menor (menor a 4) ha aparecido, así que 4 deja de moverse.</string>
    <string name="InsertionSort13">Ahora 4 se considera completamente ordenado.</string>
    <string name="InsertionSort14">La misma operación es repetida hasta que todos los números han sido ordenados completamente.</string>
    <string name="InsertionSort18">Ahora todos los números están ordenados.</string>
    <string name="InsertionSort19">Esto concluye la explicación del Ordenado por Inserción.</string>
    <string name="InsertionSort2">Luego, el número del extremo izquierdo es removido...</string>
    <string name="InsertionSort3">y es comparado con el número a su izquierda.</string>
    <string name="InsertionSort4">Si el número inicial que fue considerado como ya ordenado es mayor, ambos números son intercambiados.</string>
    <string name="InsertionSort5">Esta operación se repite hasta que un número menor aparezca, o el número alcance el extremo izquierdo.</string>
    <string name="InsertionSort6">En este caso, 5 es mayor que 3, así que los números se intercambian.</string>
    <string name="InsertionSort7">El número ha alcanzado el extremo izquierdo, así que deja de moverse.</string>
    <string name="InsertionSort8">3 ahora se considera completamente ordenado.</string>
    <string name="InsertionSort9">Igual que antes, el número a la izquierda de los números restantes es removido</string>
    <string name="KmeansClustering">Algoritmo de k-medias</string>
    <string name="KmeansClustering0">El algoritmo de \"k-medias\" es un tipo de algoritmo usado para agrupación (o clustering) de grafos.</string>
    <string name="KmeansClustering1">La agrupación o clustering, es una operación de, dado un conjunto de datos...</string>
    <string name="KmeansClustering10">El punto central de los 3 clústeres son ubicados en puntos aleatorios.</string>
    <string name="KmeansClustering100">Las distancias más cortas hasta los puntos centrales de los clústeres es calculada de nuevo, y los datos puntuales son reagrupados de nuevo en los clústeres.</string>
    <string name="KmeansClustering101">En la agrupación o clustering, cada grupo se llama \"clúster\".</string>
    <string name="KmeansClustering11">Desde cada punto, calculamos la distancia al clúster más cercano.</string>
    <string name="KmeansClustering12">Cada dato puntual es agrupado en uno de los tres clústeres predeterminados.</string>
    <string name="KmeansClustering13">La media de los datos en cada clúster es calculada, y el punto central del clúster es movido al punto que indica esa media.</string>
    <string name="KmeansClustering14">Dada la reubicación de los puntos centrales de los clústeres, es posible que clúster más cercano a algunos de los datos puntuales cambie, haciendo que ahora posiblemente \"pertenezcan\" a otro clúster distinto.</string>
    <string name="KmeansClustering15">Este proceso de asignar los datos puntuales al punto central del clúster, y de mover los puntos centrales de los clústeres, es repetido hasta que los puntos centrales de los clústeres convergen. Es decir, hasta que los clústeres ya no se reubican más.</string>
    <string name="KmeansClustering2">clasifica información similar en grupos.</string>
    <string name="KmeansClustering26">La convergencia de los puntos centrales de los clústeres a sido alcanzada, y la operación termina.</string>
    <string name="KmeansClustering27">Se ha demostrado matemáticamente que, al repetir esta operación, el punto central de los clústeres convergerán eventualmente en algún lugar.</string>
    <string name="KmeansClustering28">El clustering se ha completado.</string>
    <string name="KmeansClustering29">Se puede observar que los datos puntuales han sido agrupados aproximadamente con puntos similares en su ubicación.</string>
    <string name="KmeansClustering3">La base para determinar la similaridad de los datos depende de cada algoritmo, por ejemplo, aspectos como la distancia entre los puntos, sus coordenadas, etc.</string>
    <string name="KmeansClustering30">Ahora intentemos correr el algoritmo de k-medias sobre los mismos datos, pero esta vez con 2 clústeres.</string>
    <string name="KmeansClustering31">Ubicamos los puntos centrales de los clústeres aleatoriamente.</string>
    <string name="KmeansClustering32">y repetimos el proceso de asignar cada dato puntual al clúster más cercano, y reubicando el clúster hasta que la convergencia se logra. Es decir, hasta que los clústeres ya no se mueven.</string>
    <string name="KmeansClustering4">El algoritmo de k-medias usa la distancia desde el centro de cada clúster para clasificar los datos.</string>
    <string name="KmeansClustering43">La convergencia ha sido lograda.</string>
    <string name="KmeansClustering44">Esta vez, 2 grupos de datos, el izquierdo y el inferior, han sido reagrupados en un solo clúster.</string>
    <string name="KmeansClustering45">Como se puede ver, debido a que el número de clústeres debe ser definido antes de ejecutar el algoritmo, los resultados pueden ser insatisfactorios si el número de clústeres no es definido apropiadamente.</string>
    <string name="KmeansClustering46">Hay varias maneras de decidir apropiadamente sobre el número de clústeres: analizar y visualizar los datos con anterioridad, o correr el algoritmo múltiples veces cada vez con un número de clústeres diferente.</string>
    <string name="KmeansClustering47">Ahora, intentaremos correr el algoritmo de k-medias una vez más, usando los mismos datos pero con posiciones iniciales de los clústeres diferentes a las anteriores. (recordemos que son definidas aleatoriamente).</string>
    <string name="KmeansClustering48">Una vez más, se repite el proceso asignando cada dato puntual al clúster más cercano y moviendo el clúster al punto indicado por la media, hasta alcanzar la convergencia de los puntos centrales del clúster.</string>
    <string name="KmeansClustering5">Ahora, revisemos el algoritmo en acción.</string>
    <string name="KmeansClustering58">La convergencia ha sido lograda.</string>
    <string name="KmeansClustering59">En contraste con los resultados anteriores, los grupos superior e inferior han sido reagrupados en un solo clúster.</string>
    <string name="KmeansClustering6">Primero, se preparan los datos para su agrupación o clustering. A partir de ahora, lo llamaremos simplemente clustering.</string>
    <string name="KmeansClustering60">Como se puede observar, los resultados del clustering difieren debido a la ubicación aleatoria de los puntos centrales de los clústeres iniciales. Esto es algo característico del algoritmo de k-medias.</string>
    <string name="KmeansClustering61">Esto concluye la explicación del Algoritmo de k-medias.</string>
    <string name="KmeansClustering7">Luego, decidimos sobre el número de clústeres.</string>
    <string name="KmeansClustering8">Una característica del algoritmo de k-medias es que debemos decidir sobre el número de clústeres antes de ejecutar el algoritmo.</string>
    <string name="KmeansClustering9">En esta ocasión usaremos 3 clústeres.</string>
    <string name="KmeansClusteringDescription">El algoritmo de \"K-Medias\" es simple pero es ampliamente usado como método de análisis de datos. Podrá estudiar este tema al comprar todos los algoritmos.</string>
    <string name="LangColon">Idioma:</string>
    <string name="LetsUnlock">Con su compra podrá estudiar todos los demás temas. ¡Seamos expertos en algoritmos!</string>
    <string name="LinearSearch">Búsqueda Lineal</string>
    <string name="LinearSearch0">La \"Búsqueda Lineal\" es un algoritmo para buscar elementos en una estructura de datos.</string>
    <string name="LinearSearch1">Busquemos el número 6.</string>
    <string name="LinearSearch2">Primero, examinamos el número ubicado en el extremo izquierdo de la estructura</string>
    <string name="LinearSearch3">Comparamos ese número con 6, y si corresponde la búsqueda termina. Si acaso no corresponde, examinamos el número ubicado a su derecha.</string>
    <string name="LinearSearch4">Esta operación se repite hasta encontrar el 6.</string>
    <string name="LinearSearch5">6 ha sido encontrado, la búsqueda termina.</string>
    <string name="LinearSearch6">Como se puede ver, la búsqueda lineal es una técnica simple para hacer comparaciones repetitivas en orden y desde el principio.</string>
    <string name="LinearSearch7">Cuando existen muchos datos, el número de comparaciones se eleva y toma más tiempo.</string>
    <string name="LinearSearch8">Esto concluye la explicación de la Búsqueda Lineal.</string>
    <string name="List">Listas</string>
    <string name="List0">Las \"Listas\" son un tipo de estructura de datos, y pueden almacenar múltiples valores.</string>
    <string name="List1">Son únicas en la forma en que crean pares de datos con \"apuntadores\", que indican la ubicación del siguiente elemento de los datos en la memoria.</string>
    <string name="List12">Esto concluye la explicación de las Listas.</string>
    <string name="List2">En las listas la información es almacenada en distintos lugares no consecutivos de la memoria.</string>
    <string name="List4">Dado que la información es almacenada en distintas ubicaciones, sólo se puede acceder a cada elemento de los datos a través del apuntador que lo precede.</string>
    <string name="List9">La agregación de datos es llevada a cabo simplemente al reemplazar los apuntadores a cualquier lado de la adición.</string>
    <string name="ListSearchSection">Búsqueda en lista</string>
    <string name="MAC">Código de Autenticación de Mensaje</string>
    <string name="MAC0">Los \"Códigos de Autenticación de Mensajes\" son un sistema que implementa dos funciones: detección de autenticación y detección de falsificación.</string>
    <string name="MAC1">Primero, revisemos las situaciones en las cuales los códigos de autenticación son necesarios.</string>
    <string name="MAC10">El texto cifrado es enviado a B,</string>
    <string name="MAC11">quien desencripta el texto cifrado y obtiene el mensaje que contiene el código del producto.</string>
    <string name="MAC12">Aunque no hay problemas en este caso, revisemos lo que pudo haber pasado.</string>
    <string name="MAC13">Recapitulemos al punto donde A envía el texto cifrado a B.</string>
    <string name="MAC14">Digamos que el agente X,</string>
    <string name="MAC15">falsificó el texto cifrado que A deseaba enviar a B en la transmisión.</string>
    <string name="MAC16">B recibe el texto cifrado, pero no tiene ninguna manera de identificar que fue falsificado.</string>
    <string name="MAC17">Cuando B descifra el texto, el mensaje es \"xyz\".</string>
    <string name="MAC18">Creyendo que \"xyz\" es el producto ordenado, B envía el producto incorrecto a A.</string>
    <string name="MAC19">Teniendo en cuenta que la encriptación no es más que un proceso de cómputo de valores, los cálculos de desencriptación pueden ser realizados sobre texto cifrado que ha sido falsificado.</string>
    <string name="MAC2">Para comprar un producto al agente B, el agenta A envía un mensaje que despliega el código del producto \"abc\".</string>
    <string name="MAC20">Si el mensaje cifrado fuese una frase larga, y el mensaje falsificado se tornara en una frase sin sentido, existe una posibilidad de notar la falsificación.</string>
    <string name="MAC21">Sin embargo, con datos sobre los cuales los humanos no tienen mayor entendimiento o sentido, como este caso de un simple código de producto, puede ser difícil identificar tales falsificaciones luego de la desencriptación.</string>
    <string name="MAC22">Se precisan medidas adicionales para detectar la falsificación.</string>
    <string name="MAC23">Si usamos mensajes de autenticación de códigos, pueden detectarse falsificaciones. Revisemos cómo funcionan.</string>
    <string name="MAC24">Regresamos de nuevo al punto donde A envía el texto cifrado a B.</string>
    <string name="MAC25">El agente A crea la llave que será usada para crear un mensaje de autenticación,</string>
    <string name="MAC26">y la envía al agente B usando un método seguro.</string>
    <string name="MAC27">Luego, A crea un valor usando un texto cifrado y la clave</string>
    <string name="MAC28">y el valor \"7f05\" es obtenido.</string>
    <string name="MAC29">Este valor creado al combinar la llave y el texto cifrado es llamado \"código de autenticación de mensaje\".</string>
    <string name="MAC3">El agente A encripta el mensaje.</string>
    <string name="MAC30">Comúnmente abreviado como \"MAC\", será escrito como tal en lo que queda de esta explicación.</string>
    <string name="MAC31">Un MAC puede ser imaginado como algo similar al \"Valor Hash\" de una sola cadena de caracteres compuesta de la llave de encriptación y el texto cifrado.</string>
    <string name="MAC32">Una explicación más detallada acerca de los \"Valores Hash\" está disponible en otra parte de esta app.</string>
    <string name="MAC33">Existe una amplia variedad de maneras de crear MACs como \"HMAC\", \"OMAC\" y \"CMAC\". Actualmente la manera más usada es la \"HMAC\".</string>
    <string name="MAC34">El agente A envía a B el MAC que ha creado, junto con el texto cifrado.</string>
    <string name="MAC35">B recibe el texto cifrado y el MAC.</string>
    <string name="MAC36">Ahora B necesita revisar si el texto cifrado ha sido falsificado o no.</string>
    <string name="MAC37">Tal como A lo hizo, B usa el texto cifrado y la llave o clave para crear un MAC.</string>
    <string name="MAC38">B ha sido capaz de confirmar que el MAC creado por sí mismo coincide con el MAC recibido de A.</string>
    <string name="MAC39">De esta forma B sabe que el texto recibido proveniente de A no ha sido falsificado.</string>
    <string name="MAC4">Digamos que se usa un sistema criptográfico de llave compartida para encriptar la información.</string>
    <string name="MAC40">Lo único que falta es usar el texto cifrado y la llave para desencriptar el mensaje.</string>
    <string name="MAC41">El mensaje contiene el código de producto \"abc\" que A ha ordenado, y ha sido obtenido con éxito.</string>
    <string name="MAC42">Retornemos al punto donde A envía el texto cifrado a B.</string>
    <string name="MAC43">Veamos qué pasa si el agente malicioso X intenta falsificar el mensaje durante la transmisión.</string>
    <string name="MAC44">Digamos que entre el texto cifrado y el MAC que A envía a B,</string>
    <string name="MAC45">el agente X falsifica el texto cifrado.</string>
    <string name="MAC46">Sin embargo, cuando B calcula el MAC por sí mismo,</string>
    <string name="MAC47">identifica que no coincide con el MAC recibido de A.</string>
    <string name="MAC48">Gracias a esto, B sabe que el texto cifrado, el MAC o ambos han sido falsificados.</string>
    <string name="MAC49">En este caso, es mejor descartar el texto cifrado y el MAC y solicitar a A que los envíe nuevamente.</string>
    <string name="MAC5">El agente A pasa esta llave a B usando un método seguro.</string>
    <string name="MAC50">Entonces, ¿es posible que X falsifique el MAC también para que coincida con el texto cifrado falsificado?</string>
    <string name="MAC51">Ya que X no tiene la llave usada para crear el MAC,</string>
    <string name="MAC52">aún si es posible falsificarlo, continúa siendo imposible que coincida con el texto falsificado.</string>
    <string name="MAC53">Como se espera, cuando B intenta recalcular el MAC y no coincide con el texto cifrado falsificado, es claro que algún tipo de falsificación ha ocurrido a lo largo de la transmisión.</string>
    <string name="MAC55">Como puede verse, hacer uso de los mensajes de autenticación o MACs puede prevenir falsificaciones durante la transmisión de la información.</string>
    <string name="MAC56">Sin embargo, existen fallas aún usando mensajes de autenticación.</string>
    <string name="MAC57">Intentemos simplificar el proceso.</string>
    <string name="MAC58">Primero A y B comparten una llave para encriptar el mensaje y calcular el MAC.</string>
    <string name="MAC59">Entonces,</string>
    <string name="MAC6">El método de intercambio usa protocolos tales como el sistema criptográfico de llave pública o el intercambio de llaves Diffie-Hellman.</string>
    <string name="MAC60">De igual forma en que A puede encriptar el mensaje y calcular el MAC,</string>
    <string name="MAC63">B también es capaz de hacer lo mismo.</string>
    <string name="MAC66">En otras palabras, no hay forma de saber quién encriptó y envió el mensaje original, A o B.</string>
    <string name="MAC67">Entonces, si el agente A resulta corrupto,</string>
    <string name="MAC68">una vez el mensaje es enviado, A puede acusar a B de fabricar el mensaje y \"repudiar\" el hecho de que fue A quien lo envió.</string>
    <string name="MAC7">Tanto el Sistema Criptográfico de Llave Pública como el Sistema de Intercambio de Llaves Diffie-Hellman son explicados en detalle en otra parte de esta app.</string>
    <string name="MAC71">Para prevenir este tipo de problema de repudio, es necesario usar las \"Firmas Digitales\" que son explicadas en otra parte de esta app.</string>
    <string name="MAC72">Esto concluye la explicación de los Códigos de Autenticación de Mensajes.</string>
    <string name="MAC8">El agente A usa el sistema de llave compartida y encripta el mensaje.</string>
    <string name="MarkAllAsRead">Marcar todos como \"leídos\"</string>
    <string name="MarkAllAsUnread">Marcar todos como \"no leídos\"</string>
    <string name="MathSection">Matemática</string>
    <string name="MergeSort">Ordenado por Unión</string>
    <string name="MergeSort0">El \"Ordenado por Unión\" es un algoritmo usado para ordenar secuencias de números.</string>
    <string name="MergeSort1">Primero, la secuencia es dividida progresivamente en mitades.</string>
    <string name="MergeSort10">Cuando grupos de múltiples números son combinados, primero se comparan los números.</string>
    <string name="MergeSort11">En el diagrama, primero los números 4 y 3 serán comparados.</string>
    <string name="MergeSort12">4 es mayor que 3, así que 3 es movido.</string>
    <string name="MergeSort13">Las filas restantes tienen su primer número comparado de la misma manera.</string>
    <string name="MergeSort14">4 es menor que 7, así que 4 es movido.</string>
    <string name="MergeSort15">6 es menor que 7, así que 6 es movido.</string>
    <string name="MergeSort16">El 7 restante es movido.</string>
    <string name="MergeSort17">La combinación de grupos es repetida recursivamente hasta que todos los números formen un solo grupo.</string>
    <string name="MergeSort22">La combinación está completa y todos los números han sido ordenados.</string>
    <string name="MergeSort23">Esto concluye la explicación del Ordenado por Unión.</string>
    <string name="MergeSort5">Las divisiones están completas.</string>
    <string name="MergeSort6">Luego, los grupos divididos son combinados.</string>
    <string name="MergeSort7">Al ser combinados, los números de cada grupo son ordenados de menor a mayor tras la combinación.</string>
    <string name="MergeSortDescription">El \"Ordenado por Unión\" es único en la manera en como divide la secuencia de números en grupos más pequeños y luego los ordena. Podrá estudiar este tema al comprar todos los algoritmos.</string>
    <string name="NowBuying">Procesando...</string>
    <string name="OK">OK</string>
    <string name="OthersSection">Otros</string>
    <string name="PKC">Criptosistema de Clave Pública</string>
    <string name="PKC0">El \"Criptosistema de Clave o Llave Compartida\" es un sistema de encriptación que usa diferentes llaves para la encriptación y la desencriptación.</string>
    <string name="PKC1">La clave usada para encriptar es llamada \"clave pública\", y la que se usa para desencriptar se llama \"clave secreta\".</string>
    <string name="PKC10">El texto cifrado es enviado a B.</string>
    <string name="PKC11">El agente B usa la llave secreta y desencripta el texto cifrado recibido de A.</string>
    <string name="PKC12">El agente B ahora ha obtenido la información original.</string>
    <string name="PKC13">Ya que las claves públicas y el texto cifrado son enviadas a través de internet...</string>
    <string name="PKC14">Existe la posibilidad de que sean interceptadas por un agente malicioso X.</string>
    <string name="PKC15">Sin embargo, el texto cifrado no puede ser descifrado usando la llave pública, y X no puede obtener el mensaje original.</string>
    <string name="PKC16">Entonces, contrario a lo que sucede con el sistema criptográfico de llave compartida, el problema de la entrega de la clave no sucede con el sistema de llave pública.</string>
    <string name="PKC17">El sistema de llave o clave pública tiene el mérito de facilitar el intercambio de información entre cualquier número de entidades. Revisemos esto en mayor detalle.</string>
    <string name="PKC18">Digamos que B ha preparado la clave pública y la llave secreta con anticipación.</string>
    <string name="PKC19">Permitir que la llave pública se conozca por otros no representa ningún problema.</string>
    <string name="PKC2">Comparada con el sistema de llave compartida, el sistema de llave pública tiende a tomar más tiempo para encriptar y desencriptar la información.</string>
    <string name="PKC20">Entonces, B difunde y publica su llave pública a través de internet.</string>
    <string name="PKC21">Por el contrario, la llave secreta debe permanecer en estricto control y no debe conocerse por nadie más.</string>
    <string name="PKC22">Digamos que existen múltiples personas o entidades que desean enviar datos al agente B.</string>
    <string name="PKC23">Estas personas pueden obtener la llave pública de B,</string>
    <string name="PKC24">y encriptar sus datos con ella, para luego enviarlos.</string>
    <string name="PKC25">Es posible enviar este texto cifrado a B,</string>
    <string name="PKC26">quien luego usa la llave secreta para desencriptar el mensaje y obtener los datos originales.</string>
    <string name="PKC27">Ahora B ha obtenido el mensaje original.</string>
    <string name="PKC28">Como puede verse, no es necesario preparar una llave específica para cada persona que desee intercambiar información; con la llave pública basta.</string>
    <string name="PKC29">Adicionalmente, ya que el receptor de los datos (el agente B) es el único que tiene acceso a la llave privada, tiene un alto nivel de seguridad.</string>
    <string name="PKC3">Algunos de los métodos de cálculo para la encriptación de llave pública se muestran en el diagrama.</string>
    <string name="PKC30">Sin embargo, existen dos problemas con el sistema criptográfico de llave pública.</string>
    <string name="PKC31">el primer problema es que se necesita más tiempo tanto para la encriptación como el descifrado de la información.</string>
    <string name="PKC32">Debido a esto, no es muy apropiado para intercambiar pequeñas cantidades de datos.</string>
    <string name="PKC33">Existe el \"sistema criptográfico híbrido\", que ofrece una solución a este problema. Este sistema es explicado en detalle en otra parte de esta app.</string>
    <string name="PKC34">El segundo problema del sistema criptográfico de llave pública se refiere a la confiabilidad de la llave pública como tal.</string>
    <string name="PKC35">Regresemos al momento donde hablábamos de que el agente B había creado las llaves pública y secreta.</string>
    <string name="PKC36">Por conveniencia, representaremos la llave pública del agente B con las letras \"PB\" y la llave secreta (también de B) con las letras \"SB\".</string>
    <string name="PKC37">X, quien quiere interceptar los datos que A le envía a B, crea una llave pública \"PX\" y una llave secreta \"SX\".</string>
    <string name="PKC38">Cuando B envía la llave pública \"PB\" a A,</string>
    <string name="PKC39">el agente X reemplaza secretamente la llave pública \"PB\" por la llave \"PX\" creada por sí mismo,</string>
    <string name="PKC4">Hoy, la encriptación RSA es ampliamente usada, y es explicada en detalle en otra parte de esta app.</string>
    <string name="PKC40">y le entrega \"PX\" a A haciéndola pasar por la llave original.</string>
    <string name="PKC41">No existe ninguna forma de demostrar quién ha creado una llave pública.</string>
    <string name="PKC42">Así que A no es capaz de determinar si ha recibido una llave genuina o si ha sido secretamente intercambiada por una falsa.</string>
    <string name="PKC43">El agente A encripta la información con la llave \"PX\".</string>
    <string name="PKC44">Cuando A intenta enviar el texto cifrado a B,</string>
    <string name="PKC45">X intercepta esta información.</string>
    <string name="PKC46">Y dado que el mensaje ha sido encriptado usando la llave \"PX\" creada por X,</string>
    <string name="PKC47">es capaz de descifrar el texto con su propia llave secreta \"SX\".</string>
    <string name="PKC48">Ahora X ha interceptado exitosamente el mensaje que A intentaba enviar a B.</string>
    <string name="PKC49">Luego, X encripta los datos con la llave pública \"PB\" proporcionada libremente por B.</string>
    <string name="PKC5">Revisemos el panorama de cómo se intercambia la información usando un sistema de llave pública.</string>
    <string name="PKC50">El texto cifrado resultante es enviado a B.</string>
    <string name="PKC51">Ya que el texto cifrado fue creado con la llave pública \"PB\" preparada por B, él es capaz de descifrar el mensaje con su propia llave secreta \"SB\".</string>
    <string name="PKC52">Y, puesto que B fue capaz de descifrar el mensaje con su propia llave secreta, ni siquiera puede imaginarse que fue interceptada por alguien más.</string>
    <string name="PKC53">Este método de ataque de intercepción de datos por medio del reemplazo de las llaves públicas se llama \"ataque del hombre en el medio\".</string>
    <string name="PKC54">El problema está ubicado en el hecho que A no puede verificar si la llave pública recibida fue realmente creada por B.</string>
    <string name="PKC55">Para resolver este problema, el sistema de \"Certificados Digitales\" es usado; este sistema será explicado en mayor detalle en otra parte de esta app.</string>
    <string name="PKC56">Esto concluye la explicación del Criptosistema de Clave Pública.</string>
    <string name="PKC6">Digamos que el agente A intenta enviar un mensaje al agente B por Internet.</string>
    <string name="PKC7">Primero, el receptor (B) crea una llave pública y una llave secreta.</string>
    <string name="PKC8">La llave pública es enviada a A.</string>
    <string name="PKC9">A usa la llave pública recibida de B par encriptar sus datos.</string>
    <string name="PageRank">PageRank</string>
    <string name="PageRank0">\"PageRank\" es un algoritmo usado para determinar el orden de los resultados encontrados en un sitio web de búsqueda.</string>
    <string name="PageRank1">La historia de cómo Google se convirtió en una compañía global usando este algoritmo es muy famosa.</string>
    <string name="PageRank10">Daremos a las páginas web que no tienen enlaces apuntando hacia ellas, el valor 1.</string>
    <string name="PageRank100">Si vemos esta actividad desde el espacio de internet, se ve como si el usuario estuviese</string>
    <string name="PageRank101">constantemente teletransportándose a páginas no relacionadas en absoluto, luego de haberse movido un número no especificado de veces a páginas relacionadas.</string>
    <string name="PageRank11">El valor de una página con enlaces apuntando hacia ella es combinado con el valor de las páginas que apuntan hacia ella.</string>
    <string name="PageRank12">Sin embargo, cuando hay enlaces apuntando hacia múltiples páginas,</string>
    <string name="PageRank13">el valor del enlace es distribuido igualmente entre ellas.</string>
    <string name="PageRank14">En la forma de pensar de PageRank, en enlace proveniente de una página altamente enlazada tiene un valor alto.</string>
    <string name="PageRank15">La página en el centro de este diagrama tiene enlaces apuntando desde ella hacia tres páginas independientes, así que su valor es 3.</string>
    <string name="PageRank16">La página en la parte superior tiene un valor alto, pues tiene un enlace apuntando hacia ella proveniente de una página con valor 3.</string>
    <string name="PageRank17">De las seis páginas existentes en el diagrama, se determina que la más importante de todas es la que está ubicada en la parte superior.</string>
    <string name="PageRank18">Este es razonamiento básico detrás de PageRank.</string>
    <string name="PageRank19">Con este método surge un problema cuando los enlaces forman un bucle.</string>
    <string name="PageRank2">Hasta ese entonces, el resultado de la búsqueda estaba determinado al enfocarse en las palabras clave de la búsqueda y en su relación con las frases dentro del sitio web.</string>
    <string name="PageRank20">Si se calcula el valor de cada página en orden...</string>
    <string name="PageRank24">se puede ver que se forma un bucle infinito y los valores de todas las páginas en el bucle aumentan indefinidamente.</string>
    <string name="PageRank25">Este problema cíclico se resuelve usando un método de cálculo llamado \"random surfer model\".</string>
    <string name="PageRank26">Pensemos en cómo ve las páginas web una persona que navega por la red.</string>
    <string name="PageRank27">Digamos que en una ocasión, una persona visita una página web interesante que ha sido discutida en una revista. Comenzando por la página abajo a la izquierda...</string>
    <string name="PageRank28">sigue el enlace hasta moverse a una página diferente..</string>
    <string name="PageRank29">Luego de ver unas cuantas páginas, pierde interés...</string>
    <string name="PageRank3">Con este método, no se tiene en cuenta si acaso el sitio web evaluado contiene información útil o no. Entonces, los resultados de las búsquedas no tenían en realidad una alta precisión.</string>
    <string name="PageRank30">y deja de navegar por el momento.</string>
    <string name="PageRank31">Luego, otro día, esta persona comienza a navegar en otro sitio web completamente diferente que le ha sido recomendado por un amigo.</string>
    <string name="PageRank32">Siguiendo el enlace, se mueve a otra página completamente diferente...</string>
    <string name="PageRank33">y deja de navegar por el momento al perder el interés.</string>
    <string name="PageRank34">La acción se repite sucesivamente, revisando una página web y moviéndose un número de enlaces hacia adelante antes de detenerse.</string>
    <string name="PageRank35">Si definimos esta acción como usuarios aleatorios, llegamos a algo como lo siguiente.</string>
    <string name="PageRank36">La probabilidad 1-α es la probabilidad de que un enlace de entre los que están vinculados a la página actual será escogido.</string>
    <string name="PageRank37">La probabilidad α es la probabilidad de que el usuario aleatorio se teletransportará a otra página.</string>
    <string name="PageRank38">Por ejemplo, en esta explicación haremos que la probabilidad α, que es la probabilidad de tele transportación, sea 15%.</string>
    <string name="PageRank39">Intentemos simular la transición entre páginas de acuerdo a esta definición.</string>
    <string name="PageRank4">PageRank es un algoritmo que calcula el valor de un sitio web por la estructura de enlaces entre páginas. Demos un vistazo con mayor detalle a su funcionamiento hasta donde se realizan los cálculos.</string>
    <string name="PageRank40">Igual que antes, consideraremos lo que pasa cuando se forma un bucle.</string>
    <string name="PageRank41">El número de cada página representa el número de veces que el usuario aleatorio ha visitado esta página.</string>
    <string name="PageRank42">Actualmente, dado que no hemos iniciado la simulación, todos los números son cero.</string>
    <string name="PageRank43">Al correr la simulación de acuerdo a la definición, la diferencia se desarrolla en el número de visitas a cada página.</string>
    <string name="PageRank49">Ahora aceleraremos el paso del tiempo.</string>
    <string name="PageRank5">Digamos que los cuadrados son sitios web, y que las flechas entre ellos representan enlaces que los vinculan.</string>
    <string name="PageRank50">Corrimos la simulación hasta un total de visitas de pagina que alcanzó las 1000 visitas.</string>
    <string name="PageRank51">Expresando los resultados como porcentajes, obtenemos los números del diagrama.</string>
    <string name="PageRank52">Podemos decir que estos valores expresan la probabilidad de que alguien esté viendo la página en algún momento dado.</string>
    <string name="PageRank53">"Usando estos valores como valores de relevancia de páginas web, constituye el método Random Surfer's Model."</string>
    <string name="PageRank54">Como puede verse, al usar este método es posible calcular los valores aun si existen bucles creados por los enlaces.</string>
    <string name="PageRank55">En realidad, métodos de cálculo más prácticos pueden ser usados en lugar de la simulación. Presentaremos uno de ellos ahora.</string>
    <string name="PageRank56">Intentemos calcular el valor de cada página en una red compleja de enlaces, como en este diagrama.</string>
    <string name="PageRank57">Primero, definimos el valor inicial de cada página.</string>
    <string name="PageRank58">Los valores son definidos igualmente de tal forma que su total sea de 1.</string>
    <string name="PageRank59">Luego, encontramos la probabilidad de que un usuario aleatorio (web surfer) esté en cada página luego de moverse una vez.</string>
    <string name="PageRank6">Este diagrama muestra que los tres sitios web de la parte inferior contienen enlaces al sitio web en la parte superior.</string>
    <string name="PageRank60">Expresaremos la probabilidad de estar en A luego de n movimientos como PAn. De igual forma, la probabilidad de estar en B luego de n movimientos es PBn.</string>
    <string name="PageRank61">Por ejemplo, encontremos la probabilidad de que el usuario aleatorio esté en A luego de moverse una vez (PA1).</string>
    <string name="PageRank62">Un escenario para estar en A es que la persona que está en C decida moverse y no tele transportarse...</string>
    <string name="PageRank63">y elija A en lugar de B como su destino.</string>
    <string name="PageRank64">La probabilidad de que alguien esté en C en el estado inicial (cuando cero movimientos han ocurrido) es PC0 (igual a 0.25).</string>
    <string name="PageRank65">Además, la probabilidad de que alguien estando en C elija moverse es 1-α, y la probabilidad de elegir A de entre A o B es de 0.5.</string>
    <string name="PageRank66">Entonces, la probabilidad de moverse de C hasta A es PC0 x (1-α) x 0.5.</string>
    <string name="PageRank67">Otro escenario para estar en A es que el usuario aleatorio que se encuentra en cualquiera de las páginas A-D decida tele transportarse...</string>
    <string name="PageRank68">y elija A como el destino de su tele transportación.</string>
    <string name="PageRank69">La probabilidad de que alguien que está en cualquiera de las páginas A-D decida tele transportarse es α.</string>
    <string name="PageRank7">En el algoritmo PageRank, mientras más enlaces tiene un sitio web apuntando hacia él, mayor se considera su relevancia e importancia.</string>
    <string name="PageRank70">Además, la probabilidad de que A sea elegido como el destino de la tele transportación es de 0.25.</string>
    <string name="PageRank71">Así, la probabilidad de que alguien se teletransporte hacia A es de α x 0.25.</string>
    <string name="PageRank72">De las probabilidades previamente mencionadas, encontramos que la probabilidad de estar en A luego de moverse una vez (PA1) es igual a PC0 x (1-α) x 0.5 + α x 0.25.</string>
    <string name="PageRank73">Haciendo las sustituciones PC0=0.25 y α = 0.15, calculamos que PA1=0.14375.</string>
    <string name="PageRank74">De la misma manera calculamos las probabilidades de estar en B, C y D, y actualizamos los valores.</string>
    <string name="PageRank75">Los resultados están desplegados en el diagrama.</string>
    <string name="PageRank76">Luego, encontramos las probabilidades de que un usuario aleatorio esté en cada página luego de 2 movimientos.</string>
    <string name="PageRank77">Los resultados están desplegados en el diagrama.</string>
    <string name="PageRank78">Repetimos los mismos cálculos, y la probabilidad de que alguien esté en una página dada comienza a aproximarse a un valor fijo.</string>
    <string name="PageRank79">Cuando los valores se han estabilizado lo suficiente, los cálculos se consideran completados.</string>
    <string name="PageRank8">Aquí se determina que el sitio en la parte superior es el más importante.</string>
    <string name="PageRank80">Los valores calculados de esta manera son los valores de cada página.</string>
    <string name="PageRank81">Finalmente, revisaremos si los valores calculados de PageRank coinciden con los valores ponderados que cubrimos al inicio.</string>
    <string name="PageRank82">Usando los mismos métodos que antes, intentaremos calcular los valores para la estructura de enlaces en el diagrama.</string>
    <string name="PageRank83">Debido a que los valores están redondeados, no suman exactamente 1, pero puede verse que el resultado es cercano a los resultados anteriores.</string>
    <string name="PageRank84">Ahora también calcularemos los valores para esta estructura de enlaces.</string>
    <string name="PageRank85">Estos también son cercanos a los resultados previos.</string>
    <string name="PageRank86">De esta manera el sistema PageRank sobrepasa las ponderaciones de enlaces en favor de las probabilidades de que una página sea visitada.</string>
    <string name="PageRank87">En realidad, el orden mostrado por Google Search no es el resultado exclusivamente del algoritmo PageRank</string>
    <string name="PageRank88">Sin embargo, no cambia el hecho de que el algoritmo PageRank es revolucionario en dos aspectos...</string>
    <string name="PageRank89">los cálculos de valores para páginas formando estructuras de enlaces, y la capacidad de realizar los cálculos aún cuando existen bucles en la estructura.</string>
    <string name="PageRank9">En realidad, la importancia de cada sitio web es calculada en un valor numérico. Primero, explicaremos la idea básica detrás de este método de cálculo.</string>
    <string name="PageRank90">Esto concluye la explicación de PageRank.</string>
    <string name="PageRankDescription">El \"PageRank\" es un índice que determina el orden de visualización de resultados de un motor de búsqueda. Podrá estudiar este tema al comprar todos los algoritmos.</string>
    <string name="PrimalityTest">Prueba de Primalidad</string>
    <string name="PrimalityTest0">La \"Prueba de Primalidad\" es un método que determina si un número natural es o no es un número primo.</string>
    <string name="PrimalityTest1">Un primo es un número natural (n > 1) que no tiene otro divisor diferente a 1 o sí mismo.</string>
    <string name="PrimalityTest100">Antes de entrar en la explicación de la prueba de primalidad, explicaremos la operación mod.</string>
    <string name="PrimalityTest101">La operación mod es una operación que encuentra el remanente de una división.</string>
    <string name="PrimalityTest102">Para A mod B, obtendremos C, que es el remanente de dividir A entre B.</string>
    <string name="PrimalityTest103">Veamos ejemplos de la operación usando números concretos.</string>
    <string name="PrimalityTest17">En otras palabras, esto significa que 3599 NO es un número primo.</string>
    <string name="PrimalityTest18">Sin embargo, este método toma más y más tiempo a medida que el número evaluado se vuelve más grande; no es realista usarlo en la práctica.</string>
    <string name="PrimalityTest19">La \"Prueba de Primalidad de Fermat\" es un método para abordar este problema.</string>
    <string name="PrimalityTest2">La encriptación RSA, que es un método de encriptación de datos ampliamente usado, usa números primos muy grandes.</string>
    <string name="PrimalityTest20">La prueba de primalidad de Fermat es denominada un método para determinar primos probabilísticos, y determina si la probabilidad de que un número sea primo es alta o no.</string>
    <string name="PrimalityTest21">Como prerrequisito, veamos la naturaleza de los números primos para entender luego este método.</string>
    <string name="PrimalityTest22">Por ejemplo, pensemos en la naturaleza del número primo 5.</string>
    <string name="PrimalityTest23">El resultado de tomar cada número menor que 5 a la potencia 5 es mostrado en el diagrama.</string>
    <string name="PrimalityTest28">Luego, llevamos a cabo la operación mod en cada número para encontrar el remanente cuando cada número es dividido por 5.</string>
    <string name="PrimalityTest29">Los resultados de los cálculos se muestran en el diagrama.</string>
    <string name="PrimalityTest3">La prueba de primalidad juega un papel crucial en la encriptación RSA.</string>
    <string name="PrimalityTest30">Cuando examinamos los números originales y sus remanentes, encontramos que concuerdan.</string>
    <string name="PrimalityTest31">A partir de esto, al menos para el primo 5, vemos que la fórmula del diagrama funciona.</string>
    <string name="PrimalityTest32">Ahora consideremos en número compuesto 6.</string>
    <string name="PrimalityTest33">Un \"Número Compuesto\" significa un número natural que no es un primo. El número 6 puede ser expresado como 2 x 3, así que no es un número primo.</string>
    <string name="PrimalityTest34">Cuando realizamos los mismos cálculos,</string>
    <string name="PrimalityTest4">Entonces, como un ejemplo, revisemos si el número 3599 es o no es un número primo.</string>
    <string name="PrimalityTest41">vemos que en los casos de 2 y 5 los números originales no concuerdan con sus remanentes.</string>
    <string name="PrimalityTest42">Esto prueba que, como se conjeturaba, la fórmula del diagrama funciona no sólo para 5 sino que también para todos los primos p.</string>
    <string name="PrimalityTest43">Este es llamado \"El Pequeño Teorema de Fermat\".</string>
    <string name="PrimalityTest44">Llamamos \"Prueba de Primalidad de Fermat\" al método de usado para determina si un número es primo o no al satisfacer o no el pequeño teorema de Fermat.</string>
    <string name="PrimalityTest45">Determinemos si el número 113 es primo o no usando la prueba de primalidad de Fermat.</string>
    <string name="PrimalityTest46">Tres números más pequeños que 113 han sido elegidos de manera aleatoria para hacer esta prueba.</string>
    <string name="PrimalityTest47">Luego de tomar estos tres números y elevarlos a la potencia 113, dividimos el resultado de cada uno en 113, y obtenemos el remanente de esas divisiones.</string>
    <string name="PrimalityTest48">En cada caso, en número original es igual su remanente correspondiente.</string>
    <string name="PrimalityTest49">Mientras más números concuerden de esta manera, más alta es la probabilidad de primalidad, o sea que 113 sea en efecto un número primo.</string>
    <string name="PrimalityTest5">Un método posible es dividir 3599 por números mayores a 2, en orden, y ver si el número es divisible por cada uno.</string>
    <string name="PrimalityTest50">Sin embargo, revisar cada número más pequeño que p siempre tomará un largo tiempo.</string>
    <string name="PrimalityTest51">En la práctica, luego de probar varios números y si la probabilidad de primalidad es suficientemente alta, el número es denominado como un primo probable.</string>
    <string name="PrimalityTest52">Por ejemplo, una versión mejorada de la prueba de primalidad de Fermat es la prueba de primalidad de Miller-Rabin, y es usada para determinar números primos en la encriptación RSA.</string>
    <string name="PrimalityTest53">Pero, si al repetir la prueba la probabilidad de que un número no sea primo es inferior a 0.5 a la potencia 80, el número se considera un nuevo número primo.</string>
    <string name="PrimalityTest54">Además, incluso si un número satisface completamente la prueba de primalidad de Fermat, no se demuestra totalmente que es efectivamente un número primo.</string>
    <string name="PrimalityTest55">Si el número probado es un número primo, satisfará completamente la prueba de primalidad de Fermat.</string>
    <string name="PrimalityTest56">Por otro lado, mientras los números compuestos normalmente serán atrapados por la prueba de primalidad de Fermat al ser evaluados,</string>
    <string name="PrimalityTest57">existen números compuestos que, aunque son extremadamente raros, satisfacen también la prueba de primalidad de Fermat de la misma manera en que lo hacen los números primos.</string>
    <string name="PrimalityTest58">Por ejemplo, consideremos el número 561.</string>
    <string name="PrimalityTest59">El número 561 es un compuesto que puede expresarse como 3 x 187, o también como 11 x 51, entre otros, y definitivamente no es un número primo.</string>
    <string name="PrimalityTest6">\"Divisible\" significa que la operación mod, que encuentra el remanente de una división, será igual a cero. (0).</string>
    <string name="PrimalityTest60">Sin embargo 561 satisface la prueba de primalidad de Fermat.</string>
    <string name="PrimalityTest63">Este tipo de números compuestos se conocen como \"Números de Carmichael\" o también como \"Pseudoprimos Absolutos de Fermat\".</string>
    <string name="PrimalityTest64">El diagrama muestra algunos números de Carmichael en orden, comenzando por los más pequeños, y vemos que hay sólo unos cuantos de ellos.</string>
    <string name="PrimalityTest65">Es correcto decir que los números primos satisfacen la prueba de primalidad de Fermat. Sin embargo, no se puede decir que un número es en efecto un número primo por el hecho de satisfacer la prueba de primalidad de Fermat.</string>
    <string name="PrimalityTest66">En el mejor de los casos, la prueba de primalidad de Fermat es un método de determinar la probabilidad de que un número sea primo, y no demuestra formalmente que lo es.</string>
    <string name="PrimalityTest67">Aún así, la prueba de primalidad de Fermat se usa en la mayoría de los casos ya que no existe otro método eficiente para abordar este problema.</string>
    <string name="PrimalityTest68">Esto concluye la explicación de la Prueba de Primalidad.</string>
    <string name="PrimalityTest7">La raíz cuadrada de 3599 es 59.99..., así que calcular la operación mod desde 2 hasta 59 debería ser suficiente.</string>
    <string name="PrimalityTest8">Como resultado de realizar la operación mod, vemos que 3599 es divisible por 59.</string>
    <string name="PrimalityTestDescription">En la sección \"Test de Primalidad\" explicamos el test de primalidad de Fermat: método probabilístico para determinar números primos. Podrá estudiar este tema al comprar todos los algoritmos.</string>
    <string name="Queue">Colas</string>
    <string name="Queue0">Las \"Colas\" son un tipo de estructura de datos.</string>
    <string name="Queue1">Las \"Colas\" también son conocidas como \"Líneas de espera\", y como su nombre lo sugiere, pueden ser imaginadas como un grupo de personas esperando en línea.</string>
    <string name="Queue10">Esto concluye la explicación de las Colas.</string>
    <string name="Queue2">En las colas, una persona que se forme primero tiene una prioridad más alta.</string>
    <string name="Queue3">Al agregar datos en una Cola, los datos son colocados al final.</string>
    <string name="Queue5">Usamos el término \"encolar\" para referirnos a la acción de agregar datos a una cola.</string>
    <string name="Queue6">Al extraer datos de una cola, el elemento que ha estado en cola el mayor tiempo es el que se remueve primero.</string>
    <string name="Queue8">Usamos el término \"decolar\" para referirnos a la acción de extraer datos a una cola.</string>
    <string name="Queue9">Este método de extraer primero los datos agregados más antiguamente se llama \"PEPS\" o \"Primero en Entrar, Primero en Salir\", o también conocido en Inglés como \"FIFO\" o \"First In First Out\".</string>
    <string name="QuickSort">Ordenado Rápido</string>
    <string name="QuickSort0">El \"Ordenado Rápido\" es un algoritmo usado para ordenar secuencias de números.</string>
    <string name="QuickSort1">Una característica del Ordenado Rápido es que involucra menos comparaciones e intercambios que otros algoritmos, por lo que es capaz de ordenar en muchos casos.</string>
    <string name="QuickSort100">Revisemos el algoritmo en funcionamiento.</string>
    <string name="QuickSort101">Un marcador será ubicado en el pivote para fácil referencia.</string>
    <string name="QuickSort102">Luego, un marcador izquierdo será añadido al número ubicado en el extremo izquierdo, y también un marcador derecho será añadido al número ubicado en el extremo derecho.</string>
    <string name="QuickSort103">El algoritmo de Ordenado Rápido usa estos marcadores para ejecutar rondas de operaciones de manera recursiva.</string>
    <string name="QuickSort105">De esta forma, el marcador izquierdo actúa para encontrar números mayores o iguales al pivote, y el marcador derecho encuentra números menores que el pivote.</string>
    <string name="QuickSort106">Al intercambiar números, se pueden recolectar números que son menores que el pivote al lado izquierdo de la secuencia, y números mayores o iguales que el pivote al lado derecho de la secuencia.</string>
    <string name="QuickSort107">Esto completa la primera ronda de operaciones.</string>
    <string name="QuickSort11">4 es menor que 6, así que el marcador deja de moverse.</string>
    <string name="QuickSort12">Cuando ambos marcadores (izquierdo y derecho) se detienen, los números de los marcadores son intercambiados.</string>
    <string name="QuickSort13">Luego del intercambio, el marcador izquierdo continúa moviéndose a la derecha.</string>
    <string name="QuickSort14">Igual que antes, el marcador se mueve hasta encontrar un número mayor o igual que el pivote.</string>
    <string name="QuickSort18">9 es mayor o igual que 6, así que el marcador deja de moverse,</string>
    <string name="QuickSort19">Una vez más, el marcador derecho es movido a la izquierda.</string>
    <string name="QuickSort2">La primera operación se enfoca en la secuencia completa de números.</string>
    <string name="QuickSort21">El movimiento también se detiene cuando el marcador derecho se encuentra con el marcador izquierdo.</string>
    <string name="QuickSort22">Cuando ambos marcadores (izquierdo y derecho) se detienen y están en la misma posición (mismo número), ese número es intercambiado, esta vez con el número pivote.</string>
    <string name="QuickSort23">El número ocupado por ambos marcadores se considera completamente ordenado.</string>
    <string name="QuickSort24">Con una ronda de operaciones...</string>
    <string name="QuickSort25">fuimos capaces de poner números menores que el pivote a su izquierda</string>
    <string name="QuickSort26">y números mayores que el pivote, a su derecha.</string>
    <string name="QuickSort27">Otra ronda de operaciones será ejecutada recursivamente en ambas secuencias creadas por la división.</string>
    <string name="QuickSort28">Luego, las operaciones serán ejecutadas en el lado izquierdo de la división.</string>
    <string name="QuickSort29">Los 3 marcadores son ubicados (pivote, marcador izquierdo, marcador derecho).</string>
    <string name="QuickSort3">Un número es elegido como referencia para el ordenado. Este número es llamado \"pivote\".</string>
    <string name="QuickSort30">La misma operación anterior es ejecutada.</string>
    <string name="QuickSort4">El marcador izquierdo se moverá a la derecha.</string>
    <string name="QuickSort40">La ronda de operaciones es completada...</string>
    <string name="QuickSort41">Y fuimos capaces de dividir la secuencia en números más pequeños que el pivote, a su izquierda,</string>
    <string name="QuickSort42">y números mayores que el pivote, a su derecha.</string>
    <string name="QuickSort43">Otra ronda de operaciones será ejecutada recursivamente.</string>
    <string name="QuickSort44">La operación se llevará a cabo en el lado izquierdo de la división.</string>
    <string name="QuickSort45">Cuando el objetivo de la secuencia sólo contiene un número, se considera completamente ordenada.</string>
    <string name="QuickSort47">Ahora las operaciones se ejecutarán sobre el lado derecho creado en la segunda ronda de operaciones.</string>
    <string name="QuickSort48">Los 3 marcadores son ubicados.</string>
    <string name="QuickSort49">El marcador izquierdo se mueve a la derecha.</string>
    <string name="QuickSort50">Aún cuando el marcador izquierdo se encuentra con el derecho, no se detiene. Esta vez es diferente del marcador derecho en este aspecto.</string>
    <string name="QuickSort51">Cuando el marcador izquierdo alcanza el extremo derecho de la secuencia objetivo, se detiene.</string>
    <string name="QuickSort52">Esto significa que el número pivote es el número mayor en la secuencia.</string>
    <string name="QuickSort53">Luego, el marcador derecho sería movido, pero cuando ha sido sobrepasado por el marcador izquierdo, termina sin moverse.</string>
    <string name="QuickSort54">Cuando el marcador izquierdo alcanza el extremo derecho de la secuencia objetivo, se considera que el pivote está completamente ordenado y la ronda de operaciones termina.</string>
    <string name="QuickSort55">En adelante, la misma operación será repetida hasta ordenar completamente todos los números.</string>
    <string name="QuickSort6">Cuando el marcador izquierdo alcanza un número mayor o igual al pivote, dejará de moverse.</string>
    <string name="QuickSort7">En este caso, 8 es mayor o igual a 6, así que el marcador deja de moverse.</string>
    <string name="QuickSort8">Luego, el marcador derecho se mueve a la izquierda.</string>
    <string name="QuickSort83">Todos los números han sido ordenados completamente.</string>
    <string name="QuickSort84">Esto concluye la explicación del Ordenado Rápido.</string>
    <string name="QuickSort9">Cuando el marcador alcanza un número menor o igual al pivote, deja de moverse.</string>
    <string name="QuickSort99">El pivote normalmente es un número elegido aleatoriamente. Esta vez, por conveniencia, elegiremos el número ubicado en el extremo derecho para ser el pivote.</string>
    <string name="QuickSortDescription">El \"Ordenado rápido\" es único por su bajo número de comparaciones e intercambios. Podrá estudiar este tema al comprar todos los algoritmos.</string>
    <string name="Random">Aleatorio</string>
    <string name="RateThisApp">Calificar esta app</string>
    <string name="RecursionSection">Recursión</string>
    <string name="Restore">Restaurar registro de compra</string>
    <string name="RestoreAlert">El registro de compra se ha confirmado y será restaurado. No se efectuarán cargos ni costos.</string>
    <string name="RestoreBuyingLog">Restaurar registro de compra</string>
    <string name="RestoreSuccessed">Registro de compra restaurado.</string>
    <string name="Reversed">Pocos únicos</string>
    <string name="ReviewConfirmation">Abrir en la App Store</string>
    <string name="ReviewConfirmationAndroid">Abrir en la tienda de Google Play Store</string>
    <string name="RunLength">Codificación Run-Length</string>
    <string name="RunLength0">Intentemos codificar una imagen usando tres colores en una cuadrícula de 5x5.</string>
    <string name="RunLength1">Primero usaremos un método simple.</string>
    <string name="RunLength10">Estas operaciones son llamadas \"compresión\" y \"descompresión\".</string>
    <string name="RunLength11">La codificación Run-Length es muy apropiada para ciertos tipos de datos, pero no muy apropiada para otros.</string>
    <string name="RunLength12">Si miramos de cerca la línea codificada, vemos que en general el número de caracteres ha disminuido,</string>
    <string name="RunLength13">pero las partes que no tienen colores consecutivos de hecho resultaron aumentando en caracteres al codificar con este método.</string>
    <string name="RunLength14">Por ejemplo, si aplicamos la codificación Run-Length a datos como estos, que son bajos en caracteres consecutivos,</string>
    <string name="RunLength15">los datos se duplican y ahora son 50 caracteres.</string>
    <string name="RunLength16">Al contrario, cuando aplicamos la codificación Run-Length sobre datos con continuidad, como estos...</string>
    <string name="RunLength17">Los datos son comprimidos en 10 caracteres. Comparándolo con los 25 caracteres originales, la compresión es significativa.</string>
    <string name="RunLength18">Como se puede ver, dependiendo de los datos a ser procesados, en ocasiones la compresión es efectiva y en ocasiones no lo es.</string>
    <string name="RunLength19">Entonces, se necesitan varias estrategias, tales como usar la codificación Run-Length preferiblemente cuando se trata de datos con caracteres consecutivos.</string>
    <string name="RunLength2">Asignaremos una letra a cada uno de los colores: Y para amarillo, G para verde y B para azul.</string>
    <string name="RunLength20">Por ejemplo, intentemos usar la codificación Run-Length para codificar un fax monocromático.</string>
    <string name="RunLength21">Si usamos simplemente W para blanco y B para negro, para expresar así cada cuadrado al enviar la imagen, el resultado será 25 caracteres.</string>
    <string name="RunLength22">Ya que queremos mantener el volumen de datos a enviar tan bajo como sea posible, intentaremos codificarlo con la codificación Run-Length.</string>
    <string name="RunLength23">El resultado es de 26 caracteres, uno más que antes, así que la codificación aquí fue simplemente inútil.</string>
    <string name="RunLength24">Sin embargo, una imagen monocromática usa sólo dos colores: blanco y negro.</string>
    <string name="RunLength25">Entonces, si alcanzamos el final de una secuencia de blancos, el siguiente siempre será negro.</string>
    <string name="RunLength26">Al parecer podemos restaurar la imagen del código aún sin las letras W y B.</string>
    <string name="RunLength27">Si omitimos las letras W y B, el código resultante es de 13 caracteres, más o menos la mitad que antes.</string>
    <string name="RunLength28">Aún así, necesitamos establecer una regla que permita saber que el primer número en la secuencia se refiere a un número consecutivo de cuadrados blancos.</string>
    <string name="RunLength29">Con esta regla podemos restaurar correctamente la imagen a partir del código.</string>
    <string name="RunLength3">Como resultado al transformar filas una por una en Ys, Gs y Bs comenzando arriba a la izquierda, hemos sido capaces de codificar la imagen en una línea de 25 letras.</string>
    <string name="RunLength30">Entonces, ¿Cómo deberíamos codificar una imagen como la siguiente?</string>
    <string name="RunLength31">En contraste a la imagen anterior, el primer cuadrado es negro en lugar de blanco.</string>
    <string name="RunLength32">Esta vez hemos intentado codificar la imagen tal como antes</string>
    <string name="RunLength33">El primer número en el código, 6, se refiere al número consecutivo de cuadrados negros,</string>
    <string name="RunLength34">pero esto no se ajusta a nuestra regla de que \"el primer número en el código se refiere al número consecutivo de cuadrados blancos\"</string>
    <string name="RunLength35">Si restauramos esta imagen con el código actual, el resultado será una imagen con los colores blanco y negro invertidos.</string>
    <string name="RunLength36">así que para seguir completamente la regla de que \"el primer número en el código se refiere al número consecutivo de cuadrados blancos\", un cero (0) ha sido agregado al principio del código.</string>
    <string name="RunLength37">Esto sencillamente indica que no hay ningún cuadrado blanco al inicio de la imagen.</string>
    <string name="RunLength38">Al agregar este 0 al inicio del código, el número de caracteres aumentó en 1, pero pudimos codificar y comprimir esta imagen sin cambiar la regla que ya habíamos establecido.</string>
    <string name="RunLength39">En general, puede decirse que la codificación Run-Length está configurada más apropiadamente para imágenes, y no para texto que casi nunca tiene caracteres consecutivos repetitivos.</string>
    <string name="RunLength4">Ahora, usaremos la codificación Run-Length sobre la imagen, e intentaremos expresarla en menos de 25 letras.</string>
    <string name="RunLength40">Lo que se quiere es una estrategia que exhiba compresión superior y mejores resultados en ambos casos.</string>
    <string name="RunLength41">Esto concluye la explicación de la Codificación Run-Length.</string>
    <string name="RunLength5">La \"Codificación Run-Length\" es un método de codificación que hace un código y el número de veces que se repite en un conjunto.</string>
    <string name="RunLength6">Por ejemplo, podemos expresar la primera parte \"YYYY\" como \"Y4\", que es dos caracteres más corto.</string>
    <string name="RunLength7">La misma operación se repite, completando la codificación Run-Length.</string>
    <string name="RunLength8">Como resultado tenemos una imagen codificada, esta vez 5 caracteres más corta y ahora codificada en 20 caracteres.</string>
    <string name="RunLength9">Si se sabe que la imagen tiene 5 cuadrados por fila, la imagen original puede ser decodificada.</string>
    <string name="SecurityBase">Encriptación Básica</string>
    <string name="SecurityBase0">¿Por qué necesitamos tecnologías de encriptación en el mundo del Internet moderno?</string>
    <string name="SecurityBase1">Digamos que el agente A intenta enviar un mensaje al agente B por Internet</string>
    <string name="SecurityBase10">Cuando se encripta información, no hay nada de qué preocuparse aún si esta información es interceptada por un tercero.</string>
    <string name="SecurityBase11">Por lo tanto, la tecnología de encriptación ha adquirido muchísima importancia en el mundo de Internet de hoy.</string>
    <string name="SecurityBase12">A continuación, revisaremos en detalle exactamente el tipo de operaciones que están involucradas en la encriptación.</string>
    <string name="SecurityBase13">Primero que todo, sin importar qué tipo de información sea, un computador manipula la información en binario, o sea usando los dígitos 1 y 0.</string>
    <string name="SecurityBase14">Existen diversos formatos de datos, como texto, videos, música...</string>
    <string name="SecurityBase15">pero dentro del computador, toda la información es manipulada como valores binarios.</string>
    <string name="SecurityBase150">Hemos explicado por qué es necesaria la tecnología de encriptación de datos, la idea de la manipulación de los datos como valores numéricos y por qué la encriptación es un cálculo numérico.</string>
    <string name="SecurityBase16">Pensemos en la encriptación de datos teniendo esto en cuenta.</string>
    <string name="SecurityBase17">Para el ordenador, los datos son una secuencia de números que tienen algún sentido o significado.</string>
    <string name="SecurityBase18">A pesar de que el \"texto cifrado\" también es una secuencia de números, estos son aleatorios y el computador no es capaz de descifrar su significado de manera normal.</string>
    <string name="SecurityBase19">La encriptación significa llevar a cabo algún tipo de operación sobre los datos para convertirlos en datos que el computador no puede descifrar.</string>
    <string name="SecurityBase2">Esa información es entregada a B pasando a través de una variedad de redes y dispositivos en Internet.</string>
    <string name="SecurityBase20">Una \"llave\" es usada para las operaciones numéricas de la encriptación.</string>
    <string name="SecurityBase21">Esta llave también está hecha de valores numéricos.</string>
    <string name="SecurityBase22">En otras palabras, usando una llave para las operaciones numéricas, la encriptación convierte los datos en algo que no puede ser leído.</string>
    <string name="SecurityBase23">Del modo contrario, la llave numérica permite descifrar el texto cifrado para restituirlo al mensaje original.</string>
    <string name="SecurityBase24">Por ejemplo, veamos en detalle lo que sucede cuando la operación \"XOR\" es usada con los dato y las llaves mostradas.</string>
    <string name="SecurityBase25">XOR (exclusive or = ó exclusivo en Español) es una operación que realiza cálculos basándose en una \"Tabla de Verdad\".</string>
    <string name="SecurityBase26">Una característica de XOR es que estas expresiones son verdaderas</string>
    <string name="SecurityBase27">Eso significa que C es el resultado del cálculo de XOR sobre los valores A y B.</string>
    <string name="SecurityBase28">Es posible hacer un cálculo XOR una vez más usando C y A ó B para obtener el otro valor.</string>
    <string name="SecurityBase29">Usando la llave para hacer un cálculo XOR sobre los datos,</string>
    <string name="SecurityBase3">Si la información es enviada tal cual,</string>
    <string name="SecurityBase30">fuimos capaces de obtener el texto cifrado.</string>
    <string name="SecurityBase31">Ahora intentaremos descifrar el texto cifrado.</string>
    <string name="SecurityBase32">Usando la llave una vez más para hacer el cálculo XOR sobre el texto cifrado,</string>
    <string name="SecurityBase33">logramos obtener la información original.</string>
    <string name="SecurityBase34">Como puede verse, la misma llave es usada para encriptar y descifrar al usar un cálculo XOR como método de encriptación.</string>
    <string name="SecurityBase35">Esto concluye la explicación de la Encriptación Básica.</string>
    <string name="SecurityBase4">existe la posibilidad de que sea interceptada por un tercero con intenciones maliciosas.</string>
    <string name="SecurityBase5">Por esta razón es necesario encriptar la información antes de enviarla, para que permanezca privada.</string>
    <string name="SecurityBase6">Los datos que han sido encriptados se denominan \"Texto Cifrado\".</string>
    <string name="SecurityBase7">El texto cifrado es enviado a B.</string>
    <string name="SecurityBase8">El agente B desencripta el texto cifrado recibido de A, y puede acceder al mensaje original.</string>
    <string name="SecurityBase9">El proceso de decodificación o desencriptación de datos hasta obtener el mensaje original se llama \"Descifrado\".</string>
    <string name="SecurityBasic">Seguridad Básica</string>
    <string name="SecurityBasic0">Cuando intercambiamos información y datos sobre internet, nuestros datos llegan al receptor pasando a través de una variedad de redes y dispositivos.</string>
    <string name="SecurityBasic1">Debido a esto, la tecnología en seguridad se convierte en un elemento esencial para usar Internet de forma segura.</string>
    <string name="SecurityBasic10">Este problema se llama \"Suplantación\" o \"Spoofing\" en Inglés.</string>
    <string name="SecurityBasic11">\#3: Aún cuando el mensaje enviado por el agente A es recibido por el agente B,</string>
    <string name="SecurityBasic12">existe la posibilidad de que el mensaje haya sido alterado durante la transmisión.</string>
    <string name="SecurityBasic13">Este problema se conoce como \"Falsificación\".</string>
    <string name="SecurityBasic14">Además de la falsificación maliciosa por un tercero, también es posible que el mensaje se vea dañado o comprometido por algún problema durante la transmisión.</string>
    <string name="SecurityBasic15">\#4: Mientras que el agente B recibe un mensaje y cree que proviene del agente A,</string>
    <string name="SecurityBasic16">si el emisor del mensaje (agente A) tiene intenciones maliciosas,</string>
    <string name="SecurityBasic17">en teoría podría insistir en que \"ese mensaje nunca fue enviado por mí\" o \"ese no fue el mensaje que yo envié\"\".</string>
    <string name="SecurityBasic18">Cuando algo así sucede, el Internet ya no es un medio viable de comunicación entre las partes para transacciones comerciales, legales o contratos de algún tipo.</string>
    <string name="SecurityBasic19">Este problema se conoce como \"Repudio\" o \"Repudiation\" en Inglés.</string>
    <string name="SecurityBasic2">Para comenzar, revisemos los 4 problemas más prominentes que pueden darse cuando los datos están siendo transmitidos.</string>
    <string name="SecurityBasic20">Hemos explicado brevemente los 4 problemas principales.</string>
    <string name="SecurityBasic21">Más allá, estos problemas no están limitados a los intercambios de información entre personas, pero también pueden darse al estar navegando en un</string>
    <string name="SecurityBasic22">Ahora, demos un vistazo breve a los tipos de tecnologías de seguridad que están disponibles para solventar estos problemas.</string>
    <string name="SecurityBasic23">Para prevenir el problema de interceptación usamos la tecnología de \"Encriptación\".</string>
    <string name="SecurityBasic24">Para prevenir el segundo problema, el de suplantación, usamos bien sea \"códigos de autenticación de mensajes\",</string>
    <string name="SecurityBasic25">o tecnologías de \"firmas digitales\".</string>
    <string name="SecurityBasic26">De igual manera, Para prevenir el tercer problema, el de falsificación, usamos bien sea \"códigos de autenticación de mensajes\",</string>
    <string name="SecurityBasic27">o tecnologías de \"firmas digitales\".</string>
    <string name="SecurityBasic28">Esta tecnología de firmas digitales también es útil para prevenir el cuarto problema, el de repudio.</string>
    <string name="SecurityBasic29">Agregando todo en un diagrama, vemos la siguiente ilustración.</string>
    <string name="SecurityBasic3">\#1: Cuando el agente A intenta enviar un mensaje al agente B,</string>
    <string name="SecurityBasic30">También, la tecnología de \"certificado digital\" ayuda a resolver el problema inherente a las firmas digitales de en ocasiones no ser posible la verificación del dueño de una clave pública.</string>
    <string name="SecurityBasic31">Todas estas tecnologías de seguridad son explicadas en detalle en esta app.</string>
    <string name="SecurityBasic32">Esto concluye la explicación de Seguridad Básica.</string>
    <string name="SecurityBasic4">existe la posibilidad de que el mensaje sea interceptado por el agente X durante la transmisión.</string>
    <string name="SecurityBasic5">Este problema se llama \"Interceptación\".</string>
    <string name="SecurityBasic6">\#2: Incluso cuando el agente A intentaba entregar un mensaje al agente B,</string>
    <string name="SecurityBasic7">existe la posibilidad de que el agente X se haga pasar por el agente B.</string>
    <string name="SecurityBasic8">De forma inversa, a pesar de que el agente B cree que el mensaje proviene de A,</string>
    <string name="SecurityBasic9">podría suceder que el mensaje provenga del agente X haciéndose pasar por A.</string>
    <string name="SecuritySection">Seguridad</string>
    <string name="SelectionSort">Ordenado por Selección</string>
    <string name="SelectionSort0">El \"Ordenado por Selección\" es un algoritmo usado para ordenar secuencias de números.</string>
    <string name="SelectionSort1">Usando una búsqueda lineal, el valor más bajo de la secuencia es localizado. La explicación detallada de lo que \"Búsqueda Lineal\" significa puede ser encontrada en esta misma app.</string>
    <string name="SelectionSort2">El valor más bajo se intercambia con cualquier valor que se encuentre en el extremo izquierdo de la secuencia, y es considerado ya ordenado.</string>
    <string name="SelectionSort3">Además, si el valor más bajo ya se encuentra en el extremo izquierdo de la secuencia, ninguna operación es llevada a cabo.</string>
    <string name="SelectionSort4">La misma operación es repetida hasta que todos los números han sido ordenados completamente.</string>
    <string name="SelectionSort6">El orden de la secuencia está completo.</string>
    <string name="SelectionSort7">Esto concluye la explicación del Ordenado por Selección.</string>
    <string name="Setting">Configuración</string>
    <string name="SettingNotShowUnreadButtons">Ocultar indicadores</string>
    <string name="Share">Compartir y calificar esta app</string>
    <string name="ShareOnFacebook">Compartir en Facebook</string>
    <string name="ShareOnTwitter">Compartir en Twitter</string>
    <string name="Shuffle">Mezclar</string>
    <string name="SortSection">Ordenar</string>
    <string name="Stack">Pilas</string>
    <string name="Stack0">Las \"Pilas\" son un tipo de estructura de datos.</string>
    <string name="Stack1">La estructura propia de una Pila puede ser fácilmente imaginada como una pila de objetos apilados verticalmente.</string>
    <string name="Stack10">Esto concluye la explicación de las Pilas.</string>
    <string name="Stack2">Al extraer objetos de la pila, son extraídos en orden desde arriba hacia abajo.</string>
    <string name="Stack3">Al agregar datos a una pila, los datos son agregados en la posición disponible más abajo.</string>
    <string name="Stack5">Usamos el término \"Push\" para referirnos a la acción de agregar datos en una Pila.</string>
    <string name="Stack6">Al extraer datos de una Pila, la información agregada más recientemente es removida primero.</string>
    <string name="Stack8">Usamos el término \"Pop\" para referirnos a la acción de extraer datos en una Pila.</string>
    <string name="Stack9">Este método de extraer primero los datos agregados más recientemente se llama \"UEPS\" o \"Último en Entrar, Primero en Salir\", o también conocido en Inglés como \"LIFO\" o \"Last In First Out\".</string>
    <string name="ThankYouForUnlocking">Gracias por comprar Algoritmos: Explicados y Animados. ¡Esperamos que lo disfrute!</string>
    <string name="ToSendUs">Para enviar un requerimiento o un reporte de fallo, por favor use la sección \"Feedback\"</string>
    <string name="Unlock">Comprar todos los algoritmos</string>
    <string name="UnlockSuccessed">Compra de los algoritmos completada.</string>
    <string name="WEB">La Web</string>
    <string name="YouCanLearnAfter">\"%@\" puede ser estudiado al comprar todos los algoritmos.</string>
    <string name="YouCanLearnAfterAndroid">\"%s\" puede ser estudiado al comprar todos los algoritmos.</string>
    <string name="YouCanRestore">Si usted ya ha comprado todos los algoritmos, puede volver a tener acceso a todos los temas actualizando su registro de compra.</string>
    <string name="abc_action_bar_home_description">Ir a la pantalla de inicio</string>
    <string name="abc_action_bar_up_description">Desplazarse hacia arriba</string>
    <string name="abc_action_menu_overflow_description">Más opciones</string>
    <string name="abc_action_mode_done">Listo</string>
    <string name="abc_activity_chooser_view_see_all">Ver todo</string>
    <string name="abc_activitychooserview_choose_application">Seleccionar una aplicación</string>
    <string name="abc_capital_off">DESACTIVADO</string>
    <string name="abc_capital_on">ACTIVADO</string>
    <string name="abc_search_hint">Buscar…</string>
    <string name="abc_searchview_description_clear">Borrar consulta</string>
    <string name="abc_searchview_description_query">Consulta</string>
    <string name="abc_searchview_description_search">Buscar</string>
    <string name="abc_searchview_description_submit">Enviar consulta</string>
    <string name="abc_searchview_description_voice">Búsqueda por voz</string>
    <string name="abc_shareactionprovider_share_with">Compartir con</string>
    <string name="abc_shareactionprovider_share_with_application">Compartir con %s</string>
    <string name="abc_toolbar_collapse_description">Contraer</string>
    <string name="app_name">Algoritmos</string>
    <string name="en">Inglés</string>
    <string name="es">Español</string>
    <string name="goal">META</string>
    <string name="ja">Japonés</string>
    <string name="ko">Coreano</string>
    <string name="min">min</string>
    <string name="pt">Portugués</string>
    <string name="ru">Ruso</string>
    <string name="search">busca</string>
    <string name="search_menu_title">Buscar</string>
    <string name="status_bar_notification_info_overflow">+999</string>
    <string name="zh">Chino (simplificado)</string>
</resources>
