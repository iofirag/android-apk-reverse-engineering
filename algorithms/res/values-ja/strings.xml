<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="AStarSearch">Ａ＊</string>
    <string name="AStarSearch0">Ａ＊(エー・スター)はダイクストラ法を発展させたものです。この迷路の最短経路を、まずはダイクストラ法で解いてみましょう。</string>
    <string name="AStarSearch1">迷路は、各点の間のコストが１のグラフであると解釈できます。</string>
    <string name="AStarSearch10">今回設定した推定コストの数字は、例えばその地点の高度を表すと考えると分かりやすいかもしれません。</string>
    <string name="AStarSearch100">あらかじめ分かっている情報から適切な推定コストを設定し、それをヒントとして与えておくことで、より効率的な探索が可能になります。</string>
    <string name="AStarSearch101">スタートからの現時点までの実際に掛かったコストと、現時点からゴールへの推定コストを足し合わせることで、スタートからゴールまでのコストを計算したことになります。</string>
    <string name="AStarSearch11">右下にあるゴールの地点が最も低く、左上のコスト８の地点が最も高くなっています。坂道を上がるよりも、下がるほうが楽です。</string>
    <string name="AStarSearch12">迷路を探索するにあたり、坂道を降りるように、つまり、コストの低い方向へと進みやすくすれば、すばやくゴールに辿り着きそうです。</string>
    <string name="AStarSearch13">それでは、Ａ＊で解いてみましょう。</string>
    <string name="AStarSearch14">まず、スタート地点を探索済みにします。</string>
    <string name="AStarSearch15">スタート地点から辿れる点のコストをそれぞれ計算します。</string>
    <string name="AStarSearch16">コストは「そこに辿り着くまでのコスト」と「ゴールまでの推定コスト」の合計で計算します。</string>
    <string name="AStarSearch17">コストが最も低い点をひとつ選びます。</string>
    <string name="AStarSearch18">選んだ点を探索済みにします。</string>
    <string name="AStarSearch19">探索済みにした点から辿れる点のコストを計算します。</string>
    <string name="AStarSearch2">そのことを前提にダイクストラ法で最短路を求めてみましょう。</string>
    <string name="AStarSearch20">コストが最も低い点をひとつ選びます。</string>
    <string name="AStarSearch21">選んだ点を探索済みにします。</string>
    <string name="AStarSearch22">以下、同様の操作をゴールに辿り着くまで繰り返します。</string>
    <string name="AStarSearch24">ダイクストラ法と比べてかなり効率的に迷路を探索できました。</string>
    <string name="AStarSearch25">さらに効率的に迷路を解くには、どうすれば良いでしょうか。</string>
    <string name="AStarSearch26">仮に、ヒューリスティックコストを、「直線距離」ではなく、「実際にかかる最短コスト」にしてみましょう。</string>
    <string name="AStarSearch28">今度は、まったく余計な道に進むことなく、最短路を進んでゴールに辿り着きました。</string>
    <string name="AStarSearch29">現実的には、「実際にかかる最短コスト」が分かっていることはありません。それが分かっているのであれば、探索をする必要がないからです。</string>
    <string name="AStarSearch30">このように、Ａ＊では、ヒューリスティックコストをどのように設定するかが、調整のしどころとなります。</string>
    <string name="AStarSearch31">ヒューリスティックコストが「実際にかかる最短コスト」に近いほどに、より効率的に迷路を解くことができます。</string>
    <string name="AStarSearch32">逆に、ヒューリスティックコストの調整に失敗した場合にどうなるかを、見てみましょう。</string>
    <string name="AStarSearch33">ここでは、極端な例としてヒューリスティックコストを最短路上のみ残し、その他を０と置いてみました。</string>
    <string name="AStarSearch35">ダイクストラ法よりも、効率の悪い結果となりました。しかし、最短路は正しく求まりました。</string>
    <string name="AStarSearch36">Ａ＊では、ヒューリスティックコストを「現地点からゴールまでの最短コスト」以下に設定する限り、効率の差はあれども、迷路の最短路がもとまることは保証されています。</string>
    <string name="AStarSearch37">悪い例として、ヒューリスティックコストを「現地点からゴールまでの最短コスト」より、大きく設定してみましょう。</string>
    <string name="AStarSearch38">ここでは、最短路上のみに残していたヒューリスティックコストを、２倍の値に設定しました。これにより、「現地点からゴールまでの最短コスト」を大きく上回りました。</string>
    <string name="AStarSearch4">最短路が求まりましたが、迷路のほとんどの道を辿ったことになります。</string>
    <string name="AStarSearch40">アルゴリズムは、探索が完了したと判断しましたが、求まった経路は、最短路とは異なるものでした。</string>
    <string name="AStarSearch41">このように、Ａ＊がすぐれた探索アルゴリズムとなるかは調整の仕方によって変わることが分かります。</string>
    <string name="AStarSearch42">ゲームプログラミングにおいて、プレイヤーを追いかける敵のAIなどに、よく使用されます。</string>
    <string name="AStarSearch43">しかし、計算量が多いためゲーム全体の進行速度に悪い影響を与えることもあり得ます。他のアルゴリズムと組み合わせたり、使う場面を絞ったりと、使用にあたっての工夫が必要となります。</string>
    <string name="AStarSearch44">これで「Ａ＊」の解説を終わります。</string>
    <string name="AStarSearch5">ダイクストラ法ではスタートからのコストのみを考慮して、次にたどる点を決定しています。</string>
    <string name="AStarSearch6">そのため、矢印のような経路も、ゴールから遠ざかっているとは気づかずに探索することになります。</string>
    <string name="AStarSearch7">Ａ＊では、スタートからのコストだけではなく、現地点からゴールへのコストの推定値も加味して探索します。</string>
    <string name="AStarSearch8">この推定値は自由に設定することができます。ここでは、右下にあるゴールからの直線距離を四捨五入した値を用いることにしました。</string>
    <string name="AStarSearch9">このように人の手であらかじめ設定する推定コストを「ヒューリスティックコスト」と呼びます。</string>
    <string name="AStarSearchDescription">「Ａ＊」はダイクストラ法をより発展させたアルゴリズムです。この項目は、全アルゴリズムのご購入後に学ぶことができます。</string>
    <string name="AboutDev">アルゴリズム図鑑について</string>
    <string name="AlgorithmText1">・RSA暗号</string>
    <string name="AlgorithmText2">・楕円曲線暗号</string>
    <string name="AlreadyBought">ご購入済み</string>
    <string name="AlreadyBoughtRestore">アプリを再インストールした場合や、他のiOS端末にもインストールした場合には、「購入記録の復元」をご利用ください。</string>
    <string name="AlreadyBoughtRestoreAndroid">アプリを再インストールした場合や、他のAndroid端末にもインストールした場合には、「購入記録の復元」をご利用ください。</string>
    <string name="AppTitle">アルゴリズム図鑑</string>
    <string name="Array">配列</string>
    <string name="Array0">配列はデータ構造のひとつで、複数の値を格納することができます。</string>
    <string name="Array1">各要素には添字(データの何番目かを表す数字)でアクセスできます。</string>
    <string name="Array10">まず配列の最後に追加する空間を確保します。</string>
    <string name="Array11">追加される空間を空けるため、ひとつずつデータをずらします。</string>
    <string name="Array13">空いた空間に、「Green」を追加して追加の操作が完了します。</string>
    <string name="Array14">逆に２番目の要素を削除するときは</string>
    <string name="Array15">まず、要素を削除し</string>
    <string name="Array16">空いた空間を、データをひとつずらして埋めます。</string>
    <string name="Array18">最後に、余った空間を削除して削除の操作が完了します。</string>
    <string name="Array19">これで「配列」の解説を終わります。</string>
    <string name="Array2">データはメモリーの連続した領域に、順番通りに格納されます。</string>
    <string name="Array3">連続した領域に格納されているので、メモリアドレスが添字を使って計算でき、各データにランダムアクセスができます。</string>
    <string name="Array8">また、配列の特徴として、任意の場所へのデータの追加・削除の操作がリストに比べてコストが高いです。</string>
    <string name="Array9">「Green」を２番目に追加することを考えます。</string>
    <string name="BellmanFord">ベルマンフォード法</string>
    <string name="BellmanFord0">ベルマンフォード法はグラフの最短路を求めるアルゴリズムです。</string>
    <string name="BellmanFord1">各点のコストの初期値を設定します。始点は０、それ以外の点は無限大に設定します。</string>
    <string name="BellmanFord10">つづいて、逆方向である点Ｂから点Ａを辿る場合を計算します。</string>
    <string name="BellmanFord11">点Ｂのコストは９なので、点Ｂから点Ａを辿るコストは９＋９で18となります。</string>
    <string name="BellmanFord12">点Ａの現状の値と比較すると、現状の値の方が小さいので、コストは更新しません。</string>
    <string name="BellmanFord13">コストが大きい点から小さい点に向かう場合は、辺のコストがマイナスでない限りは、更新されることがありません。</string>
    <string name="BellmanFord14">同様の操作を全ての辺に対して行います。辺の順番は任意ですが、今回は便宜上、より左側にある辺から計算していきます。</string>
    <string name="BellmanFord15">辺をひとつ選択し…</string>
    <string name="BellmanFord150">例えば、点Ｃは１回の移動、点Ｄは、２回の移動での最短路がそれぞれ求まっています。</string>
    <string name="BellmanFord16">コストを更新しました。</string>
    <string name="BellmanFord17">同様に辺をひとつ選択し…</string>
    <string name="BellmanFord18">コストを更新しました。</string>
    <string name="BellmanFord19">現時点では、点Ａから点Ｂに行く場合、点Ａから直接辿るより、点Ｃを経由したほうがコストが小さいことが分かります。</string>
    <string name="BellmanFord2">全ての辺からひとつを選択します。ここでは便宜上Ａ−Ｂを結ぶ辺を選択しました。</string>
    <string name="BellmanFord20">全ての辺に対して更新の操作を行っていきます。</string>
    <string name="BellmanFord21">更新の操作が１巡しました。</string>
    <string name="BellmanFord22">この全辺に対する更新の操作を、コストが更新されなくなるまで繰り返します。</string>
    <string name="BellmanFord24">点のコストが更新されなくなったので、操作を止めます。</string>
    <string name="BellmanFord25">この時点でアルゴリズムによる探索は完了となり、始点から全ての点への最短路が求められています。</string>
    <string name="BellmanFord26">なぜこれらの操作で最短路が求まるかを考えてみましょう。</string>
    <string name="BellmanFord27">場面を、最初の状態に戻しました。</string>
    <string name="BellmanFord28">今度は、始点である点Ａから延びる辺の更新が最後となるように、全辺の更新の操作を逆順、つまり、より右側の辺から行ってみましょう。</string>
    <string name="BellmanFord3">選択した辺の、一方の点から他方の点を辿る場合のコストをそれぞれ計算します。計算方法は「元の点のコスト＋移動にかかるコスト」です。</string>
    <string name="BellmanFord30">更新が１巡しました。</string>
    <string name="BellmanFord31">更新が１巡した時点では、始点Ａから１回の移動で辿れることのできる点のコストのみが更新されていることが分かります。</string>
    <string name="BellmanFord32">２巡目の更新を行ってみます。</string>
    <string name="BellmanFord34">２巡目の更新が終わりました。</string>
    <string name="BellmanFord35">更新が２巡した時点では、始点から２回の移動で辿ることのできる点のコストのみが更新されていることが分かります。</string>
    <string name="BellmanFord36">実は、更新の操作をＮ回行った時点では、始点Ａからの移動をＮ回以下に限った場合の各点への最短路が求まっていることが保証されています。</string>
    <string name="BellmanFord37">図は、更新の操作を２回行った状態なので、始点からの移動を２回以下にした条件での各点への最短路は少なくとも求まっていることになります。</string>
    <string name="BellmanFord38">あくまで２回以下の移動での最短路なので、例えば点Ｆは実際はＡ−Ｃ−Ｄ−Ｆという経路で辿った方がよりコストが小さくなりますが、３回移動を必要とするため、考慮されていません。</string>
    <string name="BellmanFord39">また点Ｂは３回移動した場合の最短路になっていますが、これは辺を更新する順番でたまたまこうなっています。</string>
    <string name="BellmanFord4">計算は片方向ずつ順番に行いますが、どちらから計算しても問題はありません。この解説では便宜上、コストが小さい点から大きい点に向かう方向を先に計算することにします。</string>
    <string name="BellmanFord40">つまり、辺を更新する順番によっては、更新した回数以上の移動を必要とする最短路が求まっている場合もあります。</string>
    <string name="BellmanFord41">さて、ｎ回更新の操作をおこなった時に、ｎ回以下の移動での最短路が少なくとも求まっているということは、何回更新の操作をおこなえば良いでしょうか。</string>
    <string name="BellmanFord42">点がｎ個あったとし、同じ点を辿らないとすると、ｎ−１回移動すれば必ず全ての点を辿ることができます。</string>
    <string name="BellmanFord43">つまり、多くともｎ−１回更新の操作をおこなえば、全ての点に対する最短路が求まっていることになります。</string>
    <string name="BellmanFord44">また、途中で更新がなくなった場合も、最短路が確定していることと判断できるので、そこで操作を終了します。</string>
    <string name="BellmanFord45">では、全ての点への最短路が求まるまで、図の状態から更新の操作を再開してみます。</string>
    <string name="BellmanFord47">更新がなくなったので、操作を止めます。</string>
    <string name="BellmanFord48">先ほどと同じ全点への最短路が導き出せました。</string>
    <string name="BellmanFord49">なお、グラフのＡ−Ｂのように往路と復路でコストが異なっていても、また、他の辺のように一方通行しかできなくても…</string>
    <string name="BellmanFord5">点Ａの方が現状のコストが小さいので、点Ａから点Ｂへ辿る場合を先に計算します。</string>
    <string name="BellmanFord50">ベルマンフォード法は最短路を正しく求めることができます。</string>
    <string name="BellmanFord51">なお、図のような、辺に向きが設定されているグラフを「有向グラフ」、また向きが設定されていないグラフは「無向グラフ」と言います。</string>
    <string name="BellmanFord52">それでは、「負のコスト」を含む場合はどうでしょうか。</string>
    <string name="BellmanFord53">「負のコスト」とは、図ではＣ−Ｂにある「-3」を指します。</string>
    <string name="BellmanFord54">コストが負の値であるとはどういうことなのか想像しづらいですが…</string>
    <string name="BellmanFord55">例えば、始点Ａから終点Ｇまでを車で移動する場合を考えてみましょう。各コストは燃料の消費量を表すと考えることができます。</string>
    <string name="BellmanFord56">その場合、「負のコスト」の個所にはガソリンスタンドがあり、燃料を補給できると考えると分かりやすいかもしれません。</string>
    <string name="BellmanFord57">ベルマンフォード法では、このような「負のコスト」を含む場合でも、最短路が正しく求まります。</string>
    <string name="BellmanFord58">それでは、グラフのようにＣ−Ｂの「負のコスト」が「-3」から「-6」になった場合はどうでしょうか。</string>
    <string name="BellmanFord59">一見、問題なく最短路が求まるように思われますが…</string>
    <string name="BellmanFord6">点Ａのコストは０なので、点Ａから点Ｂを辿るコストは０＋９で９となります。</string>
    <string name="BellmanFord60">Ａ−Ｃ−Ｂをぐるっと一周したときのコストの合計は「-1」となります。</string>
    <string name="BellmanFord61">このような経路を「負の閉路」と呼びます。</string>
    <string name="BellmanFord62">負の閉路が存在している場合、そこを回り続けることで、コストをどこまでも小さくすることができてしまいます。</string>
    <string name="BellmanFord63">そのため、どのような方法でも最短路を求めることはできません。</string>
    <string name="BellmanFord64">このグラフの最短路をベルマンフォード法で求めようとすると、何回更新を行ってもどこかの点の値が変わってしまい、完了しません。</string>
    <string name="BellmanFord65">逆に、ベルマンフォード法は最大でも点の数−１回の操作で更新が完了するはずなので…</string>
    <string name="BellmanFord66">更新がｎ回以上に及ぶ場合は、グラフのどこかに負の閉路が存在するということになります。</string>
    <string name="BellmanFord67">以上のように、ベルマンフォード法は計算量の多いアルゴリズムですが、負のコストがあっても最短路を求めることができ…</string>
    <string name="BellmanFord68">負の閉路が存在することを検知することもできます。</string>
    <string name="BellmanFord69">これで「ベルマンフォード法」の解説を終わります。</string>
    <string name="BellmanFord7">計算した結果が、現状の値より小さければコストを新しい値で更新します。</string>
    <string name="BellmanFord8">点Ｂの現状の値は無限大なので、コストを９に更新しました。</string>
    <string name="BellmanFord9">値が更新された場合、どの点から来た経路であるかを記録しておきます。図では、経路をオレンジの線で表しています。</string>
    <string name="BinarySearch">２分探索</string>
    <string name="BinarySearch0">２分探索は整列された配列から要素を探索するアルゴリズムです。</string>
    <string name="BinarySearch1">数６を探索してみましょう。</string>
    <string name="BinarySearch10">残った配列の中心にある数を調べます。この場合は６になります。</string>
    <string name="BinarySearch11">６＝６ となり数を発見しました。</string>
    <string name="BinarySearch12">このように、２分探索は配列が整列されていることを利用し、探索する数を半分ずつに減らしていくことで、効率良く数を探索することができます。</string>
    <string name="BinarySearch13">これで「２分探索」の解説を終わります。</string>
    <string name="BinarySearch2">まず、配列の中心にある数を調べます。この場合は５になります。</string>
    <string name="BinarySearch3">５と探索する数である６を比較します。５＜６ なので６は５より右側にあることがわかります。</string>
    <string name="BinarySearch4">必要のなくなった数字は候補から外します。</string>
    <string name="BinarySearch6">残った配列の中心にある数を調べます。この場合は７になります。</string>
    <string name="BinarySearch7">７と６を比較します。６＜７ なので６は７より左側にあることがわかります。</string>
    <string name="BinarySearch8">必要のなくなった数字は候補から外します。</string>
    <string name="BinaryTree">２分探索木</string>
    <string name="BinaryTree0">２分探索木はデータ構造のひとつです。</string>
    <string name="BinaryTree1">数字の書かれた節点は「ノード」と呼ばれます。</string>
    <string name="BinaryTree10">逆に、２分探索木の最大ノードは、最上部のノードから右部分木のみを辿った末端にあります。</string>
    <string name="BinaryTree11">２分探索木にノードを追加する手順を見てみましょう。</string>
    <string name="BinaryTree12">例として、１を追加してみます。</string>
    <string name="BinaryTree13">ノードを追加する場所を、２分探索木の最上部のノードから探索します。</string>
    <string name="BinaryTree14">１＜15 なので、左に進みます。</string>
    <string name="BinaryTree16">１＜９ なので、左に進みます。</string>
    <string name="BinaryTree18">１＜３ なので、左に進みますが、進む先にノードがないため、新しいノードとして追加します。</string>
    <string name="BinaryTree2">２分探索木は２つの性質があります。</string>
    <string name="BinaryTree20">これで１の追加は完了です。</string>
    <string name="BinaryTree21">次に、４を追加してみましょう。</string>
    <string name="BinaryTree22">先ほどと同様に、追加する場所を上から２分探索木の最上部のノードから探索していきます。</string>
    <string name="BinaryTree23">４＜15 なので、左に進みます。</string>
    <string name="BinaryTree25">４＜９ なので、左に進みます。</string>
    <string name="BinaryTree27">４＞３ なので、右に進みます。</string>
    <string name="BinaryTree29">４＜８ なので、左に進みますが、進む先にノードがないため、新しいノードとして追加します。</string>
    <string name="BinaryTree3">１つ目の性質として、全てのノードは、そのノードの左部分木に含まれるどの数よりも大きくなります。</string>
    <string name="BinaryTree31">これで４の追加は完了です。</string>
    <string name="BinaryTree32">２分探索木からノードを削除する手順を見てみましょう。</string>
    <string name="BinaryTree33">例として、28を削除してみます。</string>
    <string name="BinaryTree34">子を持たないノードの場合…</string>
    <string name="BinaryTree35">対象のノードを削除するだけで完了です。</string>
    <string name="BinaryTree36">次に、８を削除してみましょう。</string>
    <string name="BinaryTree37">子を１つだけ持つノードを削除する場合には…</string>
    <string name="BinaryTree38">対象のノードを削除し…</string>
    <string name="BinaryTree39">削除したノードの位置に、子ノードを移動させれば完了です。</string>
    <string name="BinaryTree4">例えば、ノード９はその左部分木のどの数よりも大きいです。</string>
    <string name="BinaryTree40">最後に、９を削除してみましょう。</string>
    <string name="BinaryTree41">子を２つ持つノードを削除する場合には…</string>
    <string name="BinaryTree42">まずノードを削除し…</string>
    <string name="BinaryTree43">削除したノードの左部分木から、最大ノードを見つけ…</string>
    <string name="BinaryTree44">削除したノードの位置に、移動させます。</string>
    <string name="BinaryTree45">これで、２分探索木の整合性を保ちつつ、ノードを削除することができました。</string>
    <string name="BinaryTree46">なお、移動対象となったノードも子ノードを持つ場合には、同じ処理を再帰的に繰り返します。</string>
    <string name="BinaryTree47">また、今回は移動対象に「左部分木の最大ノード」を利用しましたが、「右部分木の最小ノード」でも問題はありません。</string>
    <string name="BinaryTree48">今度は、２分探索木からノードを探索する手順を見てみましょう。</string>
    <string name="BinaryTree49">例として、12を探索してみます。</string>
    <string name="BinaryTree5">同じく、ノード15はその左部分木のどの数よりも大きいです。</string>
    <string name="BinaryTree50">２分探索木の最上部のノードから探索していきます。</string>
    <string name="BinaryTree51">12＜15 なので、左に進みます。</string>
    <string name="BinaryTree53">12＞４ なので、右に進みます。</string>
    <string name="BinaryTree55">12を発見しました。</string>
    <string name="BinaryTree56">このように、２分探索木を使うと、効率よく探索を行うことができることが分かります。</string>
    <string name="BinaryTree57">しかし、木が直線に近い形となる場合には、線形探索と同じように、探索効率は非常に悪いものとなります。</string>
    <string name="BinaryTree58">一方で、常に形のバランスを保つようにしたものは「平衡２分探索木」と呼ばれ、探索効率を保つことができます。</string>
    <string name="BinaryTree59">これで「２分探索木」の解説を終わります。</string>
    <string name="BinaryTree6">逆に、２つ目の性質として、全てのノードは、そのノードの右部分木に含まれるどの数よりも小さくなります。</string>
    <string name="BinaryTree7">例えば、ノード15はその右部分木のどの数よりも小さいです。</string>
    <string name="BinaryTree8">この２つの性質から、次のことが成り立ちます。</string>
    <string name="BinaryTree9">まず、２分探索木の最小ノードは、最上部のノードから左部分木のみを辿った末端にあります。</string>
    <string name="BinaryTreeDescription">「２分探索木」は探索木のうちで最も基本的となるものです。この項目は、全アルゴリズムのご購入後に学ぶことができます。</string>
    <string name="BreadthFirstSearch">幅優先探索</string>
    <string name="BreadthFirstSearch0">幅優先探索はグラフを探索するアルゴリズムです。</string>
    <string name="BreadthFirstSearch1">Ａを始点、Ｇをゴールとして探索を開始します。</string>
    <string name="BreadthFirstSearch11">候補のうち、最も早く追加されたのは点ＣとＤです。そのうち左側のＣを選択します。</string>
    <string name="BreadthFirstSearch12">選択した点に移動します。</string>
    <string name="BreadthFirstSearch13">現在いるＣからたどることのできるＨを新たに候補に追加します。</string>
    <string name="BreadthFirstSearch14">以下、同様の操作をゴールにたどり着くか、全ての点を探索し終えるまで繰り返します。</string>
    <string name="BreadthFirstSearch2">Ａからたどることのできる点ＢＣＤを、次に進む点の候補とします。</string>
    <string name="BreadthFirstSearch3">候補の中からひとつの点を選択します。選択の基準は、候補のうち、最も早く候補に追加されたものを選択します。</string>
    <string name="BreadthFirstSearch38">ゴールに到達したので、探索を終えます。</string>
    <string name="BreadthFirstSearch39">このように、幅優先探索は始点から近い順に幅広く探索をおこなっていく特徴があります。</string>
    <string name="BreadthFirstSearch4">同じタイミングで候補となった点は、どれを選択してもかまいません。今回は便宜上、左側にある点から選択することとします。</string>
    <string name="BreadthFirstSearch40">これで「幅優先探索」の解説を終わります。</string>
    <string name="BreadthFirstSearch5">今回の場合、全て同じタイミングで候補となったので、Ｂを選択します。</string>
    <string name="BreadthFirstSearch6">選択した点に移動します。</string>
    <string name="BreadthFirstSearch7">現在いるＢからたどることのできるＥとＦを新たに候補に追加します。</string>
    <string name="BreadthFirstSearch8">候補の点は「先入れ先出し(FIFO)」の仕組みで管理するので、「キュー」のデータ構造を用いることができます。</string>
    <string name="BreadthFirstSearch9">「キュー」については本アプリで詳しく解説しています。</string>
    <string name="BubbleSort">バブルソート</string>
    <string name="BubbleSort0">「バブルソート」は数列を整列するアルゴリズムのひとつです。</string>
    <string name="BubbleSort1">数列の右端に天秤を置き、天秤の左右の数字を比較します。</string>
    <string name="BubbleSort16">天秤が左端に到達しました。</string>
    <string name="BubbleSort2">この場合、７と６を比較します。</string>
    <string name="BubbleSort20">一連の操作で、数列の中で最も小さい数字が左の端に移動したことになります。</string>
    <string name="BubbleSort21">左端の数字をソート済みにし…</string>
    <string name="BubbleSort22">天秤を右端に戻します。</string>
    <string name="BubbleSort23">同様の操作を全ての数字がソート済みになるまで繰り返します。</string>
    <string name="BubbleSort25">ソートが完了しました。</string>
    <string name="BubbleSort26">これで「バブルソート」の解説を終わります。</string>
    <string name="BubbleSort3">比較した結果、右の数字の方が小さければ入れ替えます。</string>
    <string name="BubbleSort4">６＜７なので、左右の数字を入れ替えました。</string>
    <string name="BubbleSort5">比較が完了すると天秤をひとつ左に移動します。</string>
    <string name="BubbleSort6">同様に数字を比較します。</string>
    <string name="BubbleSort7">今回は４＜６なので、数字は入れ替えません。</string>
    <string name="BubbleSort8">天秤をひとつ左に移動します。</string>
    <string name="BubbleSort9">同様の操作を天秤が左端に行くまで繰り返します。</string>
    <string name="BuyAllAlgorithms">全てのアルゴリズムを購入する:%@</string>
    <string name="BuyAllAlgorithmsAndroid">全てのアルゴリズムを購入する:</string>
    <string name="CKC">共通鍵暗号方式</string>
    <string name="CKC0">「共通鍵暗号方式」は、暗号化と復号に同じ鍵を用いる暗号方式です。</string>
    <string name="CKC1">共通鍵暗号方式を使ったデータのやりとりの全体像を見ていきましょう。</string>
    <string name="CKC10">ＢさんはＡさんから受け取った暗号文を鍵を使って復号します。</string>
    <string name="CKC11">これで、Ｂさんは元のデータを取得することができました。</string>
    <string name="CKC12">データを暗号化しておけば、たとえ悪意のある第三者に盗み見されたとしても安心です。</string>
    <string name="CKC13">暗号化と復号で同じ鍵を使うことが、共通鍵暗号方式の特徴です。</string>
    <string name="CKC14">共通鍵暗号方式の計算方法としては図のようなものがあります。</string>
    <string name="CKC15">現在は、「AES」という方法がよく使われています。</string>
    <string name="CKC16">次に、共通鍵暗号方式の問題点について考えてみましょう。</string>
    <string name="CKC17">場面を少し戻します。今、ＢさんはＡさんから送信された暗号文を受け取ったところです。</string>
    <string name="CKC18">暗号文は、Ｘさんに盗み見されている可能性があります。</string>
    <string name="CKC19">ここで、ＡさんとＢさんには直接的な面識がないため…</string>
    <string name="CKC2">ＡさんがＢさんにインターネット経由でデータを送ろうとしているとします。</string>
    <string name="CKC20">暗号化に使われた鍵を、Ｂさんが知らない場合を考えてみましょう。</string>
    <string name="CKC21">Ａさんは何らかの手段で、Ｂさんに鍵を渡す必要があります。</string>
    <string name="CKC22">Ａさんは、暗号文と同様、インターネットを利用してＢさんに鍵を送信しました。</string>
    <string name="CKC23">ＢさんはＡさんから受け取った鍵を使って…</string>
    <string name="CKC24">暗号文を復号することができました。</string>
    <string name="CKC25">しかし、この鍵はＸさんも盗み見する可能性があります。</string>
    <string name="CKC26">そのため、Ｘさんも鍵を使って暗号文を復号することができてしまいます。</string>
    <string name="CKC27">この鍵を伝える方法には問題があることが分かりました。</string>
    <string name="CKC28">そこでＡさんは、Ｘさんに盗み見されてもよいように、鍵自体を暗号化することを考えました。</string>
    <string name="CKC29">コンピュータにおいては、鍵もまたデータのひとつに過ぎません。</string>
    <string name="CKC3">データはインターネット上のさまざまなネットワーク、機器を経由してＢさんに届きます。</string>
    <string name="CKC30">そのため…</string>
    <string name="CKC31">新しい鍵を使って、暗号化することができます。</string>
    <string name="CKC32">鍵の暗号文を…</string>
    <string name="CKC33">Ｂさんに送信します。</string>
    <string name="CKC34">Ｂさんの手元には、データの暗号文と、それを復号するための鍵の暗号文があります。</string>
    <string name="CKC35">鍵の暗号文もまた、Ｘさんに盗み見される可能性があります。</string>
    <string name="CKC36">あとは、「鍵の暗号化に使った新しい鍵」をＢさんに伝えるだけですが…</string>
    <string name="CKC37">Ａさんはこの「新しい鍵」をどうやってＢさんに送信すればよいでしょうか？</string>
    <string name="CKC38">暗号化しなければ、Ｘさんも「新しい鍵」を盗み見して、使うことができてしまいます。</string>
    <string name="CKC39">暗号化すれば、また新しい鍵ができてしまい、問題の繰返しになってしまいます。</string>
    <string name="CKC4">そのため、そのままのデータを送信しようとすると…</string>
    <string name="CKC40">まとめると、「共通鍵暗号方式」では、鍵を安全に伝える方法が必要となります。</string>
    <string name="CKC41">これが「鍵配送問題」と呼ばれる問題です。</string>
    <string name="CKC42">解決方法として「鍵交換プロトコルを使う方法」「公開鍵暗号方式を使う方法」の２種類があり、本アプリではそれぞれについて詳しく解説しています。</string>
    <string name="CKC43">これで「共通鍵暗号方式」の解説を終わります。</string>
    <string name="CKC5">悪意のある第三者にデータを盗み見される可能性があります。</string>
    <string name="CKC6">そのため、秘密にしたいデータは暗号化して送る必要があります。</string>
    <string name="CKC7">鍵を使って…</string>
    <string name="CKC8">データを暗号化し、暗号文にします。</string>
    <string name="CKC9">暗号文をＢさんに送信します。</string>
    <string name="Cancel">キャンセル</string>
    <string name="CannotPayAlert">購入が制限されています。iPhone・iPadの設定をご変更ください。</string>
    <string name="CannotRestoreAlert">購入記録が確認できませんでした。購入時と同じiTunesのアカウントでログインしているかをご確認ください。</string>
    <string name="CannotRestoreAlertAndroid">購入記録が確認できませんでした。インターネットに接続されているか、購入時と同じGoogle Playのアカウントでログインしているかをご確認ください。</string>
    <string name="ChangeConfirmation">本当に変更してもよろしいですか？</string>
    <string name="ClusteringSection">クラスタリング</string>
    <string name="CompressionSection">データ圧縮</string>
    <string name="Config">設定</string>
    <string name="DataStructureSection">データ構造</string>
    <string name="DepthFirstSearch">深さ優先探索</string>
    <string name="DepthFirstSearch0">深さ優先探索はグラフを探索するアルゴリズムです。</string>
    <string name="DepthFirstSearch1">Ａを始点、Ｇをゴールとして探索を開始します。</string>
    <string name="DepthFirstSearch11">候補のうち、最も新しく追加されたのは点ＥとＦです。そのうち左側のＥを選択します。</string>
    <string name="DepthFirstSearch12">選択した点に移動します。</string>
    <string name="DepthFirstSearch13">現在いるＥからたどることのできるＫを新たに候補に追加します。</string>
    <string name="DepthFirstSearch14">以下、同様の操作をゴールにたどり着くか、全ての点を探索し終えるまで繰り返します。</string>
    <string name="DepthFirstSearch2">Ａからたどることのできる点ＢＣＤを、次に進む点の候補とします。</string>
    <string name="DepthFirstSearch28">ゴールに到達したので、探索を終えます。</string>
    <string name="DepthFirstSearch29">このように、深さ優先探索はひとつの路をより深く掘り下げながら探索をおこなっていく特徴があります。</string>
    <string name="DepthFirstSearch3">候補の中からひとつの点を選択します。選択の基準は、候補のうち、最も新しく候補に追加されたものを選択します。</string>
    <string name="DepthFirstSearch30">これで「深さ優先探索」の解説を終わります。</string>
    <string name="DepthFirstSearch4">同じタイミングで候補となった点は、どれを選択してもかまいません。今回は便宜上、左側にある点から選択することとします。</string>
    <string name="DepthFirstSearch5">今回の場合、全て同じタイミングで候補となったので、Ｂを選択します。</string>
    <string name="DepthFirstSearch6">選択した点に移動します。</string>
    <string name="DepthFirstSearch7">現在いるＢからたどることのできるＥとＦを新たに候補に追加します。</string>
    <string name="DepthFirstSearch8">候補の点は「後入れ先出し(LIFO)」の仕組みで管理するので、「スタック」のデータ構造を用いることができます。</string>
    <string name="DepthFirstSearch9">「スタック」については本アプリで詳しく解説しています。</string>
    <string name="DiffieHellman">Diffie-Hellman鍵交換法</string>
    <string name="DiffieHellman0">「Diffie-Hellman鍵交換法」は、２者間で安全に鍵を交換する手法です。</string>
    <string name="DiffieHellman1">数式を使っての解説の前に、図を使っての概念的な理解からはじめましょう。</string>
    <string name="DiffieHellman10">新たな鍵を合成するための要素にすることができます。</string>
    <string name="DiffieHellman11">図の例では、鍵Pと鍵P-Sを用いることで、新たな鍵P-P-Sが合成されました。</string>
    <string name="DiffieHellman12">つまり、合成された鍵は、さらに合成できるということです。</string>
    <string name="DiffieHellman13">この合成方法を使って、ＡさんとＢさんの間で鍵を安全に交換してみましょう。</string>
    <string name="DiffieHellman14">まず、Ａさんが鍵Pを用意します。この鍵Pは、誰に知られても問題ありません。</string>
    <string name="DiffieHellman15">Ａさんが、鍵PをＢさんに送ります。</string>
    <string name="DiffieHellman16">次に、ＡさんとＢさんそれぞれが、秘密の鍵SAと鍵SBを用意します。</string>
    <string name="DiffieHellman17">鍵SAと鍵SBは、人に知られないように管理する必要があります。</string>
    <string name="DiffieHellman18">Ａさんは、鍵Pと秘密の鍵SAから新たな鍵P-SAを合成します。</string>
    <string name="DiffieHellman19">同様に、Ｂさんも、鍵Pと秘密の鍵SBから新たな鍵P-SBを合成します。</string>
    <string name="DiffieHellman2">２つの鍵を合成する、特別な方法があるとします。</string>
    <string name="DiffieHellman20">ＡさんがＢさんに、鍵P-SAを送ります。</string>
    <string name="DiffieHellman21">同様に、ＢさんもＡさんに、鍵P-SBを送ります。</string>
    <string name="DiffieHellman22">Ａさんは、秘密の鍵SAと、Ｂさんから受け取った鍵P-SBを合成し、新たな鍵P-SA-SBを得ます。</string>
    <string name="DiffieHellman23">同様に、Ｂさんも、秘密の鍵SBと、Ａさんから受け取った鍵P-SAを合成し、新たな鍵P-SA-SBを得ます。</string>
    <string name="DiffieHellman24">これで、ＡさんとＢさんともに、鍵P-SA-SBを得ることができました。</string>
    <string name="DiffieHellman25">この鍵を暗号鍵・復号鍵として使うことになります。</string>
    <string name="DiffieHellman26">この鍵交換法の安全性を検証してみましょう。</string>
    <string name="DiffieHellman27">鍵P、鍵P-SA、鍵P-SBはインターネット経由で送信されるため…</string>
    <string name="DiffieHellman28">悪意のある第三者Ｘさんに盗み見される可能性があります。</string>
    <string name="DiffieHellman29">しかし、Ｘさんが得られる鍵からは、鍵P-SA-SBを合成することはできません。</string>
    <string name="DiffieHellman3">その合成方法で、鍵Ｐと鍵Ｓを合成すると…</string>
    <string name="DiffieHellman30">また、鍵は分解することができないため、秘密の鍵SA、鍵SBを得ることもできません。</string>
    <string name="DiffieHellman31">よって、Ｘさんは鍵P-SA-SBを作り出すことはできず、この鍵交換法は安全ということになります。</string>
    <string name="DiffieHellman32">次に、この鍵交換法を数式で表してみましょう。</string>
    <string name="DiffieHellman33">まず、mod演算について解説します。</string>
    <string name="DiffieHellman34">mod演算は、割り算の余りを求める演算です。</string>
    <string name="DiffieHellman35">Ａ mod Ｂ は、ＡをＢで割った時の余りＣを示します。</string>
    <string name="DiffieHellman36">具体的な数字を使った演算例を示します。</string>
    <string name="DiffieHellman37">それでは、鍵交換法を数式で考えてみましょう。</string>
    <string name="DiffieHellman38">最初に用意され、公開されてもよい鍵Pは、数式ではP、Gの２つの数字で表されます。</string>
    <string name="DiffieHellman39">Pは非常に大きな素数です。Gは素数Pの「生成元」(または「原始根」)と呼ばれる数からひとつ選びます。</string>
    <string name="DiffieHellman4">鍵Pと鍵Sの成分で構成される、新しい鍵P-Sが合成されます。</string>
    <string name="DiffieHellman40">素数Pの生成元は、すべての素数Pに対して一定数存在します。</string>
    <string name="DiffieHellman41">まず、Ａさんが素数Pと生成元Gを用意します。この数字は、誰に知られても問題ありません。</string>
    <string name="DiffieHellman42">Ａさんが、素数Pと生成元GをＢさんに送ります。</string>
    <string name="DiffieHellman43">次に、ＡさんとＢさんそれぞれが、秘密数XとYを用意します。</string>
    <string name="DiffieHellman44">なお、秘密数XとYは、素数P-2よりも小さい必要があります。</string>
    <string name="DiffieHellman45">ＡさんとＢさんはそれぞれ、(生成元Gの秘密数乗) mod 素数P を計算します。</string>
    <string name="DiffieHellman46">この計算が、概念上の合成にあたります。</string>
    <string name="DiffieHellman47">ＡさんとＢさんは、計算結果をお互いに送ります。</string>
    <string name="DiffieHellman48">ＡさんとＢさんは、相手から受け取った数を秘密数乗し、mod 素数P を計算します。</string>
    <string name="DiffieHellman49">この計算結果は、同じ値となります。</string>
    <string name="DiffieHellman5">この合成方法は２つの特徴があります。</string>
    <string name="DiffieHellman50">これで、ＡさんとＢさんは、暗号に使える鍵となる数字を共有することができました。</string>
    <string name="DiffieHellman51">この鍵交換法の安全性を検証してみましょう。</string>
    <string name="DiffieHellman52">それぞれの数字はインターネット経由で送信されるため…</string>
    <string name="DiffieHellman53">Ｘさんに盗み見される可能性があります。</string>
    <string name="DiffieHellman54">しかし、Ｘさんが得られる数字からは、ＡさんとＢさんで共有された数字を計算することができません。</string>
    <string name="DiffieHellman55">また、秘密数XやYを求めることもできません。</string>
    <string name="DiffieHellman56">一般的に、素数P、生成数G、GのX乗 mod P から、Xを求める方法は、「離散対数問題」と呼ばれ、まだ発見されていません。</string>
    <string name="DiffieHellman57">「Diffie-Hellman鍵交換法」は、この「離散対数問題」を利用した、鍵交換法と言えます。</string>
    <string name="DiffieHellman58">これで「Diffie-Hellman鍵交換法」の解説を終わります。</string>
    <string name="DiffieHellman6">１つ目に、鍵Pと、それを用いて合成された鍵P-Sがあったとしても…</string>
    <string name="DiffieHellman7">鍵Sを取り出すことは不可能という特徴です。</string>
    <string name="DiffieHellman8">つまり、鍵は合成することはできても、分解することはできません。</string>
    <string name="DiffieHellman9">２つ目に、何らかの鍵から合成された鍵も…</string>
    <string name="DiffieHellmanDescription">「Diffie-Hellman鍵交換法」は２者間で安全に鍵を交換する手法です。この項目は、全アルゴリズムのご購入後に学ぶことができます。</string>
    <string name="DigitalCertification">デジタル証明書</string>
    <string name="DigitalCertification0">公開鍵暗号方式やデジタル署名の仕組みは、公開鍵が誰のものか保証されない問題がありました。</string>
    <string name="DigitalCertification1">そのため、ＡさんがＢさんに公開鍵を送ろうとしていたときに…</string>
    <string name="DigitalCertification10">認証局は、自身で用意した公開鍵PCと秘密鍵SCを保有しています。</string>
    <string name="DigitalCertification11">Ａさんは、公開鍵PAとメールアドレスを含む個人情報を用意し…</string>
    <string name="DigitalCertification12">認証局に送ります。</string>
    <string name="DigitalCertification13">確認が完了すると、認証局の秘密鍵SCを用いて、Ａさんのデータからデジタル署名を作成します。</string>
    <string name="DigitalCertification14">「デジタル署名」の仕組みは本アプリにて詳しく解説しています。</string>
    <string name="DigitalCertification15">そして、作成したデジタル署名とデータをひとつのファイルにし…</string>
    <string name="DigitalCertification16">Ａさんに送信します。</string>
    <string name="DigitalCertification17">このファイルが、Ａさんのデジタル証明書になります。</string>
    <string name="DigitalCertification18">ＡさんはＢさんに、公開鍵の代わりに、受け取った証明書を送ります。</string>
    <string name="DigitalCertification19">Ｂさんは、受け取った証明書に書かれているメールアドレスがＡさんのものであることを確認します。</string>
    <string name="DigitalCertification2">悪意のある第三者が、公開鍵をすり替えて渡しても、受け取る側は気付くことができませんでした。</string>
    <string name="DigitalCertification20">続いて、Ｂさんは認証局の公開鍵を取得し…</string>
    <string name="DigitalCertification21">証明書内の署名が、認証局のものであるかを検証します。</string>
    <string name="DigitalCertification22">証明書の署名は、認証局の公開鍵PCでしか検証できません。</string>
    <string name="DigitalCertification23">つまり、検証の結果に問題がなければ、この証明書はたしかに認証局が発行したものであることになります。</string>
    <string name="DigitalCertification24">証明書が認証局から発行されたＡさんのものであることが確認できたので、証明書からＡさんの公開鍵PAを取り出します。</string>
    <string name="DigitalCertification25">これで、ＡさんからＢさんへの公開鍵の受け渡しは完了となります。</string>
    <string name="DigitalCertification26">公開鍵の受け渡しに問題はないかを見てみましょう。</string>
    <string name="DigitalCertification27">悪意のあるＸさんが、Ａさんになりすまして、公開鍵を渡そうとしたとします。</string>
    <string name="DigitalCertification28">しかし、Ｂさんは証明書として渡されない公開鍵を信用する必要はありません。</string>
    <string name="DigitalCertification29">それでは、ＸさんがＡさんになりすまし、認証局に自分の公開鍵を登録しようとするとどうなるでしょうか。</string>
    <string name="DigitalCertification3">デジタル証明書の仕組みを用いると、公開鍵の作成者が誰なのかを保証することができます。</string>
    <string name="DigitalCertification30">その場合、ＸさんはＡさんのメールアドレスを所持していないので、証明書を発行してもらうことはできません。</string>
    <string name="DigitalCertification31">Ｘさんは、Ｘさんのメールアドレスを利用した証明書しか作れないことになります。そのため、Ａさんの証明書を手に入れることはできません。</string>
    <string name="DigitalCertification32">デジタル証明書の仕組みによって、公開鍵の作成者が確認できることが分かりました。</string>
    <string name="DigitalCertification33">さて、先ほど、Ｂさんは認証局の公開鍵を取得したと言いましたが…</string>
    <string name="DigitalCertification34">ここでひとつの疑問が浮かびます。</string>
    <string name="DigitalCertification35">Ｂさんが取得した公開鍵PCは、本当に認証局が作成したものでしょうか。</string>
    <string name="DigitalCertification36">公開鍵自体には、作成者を確認する手段がないため、認証局になりすましたＸさんが作成したものかもしれません。</string>
    <string name="DigitalCertification37">つまり、公開鍵に関する同じ問題がここでも起こることになります。</string>
    <string name="DigitalCertification38">実は、この認証局の公開鍵PCも…</string>
    <string name="DigitalCertification39">デジタル証明書として受け渡しされます。</string>
    <string name="DigitalCertification4">デジタル証明書の仕組みを、具体的に見ていきましょう。</string>
    <string name="DigitalCertification40">それでは、この認証局の証明書は、誰が署名したのかと言うと…</string>
    <string name="DigitalCertification41">より上位の認証局です。</string>
    <string name="DigitalCertification42">認証局は木構造になっており、上位の認証局が下位の認証局の証明書を作成しています。</string>
    <string name="DigitalCertification43">どのようにして認証局の木構造ができるのかというと…</string>
    <string name="DigitalCertification44">例えば、社会的に広く信頼された認証局Ｙがあるとします。</string>
    <string name="DigitalCertification45">新たな会社Ｇが認証局のサービスを始めたいとしても、社会的な信用がありません。</string>
    <string name="DigitalCertification46">そこで、Ｇ社はＹ社にデジタル証明書を発行してもらいます。もちろん、Ｙ社はＧ社が認証局の業務を適切に行えるかをチェックします。</string>
    <string name="DigitalCertification48">この結果、Ｇ社はＹ社の信頼を得た会社であることをアピールすることができます。</string>
    <string name="DigitalCertification49">このようにして、より大きい組織が、小さい組織の信頼を担保する形で、木構造が構成されています。</string>
    <string name="DigitalCertification5">Ａさんは、公開鍵PAと秘密鍵SAのペアを持っており…</string>
    <string name="DigitalCertification50">では、認証局の木構造の最上位はどうなっているのでしょうか…</string>
    <string name="DigitalCertification51">最上位に位置する認証局は「ルート認証局(ルートCA)」と呼ばれ、自分の正当性を自ら証明することになります。</string>
    <string name="DigitalCertification52">なお、ルート認証局が、自らを認証する証明書は「ルート証明書」と呼ばれます。</string>
    <string name="DigitalCertification53">ルート認証局は、組織自体が信頼されるものでないと利用されません。</string>
    <string name="DigitalCertification54">そのため、大企業や政府関連組織など、すでに社会的な信頼のある組織が多いです。</string>
    <string name="DigitalCertification55">さて、これまで個人間における公開鍵の受け渡しについてみてきましたが…</string>
    <string name="DigitalCertification56">ウェブサイトと通信を行う際にも、デジタル証明書が利用されます。</string>
    <string name="DigitalCertification57">ウェブサイトから、公開鍵がついた証明書を受け取ることで、そのサイトが第三者によって、なりすましされていないことが確認できます。</string>
    <string name="DigitalCertification58">この証明書は「サーバ証明書」と呼ばれるもので、同じく認証局によって発行されます。</string>
    <string name="DigitalCertification59">個人の場合、証明書はメールアドレスに紐づきますが…</string>
    <string name="DigitalCertification6">公開鍵PAを、Ｂさんに送ろうとしているとします。</string>
    <string name="DigitalCertification60">サーバ証明書の場合は、ドメインに紐付きます。</string>
    <string name="DigitalCertification61">サーバ証明書は、公開鍵が証明書に紐づくドメインを管理する組織が発行したものであることを保証します。</string>
    <string name="DigitalCertification62">つまり、ウェブサイトのドメインを管理している組織と、ウェブサイトの中身を収めたサーバを管理している組織が同じであることを確認することができます。</string>
    <string name="DigitalCertification63">このように、デジタル証明書は認証局を介することによって公開鍵の作成者を保証する社会的な仕組みです。</string>
    <string name="DigitalCertification64">これで「デジタル証明書」の解説を終わります。</string>
    <string name="DigitalCertification7">Ａさんはまず、認証局(Certification Authority)に、公開鍵PAが自分のものであることを示す証明書の発行を依頼する必要があります。</string>
    <string name="DigitalCertification8">認証局は、デジタル証明書の管理をする組織です。基本的には誰でもなることができ、数多く存在します。</string>
    <string name="DigitalCertification9">そのため、政府や監査を受けた大企業など、信頼できる組織を利用するのが安全です。</string>
    <string name="DigitalCertificationDescription">「デジタル証明書」は公開鍵の作成者を保証するための仕組みです。この項目は、全アルゴリズムのご購入後に学ぶことができます。</string>
    <string name="DigitalSignature">デジタル署名</string>
    <string name="DigitalSignature0">「デジタル署名」は、「メッセージ認証コード」が実現する「認証」と「改竄の検出」の２つの機能に加え…</string>
    <string name="DigitalSignature1">「否認防止」も保証する仕組みです。</string>
    <string name="DigitalSignature10">たとえばＡさんが、Ｂさんにメッセージを送った後で、そのメッセージはＢさんが勝手に作成したものだと言い張ることがでてきしまいます。</string>
    <string name="DigitalSignature100">なお、厳密には署名の作成は「暗号化」とは異なる計算方法である場合もあります。</string>
    <string name="DigitalSignature101">しかし、署名の作成には秘密鍵を使い、署名の検証では公開鍵を使うという点では共通なので、ここでは便宜上そのように説明しています。</string>
    <string name="DigitalSignature11">また、共通鍵を利用しているため、ＡさんがＢさん以外の人にメッセージを送る際には、異なる鍵を用意する必要があります。</string>
    <string name="DigitalSignature12">一方、デジタル署名の仕組みでは、MACではなく、送信者にしか作成できないデータを特定の根拠に用います。このデータのことを「デジタル署名」と呼びます。</string>
    <string name="DigitalSignature13">仕組みの概要を見てみましょう。</string>
    <string name="DigitalSignature14">図の「Sig.」と書かれたデジタル署名は、Ａさんにしか作成できないようになっています。</string>
    <string name="DigitalSignature15">そのため、Ａさんのデジタル署名が付与されたメッセージが送られてきた場合、その送信者がＡさんあることが、保証されます。</string>
    <string name="DigitalSignature16">メッセージを受け取ったＢさんは、デジタル署名がＡさんのものであることを確認することができますが、同じデジタル署名を作成することはできません。</string>
    <string name="DigitalSignature17">メッセージ認証コードとは異なり、共通鍵を利用しないため、同じデジタル署名を用いて、Ａさんは複数の人にメッセージを送ることができます。</string>
    <string name="DigitalSignature2">「メッセージ認証コード」をおさらいしましょう。</string>
    <string name="DigitalSignature20">デジタル署名の作成方法を具体的に見ていきましょう。</string>
    <string name="DigitalSignature21">メッセージ認証コードでは、MACの作成に用いる鍵が共通のものでしたが…</string>
    <string name="DigitalSignature22">デジタル署名の作成には、「公開鍵暗号方式」の手順を応用します。</string>
    <string name="DigitalSignature23">「公開鍵暗号方式」は本アプリで詳しく解説しています。ここでは大まかな流れをおさらいしてみましょう。</string>
    <string name="DigitalSignature24">Ａさんが、Ｂさんにデータを暗号化したうえで送ろうとしています。</string>
    <string name="DigitalSignature25">まず、データの受け取り側であるＢさんが、公開鍵(P)と秘密鍵(S)を用意します。</string>
    <string name="DigitalSignature26">ＢさんがＡさんに、公開鍵を渡します。</string>
    <string name="DigitalSignature27">Ａさんは受け取った公開鍵を使って、データを暗号化します。</string>
    <string name="DigitalSignature28">暗号文を、Ｂさんに送ります。</string>
    <string name="DigitalSignature29">Ｂさんは受け取った暗号文を、秘密鍵を使って、元のデータに復号します。これでやりとりは完了です。</string>
    <string name="DigitalSignature3">メッセージ認証コードとは、メッセージに「MAC」を付与することで、メッセージの送信者が鍵の所有者であることを特定する仕組みです。</string>
    <string name="DigitalSignature30">さて、公開鍵暗号方式では、暗号化に公開鍵、復号に秘密鍵を使いました。</string>
    <string name="DigitalSignature31">そのため、公開鍵を使って、誰でもデータを暗号化することができますが…</string>
    <string name="DigitalSignature32">秘密鍵はＢさんしか持ってないため、Ｂさんしか復号できないことが保証されていました。</string>
    <string name="DigitalSignature33">では、この流れを逆にして、秘密鍵で暗号化し、公開鍵で復号すると、どうなるでしょうか。</string>
    <string name="DigitalSignature34">この場合には、秘密鍵を持つＡさんしか暗号化できないが、公開鍵を使って誰でも復号できる暗号文が作成されます。</string>
    <string name="DigitalSignature35">暗号としては全く意味をなしませんが、見方を変えれば、この暗号文の作成者が、秘密鍵を持つＡさんであることが保証されていることになります。</string>
    <string name="DigitalSignature36">「デジタル署名」では、このＡさんしか作れない暗号文を「署名」として活用します。</string>
    <string name="DigitalSignature37">「デジタル署名」を利用したメッセージのやりとりの流れを見ていきましょう。</string>
    <string name="DigitalSignature38">まず、Ａさんが送信したいメッセージと、秘密鍵・公開鍵を用意します。</string>
    <string name="DigitalSignature39">メッセージの送信側が秘密鍵と公開鍵を用意する点が、公開鍵暗号方式とは異なります。</string>
    <string name="DigitalSignature4">ここでは、便宜上メッセージは暗号化せずに送ることにします。</string>
    <string name="DigitalSignature40">ＡさんがＢさんに、公開鍵を渡します。</string>
    <string name="DigitalSignature41">秘密鍵を使って、メッセージを暗号化します。</string>
    <string name="DigitalSignature42">このメッセージを暗号化したものを署名として扱います。以降、図では「Sig.」と示します。</string>
    <string name="DigitalSignature43">メッセージと署名を、Ｂさんに送信します。</string>
    <string name="DigitalSignature44">Ｂさんは公開鍵を使って、暗号文を復号します。</string>
    <string name="DigitalSignature45">復号したメッセージと、受け取っていたメッセージとが一致することを確認します。これでやり取りは完了です。</string>
    <string name="DigitalSignature46">Ａさんの公開鍵で復号できる暗号文は、Ａさん本人にしか作れないものです。</string>
    <string name="DigitalSignature47">そのため、メッセージを送信したのがＡさんであることと、メッセージが改竄されていないことが確認できます。</string>
    <string name="DigitalSignature48">また、Ａさんの署名は、公開鍵しか持たないＢさんには作成できないため、否認防止の役割も果たします。</string>
    <string name="DigitalSignature49">ただし、公開鍵暗号方式は、暗号化にも復号にも時間がかかる傾向にあります。</string>
    <string name="DigitalSignature5">Ａさんは、メッセージとMAC、および、MAC作成に使用した鍵をＢさんに送信します。</string>
    <string name="DigitalSignature50">そのため、実際はメッセージを直接暗号化するのではなく…</string>
    <string name="DigitalSignature51">計算時間短縮のため、まずはメッセージのハッシュ値を求め…</string>
    <string name="DigitalSignature52">そのハッシュ値を暗号化して署名に用います。</string>
    <string name="DigitalSignature53">なお、ハッシュ化については、本アプリの「ハッシュ関数」にて詳しく解説しています。</string>
    <string name="DigitalSignature54">メッセージと署名を、Ｂさんに送信します。</string>
    <string name="DigitalSignature55">Ｂさんも同様に、受け取ったメッセージのハッシュ値を求めます。</string>
    <string name="DigitalSignature56">次に、受け取った署名を公開鍵で復号し、ハッシュ値を求めます。</string>
    <string name="DigitalSignature57">求めた２つのハッシュ値が同じであることが確認できれば、デジタル署名を用いたやりとりは完了です。</string>
    <string name="DigitalSignature58">「認証」「改竄の検出」「否認防止」の機能を備えるデジタル署名ですが、ひとつ問題があります。</string>
    <string name="DigitalSignature59">Ｂさんは、デジタル署名を用いたやりとりを通して、メッセージの送信者がＡさんだと信じていますが…</string>
    <string name="DigitalSignature6">Ｂさんは、受け取ったメッセージと鍵からMACを作成し直し、それが受け取ったMACと同じものであることを確認します。</string>
    <string name="DigitalSignature60">実際には、Ａさんを騙る悪意のあるＸさんとやりとりをしていた可能性はゼロとは言えません。</string>
    <string name="DigitalSignature61">その根本的な原因は、公開鍵暗号方式においては、公開鍵が誰のものであるのかが分からないことにあります。</string>
    <string name="DigitalSignature62">受け取った公開鍵には、作成者を示す情報が一切含まれていません。</string>
    <string name="DigitalSignature63">そのため、Ａさんを騙る誰かが作成した公開鍵である可能性も…</string>
    <string name="DigitalSignature64">本当にＡさんが作成した公開鍵である可能性もあり、はっきりとしません。</string>
    <string name="DigitalSignature66">この問題は「デジタル証明書」の仕組みで解決することができます。</string>
    <string name="DigitalSignature67">「デジタル証明書」においては、公開鍵にその作成者の情報を付けたものを、ひとつの証明書として扱います。</string>
    <string name="DigitalSignature68">「デジタル証明書」については、本アプリで詳しく解説しています。</string>
    <string name="DigitalSignature69">これで「デジタル署名」の解説を終わります。</string>
    <string name="DigitalSignature8">これにより、送信者がＡさんであることと、受け取ったメッセージが改竄されていないことが確認できます。</string>
    <string name="DigitalSignature9">しかし、メッセージ認証コードは、共通鍵を用いる仕組みであるため、鍵を持つ誰もがメッセージの送信者となる可能性が残ってしまいます。</string>
    <string name="DigitalSignatureDescription">「デジタル署名」は、なりすまし・改ざん・事後否認に対する解決となる仕組みです。この項目は、全アルゴリズムのご購入後に学ぶことができます。</string>
    <string name="Dijkstra">ダイクストラ法</string>
    <string name="Dijkstra0">ダイクストラ法はグラフの最短路を求めるアルゴリズムです。ベルマンフォード法より効率が良い方法です。</string>
    <string name="Dijkstra1">はじめに各点のコストの初期値を設定します。始点は０、それ以外の点は無限大に設定します。</string>
    <string name="Dijkstra10">最短路が決定した点Ｂに移動します。</string>
    <string name="Dijkstra100">なぜなら、他の経路を使う場合には必ず点Ｃを経由する必要があり、その結果、現状の経路よりもコストが高くなるからです。</string>
    <string name="Dijkstra101">経路Ａ−Ｂ−Ｄは、候補の点の中で最もコストが低いものを選択した結果の経路です。そのため、他の点を経由してＤに行くと、コストは必ず今より高くなることがわかります。</string>
    <string name="Dijkstra102">この場合、点Ｂと点Ｃが候補となります。</string>
    <string name="Dijkstra11">現在いる点から辿れる点を新たに候補に追加します。この場合、点Ｃ、Ｄ、Ｅになります。</string>
    <string name="Dijkstra12">さきほどと同様の計算方法で、候補の各点のコストを計算します。</string>
    <string name="Dijkstra13">点Ｂから辿った場合の点Ｃのコストは２＋６で８となりますが、現状の５の値の方が小さいので更新しません。</string>
    <string name="Dijkstra14">残りの点ＤとＥのコストを更新しました。</string>
    <string name="Dijkstra15">候補の点の中から、コストが最も小さい点を選択します。この場合、点Ｄになります。</string>
    <string name="Dijkstra16">この時点で、選択した点Ｄへの経路Ａ−Ｂ−Ｄが、始点から点Ｄにいく最短路として決定しました。</string>
    <string name="Dijkstra17">このように、ダイクストラ法は各点への最短路をひとつずつ決定していきながらグラフを探索するアルゴリズムです。</string>
    <string name="Dijkstra18">同様の操作を終点Ｇに辿り着くまで繰り返します。</string>
    <string name="Dijkstra2">始点からスタートします。</string>
    <string name="Dijkstra3">現在いる点から辿ることのできる探索済みでない点を探します。見つけた点は次に辿る候補にします。</string>
    <string name="Dijkstra35">終点Ｇに辿り着いたので、探索を終わります。</string>
    <string name="Dijkstra36">最終的にできたオレンジ色の木を最短路木といい、各点への最短路を表しています。</string>
    <string name="Dijkstra37">太く強調されているのは終点Ｇまでの最短路です。</string>
    <string name="Dijkstra38">このように、コストの計算と更新を全辺に対して繰り返すベルマンフォード法と比べ、ダイクストラ法は選ぶ点を工夫することで効率よく最短路を求めています。</string>
    <string name="Dijkstra39">ダイクストラ法はベルマンフォード法と同様、往路と復路でコストが異なる辺や、一方通行の辺が存在していても…</string>
    <string name="Dijkstra4">候補の各点のコストを計算します。計算方法は、「現状いる点のコスト＋候補の点に辿るコスト」になります。</string>
    <string name="Dijkstra40">最短路を正しく求めることができます。</string>
    <string name="Dijkstra41">なお、図のような、辺に向きが設定されているグラフを「有向グラフ」、また向きが設定されていないグラフは「無向グラフ」と言います。</string>
    <string name="Dijkstra42">ダイクストラ法は「負のコスト」を含む場合には、最短路が正しく求まらないことがあります。この点は、ベルマンフォード法とは異なります。</string>
    <string name="Dijkstra43">上のグラフでは、負のコストのあるＣ−Ｂを通る、Ａ−Ｃ−Ｂ−Ｇ(コスト２)が正しい最短路となっています。</string>
    <string name="Dijkstra44">試しに、ダイクストラ法で解いてみましょう。</string>
    <string name="Dijkstra45">始点Ａから辿ることのできる探索済みでない点はＢとＣであり、それぞれの点のコストは、２と４になります。</string>
    <string name="Dijkstra46">この時点でダイクストラ法は、経路Ａ−Ｂが始点Ａから点Ｂにいく最短路と決定します。</string>
    <string name="Dijkstra47">その理由は、「他の経路を使う場合には必ず点Ｃを経由する必要があるが、Ａ−Ｃのコストは、Ａ−Ｂのコストよりも大きい」というものです。</string>
    <string name="Dijkstra48">すでにお分かりの通り、これは全ての辺のコストが０より大きい、つまり、グラフ上に負のコストが存在しないことが前提となっています。</string>
    <string name="Dijkstra49">アルゴリズムは、始点Ａから終点Ｇへの最短路がＡ−Ｂ−Ｇであり、そのコストは３であると結論付けました。前述の通り、この結果は誤りです。</string>
    <string name="Dijkstra5">例えば、点Ｂの場合、始点のコストが０なので、０＋２で２となります。同様にＣのコストは０＋５で５となります。</string>
    <string name="Dijkstra52">なお、上のグラフのような…</string>
    <string name="Dijkstra53">特定の経路を回るコストがマイナスとなる「負の閉路」を含むグラフの場合…</string>
    <string name="Dijkstra54">ダイクストラ法では、最短路が存在しないにも関わらず、誤った最短路を解として導きだします。</string>
    <string name="Dijkstra55">このように、ダイクストラ法は負のコストを含むグラフには使用することができません。</string>
    <string name="Dijkstra56">逆に、ダイクストラ法は、グラフに負のコストが存在しない場合には、ベルマンフォード法よりもより少ない計算量で、最短路を求められるアルゴリズムと言えます。</string>
    <string name="Dijkstra57">これで「ダイクストラ法」の解説を終わります。</string>
    <string name="Dijkstra6">計算した結果が、現状の値より小さければコストを新しい値で更新します。</string>
    <string name="Dijkstra7">点Ｂ、Ｃの現在のコストは無限大であり、計算した結果の方が小さいため、それぞれ新しい値で更新しました。</string>
    <string name="Dijkstra8">候補の点の中から、コストが最も小さい点を選択します。この場合は点Ｂになります。</string>
    <string name="Dijkstra9">この時点で、選択した点Ｂへの経路Ａ−Ｂが、始点から点Ｂにいく最短路として決定しました。</string>
    <string name="DijkstraDescription">「ダイクストラ法」は最短経路を効率的に導くアルゴリズムです。この項目は、全アルゴリズムのご購入後に学ぶことができます。</string>
    <string name="Euclidean">ユークリッドの互除法</string>
    <string name="Euclidean0">「ユークリッドの互除法」は、２数の最大公約数を求めるアルゴリズムです。</string>
    <string name="Euclidean1">ユークリッドによって紀元前300年代に発見され、世界最古のアルゴリズムと呼ばれています。</string>
    <string name="Euclidean10">Ａ mod Ｂ は、ＡをＢで割った時の余りＣを示します。</string>
    <string name="Euclidean11">具体的な数字を使った演算例を示します。</string>
    <string name="Euclidean12">それでは、ユークリッドの互除法の流れを見てみましょう。</string>
    <string name="Euclidean13">まず、大きな方の数字を、小さな方の数字で割った余りを求めます。</string>
    <string name="Euclidean14">つまり、大きな方の数字と、小さな方の数字でmod演算を行います。</string>
    <string name="Euclidean15">割り算の結果、余りとして417が求まりました。</string>
    <string name="Euclidean16">今度は、割った数695と余りの417でmod演算を行います。</string>
    <string name="Euclidean17">278が求まりました。</string>
    <string name="Euclidean18">同様の操作を繰り返します。417と278でmod演算を行います。</string>
    <string name="Euclidean19">139が求まりました。</string>
    <string name="Euclidean2">例として、1112と695の最大公約数を考えてみましょう。</string>
    <string name="Euclidean20">278と139でmod演算を行います。</string>
    <string name="Euclidean21">０が求まりました。</string>
    <string name="Euclidean22">つまり、278は139で割り切れるということです。</string>
    <string name="Euclidean23">この余りが0になったとき、最後の演算の割る数の139が、1112と695の最大公約数となります。</string>
    <string name="Euclidean24">なぜ、ユークリッドの互除法で最大公約数が求まるのでしょうか。図を使って考えてみましょう。</string>
    <string name="Euclidean25">1112と695を、それぞれ棒の長さで表してみます。</string>
    <string name="Euclidean26">最大公約数をｎとして、目盛りを刻みました。</string>
    <string name="Euclidean27">最大公約数は139と判明しているので、便宜上、1112は８目盛り、695は５目盛り刻みました。</string>
    <string name="Euclidean28">実際には、それぞれの棒が何目盛り分であるのかは分かっていません。</string>
    <string name="Euclidean29">ただし、1112も695も最大公約数ｎの倍数であることは分かっています。</string>
    <string name="Euclidean3">通常の方法では、２つの数を素因数分解し…</string>
    <string name="Euclidean30">ここで、先ほどの演算と同じように、大きい方の数から小さい方の数を割った余りを求めます。</string>
    <string name="Euclidean31">417が求まりました。図より417も幅ｎの目盛りできっちりと刻むことのできる数だと分かります。</string>
    <string name="Euclidean32">さきほどと同様にmod演算を繰返していきます。</string>
    <string name="Euclidean35">695を417で割ると、余りの278が求まります。</string>
    <string name="Euclidean36">この余りの278も、ｎの整数倍の数、つまり、同じ最大公約数を持ちます。</string>
    <string name="Euclidean37">さらに割り算を繰り返します。</string>
    <string name="Euclidean38">278は139で割り切れるため、余りは０となりました。</string>
    <string name="Euclidean39">このとき、最大公約数のｎが139であることが分かります。</string>
    <string name="Euclidean4">共通する素数から、最大公約数(GCD)を求めます。</string>
    <string name="Euclidean40">このように、ユークリッドの互除法は、割り算を繰り返すだけで、最大公約数を求めることができます。</string>
    <string name="Euclidean41">対象の２数が巨大な数であっても、決まった手順で最大公約数を求められることが、大きな利点です。</string>
    <string name="Euclidean42">これで「ユークリッドの互除法」の解説を終わります。</string>
    <string name="Euclidean5">1112と695の最大公約数的は、139だと分かりました。</string>
    <string name="Euclidean6">しかし、この方法では、２つの数が大きくなるほど素因数分解が困難になります。</string>
    <string name="Euclidean7">ユークリッドの互除法では、より効率的に最大公約数を求めることができます。</string>
    <string name="Euclidean8">ユークリッドの互除法の解説に入る前に、mod演算について解説します。</string>
    <string name="Euclidean9">mod演算は、割り算の余りを求める演算です。</string>
    <string name="ExperimentalModeTitle">実験</string>
    <string name="FewUnique">Few Unique</string>
    <string name="GetItemInfoFailed">アイテム情報の取得に失敗しました。インターネットに接続されているかをご確認ください。</string>
    <string name="GraphSearchSection">グラフ探索</string>
    <string name="Hanoi">ハノイの塔</string>
    <string name="Hanoi0">「ハノイの塔」は円盤を移動させるパズルです。</string>
    <string name="Hanoi1">図は、ABCの３本の杭があり、Ａの杭に２枚の円盤が刺さっている状態を表しています。</string>
    <string name="Hanoi101">以上の条件をふまえて、実際に動かす例を見ていきましょう。</string>
    <string name="Hanoi102">さきほどと同じ要領で、Ｂの２枚をＣに移動させます。</string>
    <string name="Hanoi15">小さな円盤は、一番上にあるので、Ｂに移動できます。</string>
    <string name="Hanoi16">大きな円盤をＣに移動します。</string>
    <string name="Hanoi17">小さな円盤をＣに移動し、移動が完了しました。円盤が２つの場合、ゴールに到達できることが確認できました。</string>
    <string name="Hanoi18">円盤が３つの場合はどうなるでしょうか。</string>
    <string name="Hanoi19">一番大きな円盤を無視し、残りの円盤をＢに移すことを考えます。</string>
    <string name="Hanoi2">Ａの円盤を、順番を保ったままＣに移動させることができるとゴールです。</string>
    <string name="Hanoi20">残りの円盤は、さきほど２枚の円盤を移動させたのと同じ要領で動かせば、Ｂに移動できます。</string>
    <string name="Hanoi21">一番大きな円盤をＣに移動します。</string>
    <string name="Hanoi22">移動が完了しました。円盤が３つの場合でも、ゴールに到達できることが確認できました。</string>
    <string name="Hanoi23">実は、このゲームは円盤が何枚の場合でも、ゴールに到達することができます。</string>
    <string name="Hanoi24">このことを数学的帰納法を使って証明してみましょう。</string>
    <string name="Hanoi25">円盤が１枚のとき、ゴールに到達できました。</string>
    <string name="Hanoi27">円盤がｎ枚のときゴールに到達できると仮定します。</string>
    <string name="Hanoi29">n+1枚を移動させることを考えます。</string>
    <string name="Hanoi30">一番大きい円盤を無視します。</string>
    <string name="Hanoi31">仮定よりｎ枚なら移動できるので、ｎ枚をＢに移動させます。</string>
    <string name="Hanoi32">一番大きい円盤をＣに移動させます。</string>
    <string name="Hanoi33">Ｂにあるｎ枚をＣに移動させます。これで移動が完了しました。</string>
    <string name="Hanoi34">数学的帰納法により、円盤が何枚の場合でもゴールに到達できることが証明されました。</string>
    <string name="Hanoi35">ハノイの塔の解法について考えてみましょう。</string>
    <string name="Hanoi36">ｎ枚の円盤のハノイの塔を解く場合には、n-1枚のハノイの塔の解き方を利用すればよいことになります。</string>
    <string name="Hanoi37">そのn-1枚のハノイの塔を解くには、n-2枚のハノイの塔の解き方を利用することになり、最終的に１枚の円盤の状態まで、再帰的に解法を導くことができます。</string>
    <string name="Hanoi38">この再帰的な考え方はさまざまなアルゴリズムで利用されており、それらを再帰的アルゴリズムといいます。</string>
    <string name="Hanoi39">これで「ハノイの塔」の解説を終わります。</string>
    <string name="Hanoi4">円盤の移動には２つ条件があります。１つ目の条件として、１度に１枚の円盤しか移動できません。</string>
    <string name="Hanoi5">このように１枚動かすのは問題ありませんが…</string>
    <string name="Hanoi6">図のように２枚を同時に動かしてはいけません。</string>
    <string name="Hanoi9">２つ目の条件として、小さな円盤の上にそれより大きな円盤を置くことはできません。</string>
    <string name="Hash">ハッシュテーブル</string>
    <string name="Hash0">「ハッシュテーブル」は、データ構造のひとつです。</string>
    <string name="Hash1">KeyとValueのセットからなるデータの格納を得意とします。</string>
    <string name="Hash10">２番の箱も、Allyではありませんでした。</string>
    <string name="Hash11">３番の箱も、Allyではありませんでした。</string>
    <string name="Hash12">４番の箱に格納されたデータのKeyがAllyと一致しました。</string>
    <string name="Hash13">対応するValueを取り出すことで、Allyの性別が女性(Ｆ)であることが分かりました。</string>
    <string name="Hash14">このように、線形探索の操作は、データの量に比例してコストが掛かってしまいます。</string>
    <string name="Hash15">配列への格納は、データの探索に時間が掛かり、不向きであることが分かりました。</string>
    <string name="Hash16">この問題を解決するのがハッシュテーブルです。</string>
    <string name="Hash17">データを格納するための配列を用意します。ここでは便宜上、配列として５つの箱を用意しました。</string>
    <string name="Hash18">それでは、データを格納していきましょう。</string>
    <string name="Hash19">Joeのデータを格納するにあたり…</string>
    <string name="Hash2">ここでは、名前がKeyであり、性別がValueです。</string>
    <string name="Hash20">「ハッシュ関数」を用いて、Keyのハッシュ値を計算します。ここでは、4928が求まりました。</string>
    <string name="Hash21">「ハッシュ関数」は本アプリにて詳しく説明していますが、データを固定長の数値に変換する関数です。</string>
    <string name="Hash22">求めたハッシュ値を、配列の箱の数である５で割り算し、その余りを求めます。</string>
    <string name="Hash23">割り算の余りを求める演算を、mod演算と呼びます。</string>
    <string name="Hash24">mod演算の結果、３という数値が求まりました。</string>
    <string name="Hash25">求まった数と同じである配列の３番の箱に、Joeのデータを格納します。</string>
    <string name="Hash26">この操作を繰り返して、他のデータも格納していきます。</string>
    <string name="Hash27">Sueのデータを格納するにあたり…</string>
    <string name="Hash28">Keyのハッシュ値を求め、配列の箱の数５でmod演算を行います。結果は１でした。</string>
    <string name="Hash29">配列の１番の箱に、Sueのデータを格納します。</string>
    <string name="Hash3">例えば、図のデータを「配列」に格納することを考えましょう。</string>
    <string name="Hash30">Danのデータを格納するにあたり…</string>
    <string name="Hash31">Keyのハッシュ値を求め、配列の箱の数５でmod演算を行います。結果は４でした。</string>
    <string name="Hash32">配列の４番の箱に、Danのデータを格納します。</string>
    <string name="Hash33">Nellのデータを格納するにあたり…</string>
    <string name="Hash34">Keyのハッシュ値を求め、配列の箱の数５でmod演算を行います。結果は１でした。</string>
    <string name="Hash35">配列の１番の箱に、Nellのデータを格納しようとしたところ…</string>
    <string name="Hash36">すでにSueのデータが格納されていました。このような場合には…</string>
    <string name="Hash37">リストとして既存のデータに接続します。</string>
    <string name="Hash38">ハッシュテーブルの構造にはいくつか種類がありますが、リストを利用する方法を「チェイン法」と呼びます。</string>
    <string name="Hash39">Allyのデータを格納するにあたり…</string>
    <string name="Hash4">配列の６つの箱を用意し、データを格納しました。</string>
    <string name="Hash40">Keyのハッシュ値を求め、配列の箱の数５でmod演算を行います。結果は３でした。</string>
    <string name="Hash41">配列の３番の箱には、Joeのデータがあるため、Allyのデータをリストとして繋ぎます。</string>
    <string name="Hash42">Bobのデータを格納するにあたり…</string>
    <string name="Hash43">Keyのハッシュ値を求め、配列の箱の数５でmod演算を行います。結果は３でした。</string>
    <string name="Hash44">配列の３番の箱には、JoeとAllyのデータがあるため、Bobのデータをリストとして繋ぎます。</string>
    <string name="Hash45">全てのデータを格納しおわり、ハッシュテーブルが完成しました。</string>
    <string name="Hash46">Danの性別を調べる場合を考えてみましょう。</string>
    <string name="Hash47">Danが配列の何番の箱に格納されているかを知るために…</string>
    <string name="Hash48">KeyであるDanのハッシュ値を求め、配列の箱の数５でmod演算を行います。結果は４でした。</string>
    <string name="Hash49">配列の４番目の箱に格納されたデータのKeyがDanと一致しました。</string>
    <string name="Hash5">ここで、Allyの性別を調べる場合を考えてみましょう。</string>
    <string name="Hash50">対応するValueを取り出すことで、Danの性別が男性(Ｍ)であることが分かりました。</string>
    <string name="Hash51">では、Allyの性別を調べる場合はどうでしょうか。</string>
    <string name="Hash52">Allyが配列の何番の箱に格納されているかを知るために…</string>
    <string name="Hash53">KeyであるAllyのハッシュ値を求め、配列の箱の数５でmod演算を行います。結果は３でした。</string>
    <string name="Hash54">配列の３番目の箱に格納されたデータのKeyはJoeであり、Allyではありませんでした。</string>
    <string name="Hash55">そこで、Joeのデータを先頭として繋がれたリストを線形探索します。</string>
    <string name="Hash56">KeyをAllyとするデータが見つかりました。</string>
    <string name="Hash57">対応するValueを取り出すことで、Allyの性別が女性(Ｆ)であることが分かりました。</string>
    <string name="Hash58">このようにハッシュテーブルは、ハッシュ関数を利用することで、配列内のデータへの素早いアクセスを可能にしています。</string>
    <string name="Hash59">一方、ハッシュ値の重複時にはリストを利用しており、格納するデータ数が不確定であっても柔軟な対応が可能です。</string>
    <string name="Hash6">Allyが配列の何番の箱に格納されているかは分かりません。</string>
    <string name="Hash60">ハッシュテーブルに利用する配列のサイズは、小さすぎると重複が増え、線形探索が発生しやすくなります。</string>
    <string name="Hash61">逆に、サイスが大きすぎる場合には、データの格納されない箱が多く、メモリの無駄遣いになるため、注意が必要です。</string>
    <string name="Hash62">データの柔軟な格納と素早い参照ができるハッシュテーブルはプログラミング言語の連想配列などに利用されています。</string>
    <string name="Hash63">これで「ハッシュテーブル」の解説を終わります。</string>
    <string name="Hash7">そのため、先頭から順に調べていく必要があります。この操作を「線形探索」と呼びます。</string>
    <string name="Hash8">０番の箱に格納されたデータのKeyはJoeであり、Allyではありませんでした。</string>
    <string name="Hash9">１番の箱も、Allyではありませんでした。</string>
    <string name="HashFunction">ハッシュ関数</string>
    <string name="HashFunction0">「ハッシュ関数」とは、与えられたデータを固定長の不規則な値に変換する関数のことです。</string>
    <string name="HashFunction1">ミキサーを想像すると、ハッシュ関数を理解しやすいかもしれません。</string>
    <string name="HashFunction10">このことを前提に、ハッシュ関数の特徴を見ていきましょう。</string>
    <string name="HashFunction11">１つ目の特徴は、出力する値のデータ長が変わらないことです。</string>
    <string name="HashFunction12">出力のデータ長はハッシュ関数によって異なりますが、例えばSHA-1の場合、20バイトで固定となります。</string>
    <string name="HashFunction13">非常に大きなデータを入力しても、出力のハッシュ値のデータ長は変わりません。</string>
    <string name="HashFunction16">同様に、どんなに小さなデータを入力しても、ハッシュ値のデータ長は同じです。</string>
    <string name="HashFunction19">２つ目の特徴として、同じ入力なら出力も必ず同じになります。</string>
    <string name="HashFunction2">データをハッシュ関数に入力すると…</string>
    <string name="HashFunction25">３つ目の特徴として、似たようなデータを入力しても、それが1bitでも違えば、出力は大きく異なります。</string>
    <string name="HashFunction3">不規則な値を出力します。</string>
    <string name="HashFunction31">似たようなデータを入力すればハッシュ値も似たような値になる、というようなことはありません。</string>
    <string name="HashFunction32">４つ目の特徴として、まったく別のデータを入力しても、同じハッシュ値になることが、低確率ながら起こります。</string>
    <string name="HashFunction38">これを「ハッシュ値の衝突」と呼びます。</string>
    <string name="HashFunction39">５つ目の特徴として、ハッシュ値から元のデータを逆算することは、事実上不可能です。</string>
    <string name="HashFunction4">ハッシュ関数はデータをばらばらにする機械のようにイメージすると、理解しやすいです。</string>
    <string name="HashFunction41">データの入力と出力の流れは一方向であり、この点は「暗号化」との大きな違いです。</string>
    <string name="HashFunction43">最後の特徴として、計算が比較的容易であることがあげられます。</string>
    <string name="HashFunction46">ハッシュ関数のアルゴリズムはいくつか存在しますが、現在では「SHA-2」を用いるのが一般的です。</string>
    <string name="HashFunction47">ハッシュ関数は、入力されたデータの要約を出力するものと言え、さまざまな場面で使われます。</string>
    <string name="HashFunction48">本アプリでは、ハッシュ関数の利用例として「メッセージ認証コード」と「ハッシュテーブル」について詳しく解説しています。</string>
    <string name="HashFunction49">これで「ハッシュ関数」の解説を終わります。</string>
    <string name="HashFunction5">出力された不規則な値を「ハッシュ値」と呼びます。</string>
    <string name="HashFunction6">ハッシュ値は数字ですが、16進数で表記することが多いです。</string>
    <string name="HashFunction7">コンピュータはどのようなデータも、０と１の数字を用いた２進数で管理しています。</string>
    <string name="HashFunction8">ハッシュ値もまたデータであり、２進数で管理しています。</string>
    <string name="HashFunction9">実際には、ハッシュ関数は、コンピューターの内部で何らかの数値計算をしています。</string>
    <string name="Heap">ヒープ</string>
    <string name="Heap0">「ヒープ」は木構造のひとつで、「プライオリティキュー」を実現するときに使われます。</string>
    <string name="Heap1">「プライオリティキュー」はデータ構造のひとつです。</string>
    <string name="Heap10">親６＞子５ であるため、数字を入れ替えました。</string>
    <string name="Heap11">この操作を、入れ替えが発生しなくなるまで繰り返します。</string>
    <string name="Heap12">親１＜子５ であり、親の数字の方が小さいので、入れ替えは発生しません。</string>
    <string name="Heap13">これでヒープへの数字の追加が完了しました。</string>
    <string name="Heap14">ヒープから数字を取り出すときは、一番上の数字が取り出されます。</string>
    <string name="Heap15">ヒープでは、一番上の数字が最小値に保たれています。</string>
    <string name="Heap16">一番上の数字が抜けたため、ヒープの構造を整理する必要があります。</string>
    <string name="Heap17">最後尾の数を、一番上に移します。</string>
    <string name="Heap18">親の数字よりも、子の数字の方が小さい場合は、子の左右の数字のうち、より小さい方と入れ替えます。</string>
    <string name="Heap19">親６＞子右５＞子左３ であるため、左の子と親を入れ替えました。</string>
    <string name="Heap2">プライオリティキューには、データを自由に追加できます。</string>
    <string name="Heap20">この操作を、入れ替えが発生しなくなるまで繰り返します。</string>
    <string name="Heap22">子右８＞親６＞子左４ であるため、左の子と親を入れ替えました。</string>
    <string name="Heap23">これで、数字の取り出しが完了しました。</string>
    <string name="Heap24">このようにヒープを用いると、最小のデータを素早く取り出すことができます。</string>
    <string name="Heap25">ただし、途中のデータを取り出す操作はおこなえません。</string>
    <string name="Heap26">ヒープはプライオリティキューやダイクストラ法などで用いられています。</string>
    <string name="Heap27">これで「ヒープ」の解説を終わります。</string>
    <string name="Heap3">一方、データを取り出すときには最小値から順に選ばれます。</string>
    <string name="Heap4">追加は自由にでき、取り出すときは小さいものから、それがプライオリティキューです。</string>
    <string name="Heap5">それでは、ヒープの仕組みを見ていきます。</string>
    <string name="Heap6">ヒープのルールとして、子の数字は、必ず親の数字より大きくなっています。</string>
    <string name="Heap7">ヒープに数を追加してみましょう。</string>
    <string name="Heap8">追加された数は、まず最後尾に設置されます。</string>
    <string name="Heap9">親の数字の方が大きい場合、親子を入れ替えます。</string>
    <string name="HeapDescription">「ヒープ」は最小値のデータを素早く取り出せるデータ構造です。この項目は、全アルゴリズムのご購入後に学ぶことができます。</string>
    <string name="HeapSort">ヒープソート</string>
    <string name="HeapSort0">「ヒープソート」は数列を整列するアルゴリズムのひとつで、データ構造のヒープを利用することが特徴です。</string>
    <string name="HeapSort1">最初に、ヒープに全ての数字を格納します。ヒープは降順になるように構築します。ヒープについては本アプリの「ヒープ」の項目で詳しく説明しています。</string>
    <string name="HeapSort10">具体的には、ヒープ上の各要素（ノード）と配列に…</string>
    <string name="HeapSort105">なお、ヒープの構築にはより効率的な方法もありますが、今回は単純な方法を選んでいます。</string>
    <string name="HeapSort11">図のような対応関係をもたせます。</string>
    <string name="HeapSort15">ご覧のとおり、配列中にヒープが無理やり詰め込まれた状態と言えます。</string>
    <string name="HeapSort16">それでは実際に、配列を入れ替える方法でソートしてみましょう。</string>
    <string name="HeapSort17">ここでは理解の助けとなるよう、木構造状のヒープは表示したままにしておきます。</string>
    <string name="HeapSort18">さきほどと同様に、ヒープに数字を格納していく操作からはじめます。</string>
    <string name="HeapSort20">木構造状のヒープ内での数字の入れ替えに応じて、配列内でも数字を入れ替えます。</string>
    <string name="HeapSort21">ヒープに全ての数字を格納しました。同時に、配列が降順のヒープ構造に整理できました。</string>
    <string name="HeapSort22">次に、ヒープに格納した数字をひとつずつ取り出します。</string>
    <string name="HeapSort23">降順ヒープは大きいものから順にデータが取り出されます。</string>
    <string name="HeapSort24">配列内では、先頭の数字がヒープ内で最も大きな数字となっています。</string>
    <string name="HeapSort25">配列の先頭の数字を、ヒープの最後の要素に対応する配列と入れ替え、操作完了とします。</string>
    <string name="HeapSort26">ヒープの構造が維持されるように整理します。</string>
    <string name="HeapSort27">この操作を、全ての数字が操作完了となるまで繰り返します。</string>
    <string name="HeapSort28">ソートが完了しました。</string>
    <string name="HeapSort29">これで「ヒープソート」の解説を終わります。</string>
    <string name="HeapSort3">ヒープに全ての数字を格納しました。</string>
    <string name="HeapSort4">次に、ヒープに格納した数字をひとつずつ取り出します。</string>
    <string name="HeapSort5">降順ヒープは大きいものから順にデータが取り出される性質があるので、出てきた数字を逆順に並べれば、ソートが完了します。</string>
    <string name="HeapSort7">全ての数字をヒープから取り出し、ソートが完了しました。</string>
    <string name="HeapSort8">今回は数列とは別に、ヒープというデータ構造を用意しましたが…</string>
    <string name="HeapSort9">通常は、数列を納める配列それ自体にヒープを組み込み、数字の入れ替えのみでソートを行います。</string>
    <string name="Huffman">ハフマン符号</string>
    <string name="Huffman0">「ハフマン符号」はデータを符号化するアルゴリズムのひとつです。</string>
    <string name="Huffman1">JPEGやZIPなどの画像やファイルの圧縮に使用されています。</string>
    <string name="Huffman10">簡単な例として、図のように符号化のルールを定めてみました。ひとつの文字を２bitで表します。</string>
    <string name="Huffman100">「Ｃ or Ｄ」をひとつの文字と考え、同じ操作を繰り返します。</string>
    <string name="Huffman101">「Ａ」「Ｂ」「Ｃ or Ｄ」の３つより、出現比率の低い順に文字を２つ探します。</string>
    <string name="Huffman102" formatted="false">この場合は、「Ａ」(35%)と「Ｂ」(25%)になります。</string>
    <string name="Huffman103">２つの文字を線で結び、木構造を作ります。</string>
    <string name="Huffman104">２つの文字を「Ａ or Ｂ」として合体させ、出現比率を足し合わせます。</string>
    <string name="Huffman105">「Ａ or Ｂ」をひとつの文字と考えます。</string>
    <string name="Huffman106">同様に、出現比率の小さい文字２つを選びますが、最後に残った「Ａ or Ｂ」と「Ｃ or Ｄ」の２つの文字となります。</string>
    <string name="Huffman107">両者を線で結び、木構造を作ります。</string>
    <string name="Huffman108">全ての文字が「Ａ or Ｂ or Ｃ or Ｄ」としてひとつとなりました。出現比率は当然100%となります。</string>
    <string name="Huffman109">これで、ハフマン符号を導くための木構造が完成しました。</string>
    <string name="Huffman11">ルールに従って、「ABAABACD」を符号化してみました。その結果、データの大きさは16bitとなり、かなり削減されました。</string>
    <string name="Huffman110">各文字の、出現比率を再び表示しました。</string>
    <string name="Huffman111">０と１の符号を、上下に伸びる各枝に割り当てました。</string>
    <string name="Huffman112">次に、木の根から各文字を辿っていき、対応する符号を決定します。</string>
    <string name="Huffman113">「Ａ」の場合、割り当てられる符号は「00」となります。</string>
    <string name="Huffman114">「Ｂ」の場合、割り当てられる符号は「01」となります。</string>
    <string name="Huffman115">「Ｃ」の場合、割り当てられる符号は「10」となります。</string>
    <string name="Huffman116">「Ｄ」の場合、割り当てられる符号は「11」となります。</string>
    <string name="Huffman117">これでハフマン符号による符号化は完了です。</string>
    <string name="Huffman118">先程の例とは木構造が異なり、文字の出現比率に大きな差がないため、全ての文字が２bitの符号で表されています。</string>
    <string name="Huffman119">例えば、出現比率の最も高い「Ａ」を１bitで表すために、「Ｃ」と「Ｄ」を３bitで表そうとしても…</string>
    <string name="Huffman12">もちろん、勝手に定めたルールであるため、文字列を受け取る側には符号化ルールも伝える必要があります。</string>
    <string name="Huffman120" formatted="false">「Ｃ or Ｄ」の出現比率(40%)は「A」の出現比率(35%)より高いため、符号化の効率は悪くなります。</string>
    <string name="Huffman121">このように、ハフマン符号は文字の出現比率に応じて効率のよい符号化を、簡単に行なうことができることが分かります。</string>
    <string name="Huffman122">これで「ハフマン符号」の解説を終わります。</string>
    <string name="Huffman13">便宜上、本説明では符号化のルールの伝達に必要となる通信量は考えないこととします。</string>
    <string name="Huffman14">文字列を受け取った側が、符号を復元するには…</string>
    <string name="Huffman15">符号を２文字ごとに区切り…</string>
    <string name="Huffman16">それぞれを、ルールに照らし合わせて復元すれば、元の文字列「ABAABACD」を取り出せます。</string>
    <string name="Huffman17">「ABAABACD」という文字列をより小さく符号化することを、考えてみましょう。</string>
    <string name="Huffman18">先ほどのルールでは、ひとつの文字を２bitで表しましたが…</string>
    <string name="Huffman19">「Ａ」と「Ｂ」を、１bitで表すことで、さらに小さく符号化できそうです。</string>
    <string name="Huffman2">例として「ABAABACD」という文字列をネットワークを通して送信する場合を考えてみましょう。</string>
    <string name="Huffman20">なお、「ABAABACD」という文字列では、「Ｃ」と「Ｄ」よりも、「Ａ」と「Ｂ」の文字の方が多く使われています。</string>
    <string name="Huffman21">このことからも、「Ｃ」と「Ｄ」ではなく、「Ａ」と「Ｂ」を１bitで表す方が、良さそうです。</string>
    <string name="Huffman22">ルールに従って、「ABAABACD」を符号化してみました。その結果、データの大きさは10bitとなり、さらに削減されました。</string>
    <string name="Huffman23">符号を受け取った側が、符号を文字列に復元するには…</string>
    <string name="Huffman24">それぞれを、変換ルールに照らし合わせて復元すればよいのですが…</string>
    <string name="Huffman25">例えば、「10」という符号は、「ＢＡ」とも「Ｃ」とも表すことができてしまいます。</string>
    <string name="Huffman26">そのため、異なる文字列が取り出されてしまいました。</string>
    <string name="Huffman27">他にも、さまざまな文字列を取り出すことができてしまい、元の文字列を一意に決定することができません。</string>
    <string name="Huffman28">このように、符号を見ても元の文字列を一意に決定できないことを、「一意復号不可能」と言います。</string>
    <string name="Huffman29">もうひとつの例を考えてみましょう。便宜上、「Ａ」と「Ｂ」のふたつの文字が、図の通りに符号化されるとします。</string>
    <string name="Huffman3">データは０と１の２進数に符号化して送られます。</string>
    <string name="Huffman30">この符号化ルールにおいて、「000001」という符号が与えられた場合の復元手順を考えてみましょう。</string>
    <string name="Huffman31">復号するにあたり、先頭の数字から順に見ていきます。</string>
    <string name="Huffman32">はじめの数字は「０」ですが、この一字だけ見ても、「Ａ」を表すのか、「Ｂ」の一部を表すのか、判断できません。</string>
    <string name="Huffman33">２文字目までの数字は「00」ですが、「AA」を表すのか、「Ｂ」の一部を表すのか、判断できません。</string>
    <string name="Huffman34">さらに、３文字目までの数字は「000」ですが、「AAA」を表すのか、「Ｂ」の一部を表すのか、判断できません。</string>
    <string name="Huffman35">同様に、４文字目までの数字でも判断はつかず…</string>
    <string name="Huffman36">５文字目までの数字でも判断はつきません。</string>
    <string name="Huffman37">最終的に、６つ目の数字「１」を見て、やっと、先頭の文字「０」が「Ａ」であり、その後の「00001」が「Ｂ」を表すことが判断できます。</string>
    <string name="Huffman38">「000001」という数字は「AB」という文字列に一意に復元することができます。この点では、問題はありません。</string>
    <string name="Huffman39">変換表にある符号が表れたら、即時に元の文字を決定できるものを「瞬時符号」と呼びますが…</string>
    <string name="Huffman4">例えば「ASCII(アスキー)」という文字コードにおいては、「A」「B」「C」「D」のそれぞれの文字は図のように符号化されます。</string>
    <string name="Huffman40">この例のように、より後ろの文字を確認しないと元の文字を判断できないものは「瞬時符号」ではありません。</string>
    <string name="Huffman41">そのため、符号からの復元には手間がかかってしまいます。</string>
    <string name="Huffman42">効率の良い符号化・復号のためには、「一意復号可能」かつ「瞬時符号」であることが望ましいです。</string>
    <string name="Huffman43">例として見てきた、図の２つの符号化ルールのどこに問題があったのか、考えてみましょう。</string>
    <string name="Huffman44">ひとつ目の符号化ルールを可視化してみると…</string>
    <string name="Huffman45">ある符号が与えられた場合、その最初の文字が「０」ならば「Ａ」で確定します。</string>
    <string name="Huffman46">しかし「１」ならば、「Ｂ」である場合と、「Ｃ」あるいは「Ｄ」の一部である可能性があります。</string>
    <string name="Huffman47">同じように、ふたつ目の符号化ルールも可視化してみましょう。</string>
    <string name="Huffman48">ある符号が与えられた場合、その最初の文字は「０」にしかなりえません。</string>
    <string name="Huffman49">しかしその「０」が、「Ａ」である場合と、「Ｂ」の一部である可能性があります。</string>
    <string name="Huffman5">ASCIIではひとつの文字は８bitで表されます。</string>
    <string name="Huffman50">「一意復号可能」かつ「瞬時符号」であるためには、「どの符号も、他の符号の先頭に含まれることはない」ことが条件となります。</string>
    <string name="Huffman51">これまでの、ふたつの例ではそれを満たしていませんでした。</string>
    <string name="Huffman52">ハフマン符号は「一意復号可能」かつ「瞬時符号」である符号を簡単に導けるアルゴリズムです。</string>
    <string name="Huffman53">実際に、ハフマン符号での符号化を見ていきましょう。</string>
    <string name="Huffman54">ハフマン符号は「一意復号可能」な「瞬時符号」です。</string>
    <string name="Huffman55">はじめに、各文字の出現比率を計算します。「ABAABACD」の場合、図の比率になります。</string>
    <string name="Huffman56">次に、使用されている文字を、出現比率の高い順に並び替えます。この例では、「ABCD」という順のままです。</string>
    <string name="Huffman57">次に、出現比率の低い順に文字を２つ探します。</string>
    <string name="Huffman58" formatted="false">この場合は、「Ｃ」(12.5%)と「Ｄ」(12.5%)になります。</string>
    <string name="Huffman59">２つの文字を線で結び、木構造を作ります。</string>
    <string name="Huffman6">ASCIIに従って、「ABAABACD」という文字列を符号化してみました。その結果、データの大きさは64bitとなりました。</string>
    <string name="Huffman60">２つの文字を「Ｃ or Ｄ」として合体させ、出現比率を足し合わせます。</string>
    <string name="Huffman61">「Ｃ or Ｄ」をひとつの文字と考え、同じ操作を繰り返します。</string>
    <string name="Huffman62">「Ａ」「Ｂ」「Ｃ or Ｄ」の３つより、出現比率の低い順に文字を２つ探します。</string>
    <string name="Huffman63" formatted="false">この場合は、「Ｂ」(25%)と「Ｃ or Ｄ」(25%)になります。</string>
    <string name="Huffman64">２つの文字を線で結び、木構造を作ります。</string>
    <string name="Huffman65">２つの文字を「Ｂ or Ｃ or Ｄ」として合体させ、出現比率を足し合わせます。</string>
    <string name="Huffman66">「Ｂ or Ｃ or Ｄ」をひとつの文字と考えます。</string>
    <string name="Huffman67">同様に、出現比率の小さい文字２つを選びますが、最後に残った「Ａ」と「Ｂ or Ｃ or Ｄ」の２つの文字となります。</string>
    <string name="Huffman68">両者を線で結び、木構造を作ります。</string>
    <string name="Huffman69">全ての文字が「Ａ or Ｂ or Ｃ or Ｄ」としてひとつとなりました。出現比率は当然100%となります。</string>
    <string name="Huffman7">通信量を抑えるために、文字列を64bitより小さく符号化することを考えてみましょう。</string>
    <string name="Huffman70">これで、ハフマン符号を導くための木構造が完成しました。</string>
    <string name="Huffman71">各文字の、出現比率を再び表示しました。</string>
    <string name="Huffman72">次に、０と１を用いた符号化にうつります。</string>
    <string name="Huffman73">０と１の符号を、上下に伸びる各枝に割り当てます。</string>
    <string name="Huffman74">０と１の割り振りは逆でも問題ありません。ただし、仮に上側の枝を１と決めたら、途中で割り振り方を変更することはできません。</string>
    <string name="Huffman75">全ての符号を割り当てました。</string>
    <string name="Huffman76">次に、木の根から各文字を辿っていき、対応する符号を決定します。</string>
    <string name="Huffman77">「Ａ」の場合…</string>
    <string name="Huffman78">割り当てられる符号は「０」となります。</string>
    <string name="Huffman79">「Ｂ」の場合…</string>
    <string name="Huffman8">ASCIIは多くの文字を区別して管理するために、ひとつの文字を８bitで表しています。</string>
    <string name="Huffman80">割り当てられる符号は「10」となります。</string>
    <string name="Huffman81">「Ｃ」の場合…</string>
    <string name="Huffman82">割り当てられる符号は「110」となります。</string>
    <string name="Huffman83">「Ｄ」の場合…</string>
    <string name="Huffman84">割り当てられる符号は「111」となります。</string>
    <string name="Huffman85">これでハフマン符号による符号化は完了です。</string>
    <string name="Huffman86">この符号化ルールを用いて「ABAABACD」という文字列を符号化すれば良い、ということになります。</string>
    <string name="Huffman87">「どの符号も、他の符号の先頭に含まれることはない」ことは木構造から明らかです。</string>
    <string name="Huffman88">そのため、「一意復号可能」かつ「瞬時符号」となっています。</string>
    <string name="Huffman89">また、出現比率が高い文字ほど、bit数の小さな符号が割り振られているため、符号化の効率が良いことが分かります。</string>
    <string name="Huffman9">しかし「ABAABACD」という文字列では、たった４つの文字しか使われていません。これら４文字が区別できるように符号化すれば良さそうです。</string>
    <string name="Huffman90" formatted="false">具体的には、この例の場合、「Ａ」の出現頻度(50%)よりも「Ｃ or Ｄ」の出現頻度(25%)の方が低いです。</string>
    <string name="Huffman91">そのため、「Ｃ or Ｄ」を３bitで表現してでも、「Ａ」を１bitで表現するほうが効率的であり、それが反映された結果になっています。</string>
    <string name="Huffman92">求めた符号化ルールを用いて、「ABAABACD」を符号化してみましょう。</string>
    <string name="Huffman93">結果は、14bitとなりひとつの文字を２bitで表していた場合と比較して、さらに短くなりました。</string>
    <string name="Huffman94">もう一例見てみましょう。今回は、各文字の出現比率に大きな差がない場合です。</string>
    <string name="Huffman95">便宜上、文字列の順に従って出現比率が低くなるようにしました。そのため、並び替えの必要はありません。</string>
    <string name="Huffman96">次に、出現比率の低い順に文字を２つ探します。</string>
    <string name="Huffman97" formatted="false">この場合は、「Ｃ」(22%)と「Ｄ」(18%)になります。</string>
    <string name="Huffman98">２つの文字を線で結び、木構造を作ります。</string>
    <string name="Huffman99">２つの文字を「Ｃ or Ｄ」として合体させ、出現比率を足し合わせます。</string>
    <string name="HuffmanDescription">「ハフマン符号」は、JPEGやZIPなどにおいて使用されているアルゴリズムです。この項目は、全アルゴリズムのご購入後に学ぶことができます。</string>
    <string name="HybridEncoding">ハイブリッド暗号方式</string>
    <string name="HybridEncoding0">「共通鍵暗号方式」には、どうやって鍵を安全にやりとりするかという「鍵配送問題」がありました。</string>
    <string name="HybridEncoding1">一方、「公開鍵暗号方式」には、暗号化と復号の処理速度が遅いという問題がありました。</string>
    <string name="HybridEncoding10">この鍵を公開鍵暗号方式で暗号化することで、安全にＢさんに送ることができます。</string>
    <string name="HybridEncoding11">受け手であるＢさんが、公開鍵と秘密鍵を作成します。</string>
    <string name="HybridEncoding12">公開鍵をＡさんに送信します。</string>
    <string name="HybridEncoding13">ＡさんはＢさんから受け取った公開鍵を使って…</string>
    <string name="HybridEncoding14">共通鍵暗号方式に使う鍵を暗号化します。</string>
    <string name="HybridEncoding15">暗号化した鍵をＢさんに送信します。</string>
    <string name="HybridEncoding16">Ｂさんは秘密鍵を使って…</string>
    <string name="HybridEncoding17">鍵の暗号文を復号します。</string>
    <string name="HybridEncoding18">これで、Ａさんは公開鍵暗号方式に使う鍵を、Ｂさんに安全に送ることができました。</string>
    <string name="HybridEncoding19">あとは、この鍵を使って暗号化したデータを送るだけです。</string>
    <string name="HybridEncoding2">「ハイブリッド暗号方式」は、両者を組み合わせることで欠点を補い合う暗号方式です。</string>
    <string name="HybridEncoding20">データの暗号化には、処理速度の速い共通鍵暗号方式を使います。</string>
    <string name="HybridEncoding21">Ｂさんは無事に元のデータを取得することができました。</string>
    <string name="HybridEncoding22">このように、ハイブリッド暗号化方式は、安全性と処理速度の速さが両立します。</string>
    <string name="HybridEncoding23">インターネット上で情報を安全にやりとりするための「SSL」で利用されている、生活にかかせない暗号方式です。</string>
    <string name="HybridEncoding24">これで「ハイブリッド暗号方式」の解説を終わります。</string>
    <string name="HybridEncoding3">データの暗号化には処理速度の速い共通鍵暗号方式を使います。</string>
    <string name="HybridEncoding4">一方、共通鍵暗号方式で使用する鍵は、安全な公開鍵暗号方式でやりとりします。</string>
    <string name="HybridEncoding5">ハイブリッド暗号方式の具体的な流れを見てみましょう。</string>
    <string name="HybridEncoding6">ＡさんがＢさんにインターネット経由でデータを送ろうとしているとします。</string>
    <string name="HybridEncoding7">データは処理速度の速い共通鍵暗号方式で暗号化します。</string>
    <string name="HybridEncoding8">暗号化に必要な鍵は、復号にも使うため、Ａさんは鍵をＢさんに送る必要があります。</string>
    <string name="HybridEncoding9">鍵もまたデータのひとつです。</string>
    <string name="HybridEncodingDescription">「ハイブリッド暗号方式」は、共通鍵暗号方式と公開鍵暗号方式を組み合わせた方法です。この項目は、全アルゴリズムのご購入後に学ぶことができます。</string>
    <string name="IABSetUpFailed">Google Playへの接続に失敗しました。Google Playにログインしているかをご確認ください。</string>
    <string name="Inquiry">ご意見・ご感想</string>
    <string name="InquiryConfirmation">ご確認</string>
    <string name="InquiryEmail">メールアドレス</string>
    <string name="InquiryFailed">ご意見・ご感想の送信に失敗しました。しばらく時間をおいてからお試しください。</string>
    <string name="InquiryIsSendOK">ご意見・ご感想を送信してよろしいですか？</string>
    <string name="InquiryName">お名前</string>
    <string name="InquiryOptional">(任意)</string>
    <string name="InquiryPleaseInput">ご意見・ご感想瀾にメッセージをご記入ください。</string>
    <string name="InquiryPleaseSmall">メッセージは1,000文字以内でご記入ください。</string>
    <string name="InquirySend">送信する</string>
    <string name="InquirySuccess">ご意見・ご感想をお寄せいただき、誠にありがとうございます。今後のアプリ改善の参考にさせていただきます。</string>
    <string name="InquirySuccessTitle">ご意見・ご感想を送信しました</string>
    <string name="InsertionSort">挿入ソート</string>
    <string name="InsertionSort0">「挿入ソート」は数列を整列するアルゴリズムのひとつです。</string>
    <string name="InsertionSort1">最初に、左端の数字を操作済みにします。</string>
    <string name="InsertionSort10">左の数字と比較します。</string>
    <string name="InsertionSort11">５＞４なので、数字を入れ替えました。</string>
    <string name="InsertionSort12">３＜４で、自分より小さい数字があらわれたので止まります。</string>
    <string name="InsertionSort13">数字を操作済みにします。</string>
    <string name="InsertionSort14">同様の操作を、全ての数字が操作済みになるまで繰り返します。</string>
    <string name="InsertionSort18">全ての数字が操作済みになり、ソートが完了しました。</string>
    <string name="InsertionSort19">これで「挿入ソート」の解説を終わります。</string>
    <string name="InsertionSort2">つづいて、まだ操作していないものの中で、左端の数字を取り出し…</string>
    <string name="InsertionSort3">左の操作済みになっている数字と比較します。</string>
    <string name="InsertionSort4">もし、左の数字の方が大きい場合、２つの数字を入れ替えます。</string>
    <string name="InsertionSort5">この操作を、自分より小さい数字があらわれるか、数字が左端に到達するまで繰り返します。</string>
    <string name="InsertionSort6">この場合、５＞３なので、数字を入れ替えました。</string>
    <string name="InsertionSort7">数字が左端に到達したので、止まります。</string>
    <string name="InsertionSort8">数字を操作済みにします。</string>
    <string name="InsertionSort9">さきほどと同様に左端の数字を取り出し…</string>
    <string name="KmeansClustering">k-means法</string>
    <string name="KmeansClustering0">k-means法はクラスタリングアルゴリズムのひとつです。</string>
    <string name="KmeansClustering1">クラスタリングとは、データが与えられた時に…</string>
    <string name="KmeansClustering10">クラスターの中心点として、３点をランダムに設置します。</string>
    <string name="KmeansClustering100">再び最も近いクラスターの中心点を計算し、各データをクラスターに分類しました。</string>
    <string name="KmeansClustering101">クラスタリングでは、個々のグループのことを「クラスター」と呼びます。</string>
    <string name="KmeansClustering11">各データから最も近いクラスターの中心点を計算して決定します。</string>
    <string name="KmeansClustering12">各データをそれぞれ決定したクラスターに分類します。</string>
    <string name="KmeansClustering13">各クラスターに属するデータの重心を計算し、そこにクラスターの中心点を移動させます。</string>
    <string name="KmeansClustering14">中心点が移動したことにより、各データから最も近い中心点が変わることになります。</string>
    <string name="KmeansClustering15">以下「各データのクラスターへの分類」と「中心点の重心への移動」を、中心点が収束するまで繰り返します。</string>
    <string name="KmeansClustering2">それらを「似たもの」同士のグループに分類する操作のことです。</string>
    <string name="KmeansClustering26">中心点が収束したので、操作を終えます。</string>
    <string name="KmeansClustering27">操作を繰り返していくと、中心点が必ずどこかに収束することは数学的に証明されています。</string>
    <string name="KmeansClustering28">これで、クラスタリングが完了しました。</string>
    <string name="KmeansClustering29">データを似たもの同士で適切に分類できていることが確認できます。</string>
    <string name="KmeansClustering3">「似たもの」の基準は、各データ間の距離や座標など、アルゴリズムによって異なります。</string>
    <string name="KmeansClustering30">では、同じデータでクラスター数を２としてk-means法を実行してみたらどうなるかを試してみます。</string>
    <string name="KmeansClustering31">中心点をランダムに設置し…</string>
    <string name="KmeansClustering32">「各データのクラスターへの分類」と「中心点の重心への移動」を中心点が収束するまで繰り返します。</string>
    <string name="KmeansClustering4">k-means法は各クラスターの中心点からの距離を用いて、データを分類します。</string>
    <string name="KmeansClustering43">中心点が収束しました。</string>
    <string name="KmeansClustering44">今度は、左部と下部に位置するふたつのデータの塊が、ひとつのクラスターとして分類されました。</string>
    <string name="KmeansClustering45">このように、k-means法はクラスター数を事前に決定しないといけないため、設定した数が適切でないときに有意な結果が得られない場合があります。</string>
    <string name="KmeansClustering46">適切なクラスター数を推測するには、データを事前に分析するか、何度かクラスター数を変えてk-means法を試してみるなど、いくつかの手法があります。</string>
    <string name="KmeansClustering47">つづいて、同じデータで、クラスターの中心点の位置をさきほどと変えてみてk-means法を実行したらどうなるかを試してみます。</string>
    <string name="KmeansClustering48">「各データのクラスターへの分類」と「中心点の重心への移動」を中心点が収束するまで繰り返します。</string>
    <string name="KmeansClustering5">それでは、アルゴリズムの流れを見ていきましょう。</string>
    <string name="KmeansClustering58">中心点が収束しました。</string>
    <string name="KmeansClustering59">さきほどと異なり、右上部と右下部に位置するふたつのデータの塊が、ひとつのクラスターとして分類されました。</string>
    <string name="KmeansClustering6">まず、クラスタリングを行いたいデータを用意します。</string>
    <string name="KmeansClustering60">このように、k-means法はランダムに配置する最初の中心点の位置によって、クラスタリングの結果が異なってくるという特徴があります。</string>
    <string name="KmeansClustering61">これで「k-means法」の解説を終わります。</string>
    <string name="KmeansClustering7">次に、クラスター数を決定します。</string>
    <string name="KmeansClustering8">クラスター数を事前に決定することがk-means法の特徴です。</string>
    <string name="KmeansClustering9">今回は、クラスター数を３としてみます。</string>
    <string name="KmeansClusteringDescription">「k-means法」は単純ながら広く用いられているデータのクラスタリング手法です。この項目は、全アルゴリズムのご購入後に学ぶことができます。</string>
    <string name="LangColon">言語:</string>
    <string name="LetsUnlock">ご購入いただくことで、全ての項目を学ぶことができます。一緒にアルゴリズムをマスターしましょう！</string>
    <string name="LinearSearch">線形探索</string>
    <string name="LinearSearch0">線形探索は配列から要素を探索するアルゴリズムです。</string>
    <string name="LinearSearch1">数６を探索してみましょう。</string>
    <string name="LinearSearch2">まず、配列の左端の数字を調べます。</string>
    <string name="LinearSearch3">６と比較し、一致すれば探索を終了します。一致しなければひとつ右の数字を調べます。</string>
    <string name="LinearSearch4">６が見つかるまで比較を繰り返します。</string>
    <string name="LinearSearch5">６が見つかったので探索を終了します。</string>
    <string name="LinearSearch6">線形探索はこのように先頭から順番に比較を繰り返していくというシンプルな手法です。</string>
    <string name="LinearSearch7">データ数が多い場合、比較回数が多くなり時間が掛かります。</string>
    <string name="LinearSearch8">これで「線形探索」の解説を終わります。</string>
    <string name="List">リスト</string>
    <string name="List0">リストはデータ構造のひとつで、複数の値を格納することができます。</string>
    <string name="List1">データとポインタが対となっていることが特徴で、ポインタが次のデータのメモリ上の位置を指し示します。</string>
    <string name="List12">これで「リスト」の解説を終わります。</string>
    <string name="List2">リストではデータはメモリーの離れた領域に、ばらばらに格納されます。</string>
    <string name="List4">ばらばらに格納されているので、各データにはポインタを頭から辿ることでしかアクセスできません。</string>
    <string name="List9">データの追加は、追加する前後のポインタを指し替えるだけなので、簡単に行えます。</string>
    <string name="ListSearchSection">リスト探索</string>
    <string name="MAC">メッセージ認証コード</string>
    <string name="MAC0">「メッセージ認証コード」は「認証」と「改竄の検出」の２つの機能を実現する仕組みです。</string>
    <string name="MAC1">まずは、メッセージ認証コードが必要となる場面を見ていきましょう。</string>
    <string name="MAC10">暗号文をＢさんに送り…</string>
    <string name="MAC11">Ｂさんは受けとった暗号文を復号して、メッセージである商品番号を取得することができました。</string>
    <string name="MAC12">以上は問題のない場合ですが、次のようなことが起こりえます。</string>
    <string name="MAC13">場面を、Ａさんが暗号文をＢさんに送るところに戻します。</string>
    <string name="MAC14">ＡさんがＢさんに送信しようとした暗号文を…</string>
    <string name="MAC15">悪意のあるＸさんが通信途中で改竄したとします。</string>
    <string name="MAC16">Ｂさんは暗号文を受け取りますが、改竄されていることには気づくことができません。</string>
    <string name="MAC17">Ｂさんが改竄された暗号文を復号すると、メッセージは「xyz」になっていました。</string>
    <string name="MAC18">Ｂさんは、「xyz」が注文された商品番号だと信じ、Ａさんに誤った商品を発送してしまいました。</string>
    <string name="MAC19">暗号はあくまでも数値の計算処理にすぎないため、改竄された暗号文であっても、復号の計算をすることはできます。</string>
    <string name="MAC2">ＡさんがＢさんから商品を買うために、商品の番号を表す「abc」というメッセージを送るとします。</string>
    <string name="MAC20">元のメッセージが長い文章であれば、改竄されていたものは意味をなさない文章になっていることから、改竄に気付ける可能性はあります。</string>
    <string name="MAC21">しかし元のメッセージが、商品番号などの人間には直接理解できないデータであった場合には、復号してもそれが改竄されていたことに気付くことは難しいです。</string>
    <string name="MAC22">改竄を検知するには、暗号化とは別の手段が必要になります。</string>
    <string name="MAC23">「メッセージ認証コード」を使えば、メッセージの改竄を検知することができます。実際の流れを見ていきましょう。</string>
    <string name="MAC24">場面を、Ａさんが暗号文をＢさんに送るところに戻します。</string>
    <string name="MAC25">Ａさんは、メッセージ認証コード作成のための鍵を作成し…</string>
    <string name="MAC26">安全な方法で鍵をＢさんに送信します。</string>
    <string name="MAC27">続いて、Ａさんは暗号文と鍵を使って、ある値を作ります…</string>
    <string name="MAC28">「7f05」という値が得られました。</string>
    <string name="MAC29">この鍵と暗号文を組み合わせて作った値を「メッセージ認証コード」と呼びます。</string>
    <string name="MAC3">Ａさんが、メッセージを暗号化します。</string>
    <string name="MAC30">メッセージ認証コードは英語では「MAC(Message Authentication Code)」と呼ばれるため、本解説では今後「MAC」と記します。</string>
    <string name="MAC31">MACは、鍵と暗号文を組み合わせた文字列の「ハッシュ値」のようなものを想像すると良いでしょう。</string>
    <string name="MAC32">ハッシュ値については、本アプリの「ハッシュ関数」で詳しく解説しています。</string>
    <string name="MAC33">MACの作成方法には「HMAC」「OMAC」「CMAC」など、いくつかの種類があます。現在は「HMAC」という手法がよく使われています。</string>
    <string name="MAC34">ＡさんはＢさんに、作成したMACと暗号文を送ります。</string>
    <string name="MAC35">Ｂさんが暗号文とMACを受け取りました。</string>
    <string name="MAC36">Ｂさんは、受け取った暗号文が改竄されていないかを確認する必要があります。</string>
    <string name="MAC37">Ａさん同様、Ｂさんも暗号文と鍵を使ってMACを作成します。</string>
    <string name="MAC38">Ｂさんが自ら計算したMACと、Ａさんから受け取ったMACが一致することが確認できました。</string>
    <string name="MAC39">このことからＢさんが受け取った暗号文は、改竄されていないことが分かりました。</string>
    <string name="MAC4">暗号化には「共通鍵暗号方式」を用いるとします。</string>
    <string name="MAC40">あとは、暗号文用の鍵を用いて復号するだけです。</string>
    <string name="MAC41">無事に、Ａさんが注文した商品番号である「abc」というメッセージを取り出すことができました。</string>
    <string name="MAC42">場面を、Ａさんが暗号文をＢさんに送るところに戻します。</string>
    <string name="MAC43">もし、悪意のあるＸさんが通信途中で暗号文を改竄すると、どうなるでしょうか。</string>
    <string name="MAC44">ＡさんがＢさんに送信しようとした暗号文とMACのうち…</string>
    <string name="MAC45">Ｘさんが暗号文を改竄したとします。</string>
    <string name="MAC46">しかし、Ｂさんが再度MACを計算すると…</string>
    <string name="MAC47">Ａさんから受け取ったMACと一致しないことが分かりました。</string>
    <string name="MAC48">このことからＢさんは、暗号文かMAC、あるいはその両方が改竄されている可能性があることが分かりました。</string>
    <string name="MAC49">Ａさんから受け取った暗号文とMACを破棄し、再度、Ａさんに送信を要求すれば良いことになります。</string>
    <string name="MAC5">Ａさんは安全な方法で、鍵をＢさんに渡します。</string>
    <string name="MAC50">では、Ｘさんは暗号文の改竄と辻褄が合うように、MACも改竄することはできるのでしょうか。</string>
    <string name="MAC51">ＸさんはMACを計算するための鍵をもっていないため…</string>
    <string name="MAC52">MACを改竄できたとしても、暗号文の改竄と辻褄を合わせることは不可能です。</string>
    <string name="MAC53">やはり、ＢさんがMACを計算し直すと、改竄された暗号文に対するMACとは一致せず、通信の間でなんらかの改竄が行われたことが判明します。</string>
    <string name="MAC55">このように、メッセージ認証コードと呼ばれるMACを利用することで、通信の改竄を防ぐことができることが分かりました。</string>
    <string name="MAC56">ただし、メッセージ認証コードにも欠点があります。</string>
    <string name="MAC57">一連の流れを簡略化してみます。</string>
    <string name="MAC58">まず、ＡさんとＢさんは、暗号化に用いる鍵と、MACを計算するための鍵を共有しています。</string>
    <string name="MAC59">そのため…</string>
    <string name="MAC6">鍵交換の方法は「公開鍵暗号方式」か「Diffie-Hellman鍵交換法」のような鍵交換プロトコルを用います。</string>
    <string name="MAC60">Ａさんが、メッセージを暗号化し、MACを計算できるように…</string>
    <string name="MAC63">Ｂさんも同様に、メッセージを暗号化し、MACを計算することができてしまいます。</string>
    <string name="MAC66">つまり、元のメッセージを作成したのが、ＡさんであるかＢさんであるかが証明できないことになります。</string>
    <string name="MAC67">そのため、たとえばＡさんに悪意がある場合…</string>
    <string name="MAC68">メッセージを送った後になってから、それはＢさんが捏造したメッセージだと言い張り、送ったことを「事後否認」することができてしまいます。</string>
    <string name="MAC7">「公開鍵暗号方式」も「Diffie-Hellman鍵交換法」も本アプリで詳しく解説しています。</string>
    <string name="MAC71">このような事後否認を防ぐには、本アプリで解説している「デジタル署名」を使う必要があります。</string>
    <string name="MAC72">これで「メッセージ認証コード」の解説を終わります。</string>
    <string name="MAC8">Ａさんは共有した鍵を用いて、メッセージを暗号文にします。</string>
    <string name="MarkAllAsRead">全ての項目を既読にする</string>
    <string name="MarkAllAsUnread">全ての項目を未読にする</string>
    <string name="MathSection">数学</string>
    <string name="MergeSort">マージソート</string>
    <string name="MergeSort0">「マージソート」は数列を整列するアルゴリズムのひとつです。</string>
    <string name="MergeSort1">はじめに、数列を半分ずつに分割していきます。</string>
    <string name="MergeSort10">複数の数字を含むグループを合体する場合、先頭の数を比較し、小さい方の数を移動します。</string>
    <string name="MergeSort11">図の場合、先頭の４と３を比較します。</string>
    <string name="MergeSort12">４＞３なので、３を移動します。</string>
    <string name="MergeSort13">同様に残った列の先頭の数を比較し…</string>
    <string name="MergeSort14">４＜７なので、４を移動します。</string>
    <string name="MergeSort15">６＜７なので、６を移動します。</string>
    <string name="MergeSort16">残った７を移動します。</string>
    <string name="MergeSort17">グループの合体の操作は、全ての数がひとつのグループになるまで再帰的に繰り返します。</string>
    <string name="MergeSort22">合体が完了し、数列がソートされました。</string>
    <string name="MergeSort23">これで「マージソート」の解説を終わります。</string>
    <string name="MergeSort5">分割が完了しました。</string>
    <string name="MergeSort6">次に、分割してできた各グループを合体していきます。</string>
    <string name="MergeSort7">合体するときは、合体後のグループ内で数字が小さい順に並ぶように小さい数字から順に移動します。</string>
    <string name="MergeSortDescription">「マージソート」は、全体を小さく分割してから並び替える点に特徴があります。この項目は、全アルゴリズムのご購入後に学ぶことができます。</string>
    <string name="NowBuying">手続き準備中…</string>
    <string name="OK">OK</string>
    <string name="OthersSection">その他</string>
    <string name="PKC">公開鍵暗号方式</string>
    <string name="PKC0">「公開鍵暗号方式」は、暗号化と復号に異なる鍵を用いる暗号方式です。</string>
    <string name="PKC1">暗号化に使う鍵を「公開鍵」、復号に使う鍵を「秘密鍵」と呼びます。</string>
    <string name="PKC10">暗号文をＢさんに送信します。</string>
    <string name="PKC11">ＢさんはＡさんから受け取った暗号文を秘密鍵を使って復号します。</string>
    <string name="PKC12">これで、Ｂさんは元のデータを取得することができました。</string>
    <string name="PKC13">公開鍵と暗号文はインターネット経由で送信されるため…</string>
    <string name="PKC14">悪意のある第三者Ｘさんに盗み見される可能性があります。</string>
    <string name="PKC15">しかし、公開鍵では暗号文を復号できないため、Ｘさんが元のデータを取得することはできません。</string>
    <string name="PKC16">このように、共通鍵暗号方式と異なり、公開鍵暗号方式では「鍵配送問題」が起こりません。</string>
    <string name="PKC17">他にも公開鍵暗号方式は、不特定多数間でのやりとりがし易いというメリットがあります。具体的に見てみましょう。</string>
    <string name="PKC18">Ｂさんが、予め公開鍵と暗号鍵を用意しているとします。</string>
    <string name="PKC19">公開鍵は人に知られても問題がないものです。</string>
    <string name="PKC2">共通鍵暗号方式と比べると、公開鍵暗号方式は、暗号化にも復号にも時間がかかる傾向にあります。</string>
    <string name="PKC20">そのためＢさんは公開鍵をインターネット上で公開することができます。</string>
    <string name="PKC21">一方、秘密鍵は人に知られてはならないものなので、厳重に管理する必要があります。</string>
    <string name="PKC22">Ｂさんにデータを送信したい人が複数いるとします。</string>
    <string name="PKC23">データを送信する人は、Ｂさんが公開している公開鍵を取得し…</string>
    <string name="PKC24">送信したいデータを暗号化します。</string>
    <string name="PKC25">暗号文をＢさんに送ります。</string>
    <string name="PKC26">Ｂさんは受け取った暗号文を秘密鍵を使って復号します。</string>
    <string name="PKC27">これで、Ｂさんは元のデータを取得することができました。</string>
    <string name="PKC28">このように、データを送信する人ごとに鍵を用意する必要がありません。</string>
    <string name="PKC29">また、人に知られてはならない鍵を所有するのはデータの受け手のみであるため、安全度が高いです。</string>
    <string name="PKC3">公開鍵暗号の計算方法としては図のようなものがあります。</string>
    <string name="PKC30">一方で、公開鍵暗号方式には問題点が２つがあります。</string>
    <string name="PKC31">１つ目の問題点は、暗号化にも復号にも時間がかかることです。</string>
    <string name="PKC32">そのため、細かなデータを連続的にやりとりすることには向いていません。</string>
    <string name="PKC33">この問題の解決方法として、「ハイブリッド暗号方式」があり、本アプリでも詳しく解説しています。</string>
    <string name="PKC34">２つ目は、公開鍵の信頼性に関する問題点です。</string>
    <string name="PKC35">場面を、Ｂさんが公開鍵と秘密鍵を作成したところに戻します。</string>
    <string name="PKC36">便宜上、Ｂさんが作成した公開鍵を「PB」、秘密鍵を「SB」と表します。</string>
    <string name="PKC37">ＡさんがＢさんに送るデータを盗み見ようとするＸさんが、公開鍵PXと秘密鍵SXを作成します。</string>
    <string name="PKC38">Ｂさんが公開鍵PBをＡさんに送るときに…</string>
    <string name="PKC39">Ｘさんが、公開鍵PBを自身が作成した公開鍵PXにすり替え…</string>
    <string name="PKC4">現在は、RSA暗号という方法がよく使われており、本アプリでも詳しく解説しています。</string>
    <string name="PKC40">公開鍵「PX」をＡさんに渡します。</string>
    <string name="PKC41">公開鍵自体には、誰が作成したものであるかを示す手段がありません。</string>
    <string name="PKC42">そのため、Ａさんは受け取った公開鍵が擦り替わっていることに気がつくことができません。</string>
    <string name="PKC43">Ａさんは公開鍵PXでデータを暗号化します。</string>
    <string name="PKC44">Ａさんが暗号文をＢさんに送ろうとしたときに…</string>
    <string name="PKC45">Ｘさんが、この暗号文を受け取ります。</string>
    <string name="PKC46">この暗号文は、Ｘさんが用意した公開鍵PXで暗号化されたものなので…</string>
    <string name="PKC47">Ｘさんが持つ秘密鍵SXで復号できます。</string>
    <string name="PKC48">これで、Ｘさんは、ＡさんがＢさんに送ろうとしたデータを盗み見ることができました。</string>
    <string name="PKC49">次に、ＸさんはＢさんの公開鍵PBでデータを暗号化します。</string>
    <string name="PKC5">公開鍵暗号方式を使ったデータのやりとりの全体像を見ていきましょう。</string>
    <string name="PKC50">作成した暗号文をＢさんに渡します。</string>
    <string name="PKC51">この暗号文は、Ｂさんの用意した公開鍵PBで作成したものなので、Ｂさんは手元の秘密鍵SBで復号できます。</string>
    <string name="PKC52">Ｂさんは、何の問題もなく受け取った暗号文を復号することができたため、誰かにデータが盗み見られたことは夢にも思いません。</string>
    <string name="PKC53">このように、途中で公開鍵をすり替えて、データを盗み見る攻撃手法を「man-in-the-middle攻撃」と言います。</string>
    <string name="PKC54">問題の原因は、Ａさんが、受け取った公開鍵の作成者がＢさんであるかどうかを判断することができないことにあります。</string>
    <string name="PKC55">この問題点の解決には、「デジタル証明書」の仕組みを利用します。「デジタル証明書」については本アプリで詳しく解説しています。</string>
    <string name="PKC56">これで「公開鍵暗号方式」の解説を終わります。</string>
    <string name="PKC6">ＡさんがＢさんにインターネット経由でデータを送ろうとしているとします。</string>
    <string name="PKC7">まず、受け手であるＢさんが、公開鍵と秘密鍵を作成します。</string>
    <string name="PKC8">このうち、公開鍵をＡさんに送信します。</string>
    <string name="PKC9">ＡさんはＢさんから受け取った公開鍵を使って、データを暗号化します。</string>
    <string name="PageRank">ページランク</string>
    <string name="PageRank0">「ページランク」は、検索サイトにおいて、結果の順位を決定するために利用されるアルゴリズムです。</string>
    <string name="PageRank1">Google社がこのアルゴリズムを用いた検索エンジンによって、世界的な企業となったのは有名な話です。</string>
    <string name="PageRank10">リンクが張られていないページのスコアは１とします。</string>
    <string name="PageRank100">この動きをインターネット空間側に視点を置いて見てみると、ネットサーフィンをしている人は…</string>
    <string name="PageRank101">ページ間を不特定回数移動した後に、全く別のページにテレポートすることを繰り返しているように見えます。</string>
    <string name="PageRank11">リンクが張られているページのスコアは、リンクを張っているページのスコアの合計となります。</string>
    <string name="PageRank12">ただし、リンクが複数のページに張られている場合には…</string>
    <string name="PageRank13">リンクのスコアは均等に配分されます。</string>
    <string name="PageRank14">ページランクの考え方では、リンクを集めているページからのリンクは、大きな価値を持ちます。</string>
    <string name="PageRank15">この図の中央のページは、３つの独立したページからリンクが張られているため、スコアは３となります。</string>
    <string name="PageRank16">最上部のページは、スコアが３であるページからリンクが張られているため、大きなスコアを持ちます。</string>
    <string name="PageRank17">この図のなかの６つのページにおいては、最上部のページが最も重要なページであると、判断されます。</string>
    <string name="PageRank18">以上がページランクの基本的な考え方です。</string>
    <string name="PageRank19">この方法では、リンクがループ状になっている場合に、問題が生じます。</string>
    <string name="PageRank2">従来の検索サイトでは、検索キーワードとページ内の文章との関連性を中心に、検索結果の順位を決定していました。</string>
    <string name="PageRank20">各ページのスコアを順に計算していくと…</string>
    <string name="PageRank24">このように、無限にループすることになり、ループ内のページのスコアがどこまでも高くなってしまいます。</string>
    <string name="PageRank25">ループの問題は、「ランダムサーファーモデル」と呼ばれる計算方法で解決します。</string>
    <string name="PageRank26">ネットサーフィンをしている人が、どのようにページを閲覧するのかを考えてみましょう。</string>
    <string name="PageRank27">ある時、雑誌で紹介されていた面白そうなページにアクセスするとします。この左下のページから出発し…</string>
    <string name="PageRank28">リンクを辿って他のページに移動します。</string>
    <string name="PageRank29">何ページかを閲覧して、飽きると…</string>
    <string name="PageRank3">この方法では、ページ内に有益な情報が含まれているかは考慮されていません。そのため、検索結果の精度は高いとは言えない状況でした。</string>
    <string name="PageRank30">いったんネットサーフィンを終了します。</string>
    <string name="PageRank31">そして、後日、今度は友達から勧められた全く別のページからネットサーフィンを開始します。</string>
    <string name="PageRank32">リンクを辿って他のページに移動し…</string>
    <string name="PageRank33">飽きるとネットサーフィンを終了します。</string>
    <string name="PageRank34">このように、どこかのページから閲覧を開始し、数ページを移動して終了する、という動作が繰り返されます。</string>
    <string name="PageRank35">ネットサーフィンをする人の動きを定義すると、次のようになります。</string>
    <string name="PageRank36">確率１－αで、今いるページにあるリンクの中の１つを等確率で選びます。</string>
    <string name="PageRank37">確率αで、他のページの中の１つに等確率でテレポートします。</string>
    <string name="PageRank38">テレポートする確率であるαを、本解説では例として15％とします。</string>
    <string name="PageRank39">この定義に従って、ページ間の遷移をシミュレートしてみましょう。</string>
    <string name="PageRank4">ページランクは、ページ間のリンク構造からページの価値を算出するアルゴリズムです。算出までの具体的な流れを見ていきましょう。</string>
    <string name="PageRank40">さきほどと同じ、リンクがループ状になっている場合を考えます。</string>
    <string name="PageRank41">各ページ上の数字は、ネットサーフィンをする人がページを訪問した数を表します。</string>
    <string name="PageRank42">現在は、シミュレーション前ですので、全ての数字は０です。</string>
    <string name="PageRank43">定義に従ってシミュレーションを行なうと、ページごとの訪問回数に差がでてきます。</string>
    <string name="PageRank49">時間の流れを速めてみましょう。</string>
    <string name="PageRank5">四角がWEBページ、矢印がページ間のリンクを表すとします。</string>
    <string name="PageRank50">ページの訪問回数が合計1000回になるまでシミュレーションを続けてみました。</string>
    <string name="PageRank51">これを割合に直すと、図のようになります。</string>
    <string name="PageRank52">この値は、「ある時点で、そのページを閲覧している確率」を表していると言えます。</string>
    <string name="PageRank53">この値をそのままページのスコアに使うのが、ランダムサーファーモデルの手法です。</string>
    <string name="PageRank54">この手法であれば、リンクがループ状になっていても、スコアを計算できることが分かります。</string>
    <string name="PageRank55">実際はシミュレーションするのではなく、より実践的な計算方法を使います。そちらを紹介します。</string>
    <string name="PageRank56">図のような複雑なリンク構造において、各ページのスコアを計算してみましょう。</string>
    <string name="PageRank57">まず各ページに初期のスコアを設定します。</string>
    <string name="PageRank58">スコアは、全体で足して１になるように均等に設定します。</string>
    <string name="PageRank59">次に、ネットサーフィンをする人が１回移動したときに、各ページにいる確率を求めていきます。</string>
    <string name="PageRank6">この図では、下の３つのページから、上の１つのページにリンクが張られていることを示しています。</string>
    <string name="PageRank60">なお、ｎ回移動した時にＡにいる確率をPAnと表すことにします。同様に、ｎ回移動した時にＢにいる確率はPBnと表します。</string>
    <string name="PageRank61">例として、１回移動したあとにＡにいる確率(PA1)を求めてみましょう。</string>
    <string name="PageRank62">移動してＡにいる場合の１つは、Ｃにいる人がテレポートではなく移動を選び…</string>
    <string name="PageRank63">かつ、移動先としてＢではなくＡを選ぶ場合です。</string>
    <string name="PageRank64">初期状態(０回目の移動時点)でＣに人がいる確率はPC0(=0.25)です。</string>
    <string name="PageRank65">また、Ｃにいる人が移動を選ぶ確率は１－αであり、Ａ・ＢからＡを選ぶ確率は0.5です。</string>
    <string name="PageRank66">よって、ＣからＡに移動する確率は、PC0×(1-α)×0.5 となります。</string>
    <string name="PageRank67">移動してＡにいる場合はもう１つあり、ＡからＤのいずれかのページにいる人がテレポート選び…</string>
    <string name="PageRank68">かつ、テレポート先としてＡが選ばれる場合です。</string>
    <string name="PageRank69">ＡからＤのいずれかにいる人がテレポートを選ぶ確率はαです。</string>
    <string name="PageRank7">ページランクにおいては、リンクが張られている数が多いほど、重要なページであると判断されます。</string>
    <string name="PageRank70">また、テレポート先としてＡが選ばれる確率は0.25です。</string>
    <string name="PageRank71">よって、Ａにテレポートで移動する確率は、α×0.25 となります。</string>
    <string name="PageRank72">以上のことから、１回移動した後にＡにいる確率は、PA1=PC0×(1-α)×0.5+α×0.25 となります。</string>
    <string name="PageRank73">PC0=0.25、α=0.15 を代入して計算すると PA1＝0.14375 となります。</string>
    <string name="PageRank74">同様に、Ｂ・Ｃ・Ｄのページにいる確率も計算して、値を更新します。</string>
    <string name="PageRank75">結果は図の通りとなりました。</string>
    <string name="PageRank76">次に、ネットサーフィンをする人が２回移動したときに各ページにいる確率を、先ほどと同様の計算方法で求めます。</string>
    <string name="PageRank77">結果は図の通りとなりました。</string>
    <string name="PageRank78">同様の計算を繰り返します。すると、各ページにいる確率が収束していきます。</string>
    <string name="PageRank79">収束した段階で、計算を終了します。</string>
    <string name="PageRank8">この図では、上のページが最も重要なページであると判断されます。</string>
    <string name="PageRank80">こうして出てきた値を、各ページのスコアとします。</string>
    <string name="PageRank81">最後に、ページランクの値が、はじめに説明したリンクの重みづけでの計算と一致していることを確認します。</string>
    <string name="PageRank82">図のリンク構造において、さきほどの計算方法を使って、スコアを計算してみます。</string>
    <string name="PageRank83">各値を四捨五入しているので、全てを足して１にはなりませんが、先ほどと近い割合になっていることが分かります。</string>
    <string name="PageRank84">こちらのリンク構造においても、スコアを計算してみます。</string>
    <string name="PageRank85">こちらも、先ほどと近い割合になっていることが分かります。</string>
    <string name="PageRank86">このように、リンクの重みづけを、訪問している確率に置き換えて計算するのが、ページランクの仕組みです。</string>
    <string name="PageRank87">実際のGoogleにおける検索結果の順位は、ページランクのみで決められているわけではありません。</string>
    <string name="PageRank88">しかし、リンク構造からページの価値を算出するという発想、そして、リンクがループ状になっていても計算が行えること…</string>
    <string name="PageRank89">この２点において、ページランクというアルゴリズムが画期的であったことに変わりはありません。</string>
    <string name="PageRank9">実際は、各ページの重要度が計算によって数値化されます。まずは、基本的な計算方法のアイデアを説明します。</string>
    <string name="PageRank90">これで「ページランク」の解説を終わります。</string>
    <string name="PageRankDescription">「ページランク」は検索サイトにおける表示順位を決める指標となるものです。この項目は、全アルゴリズムのご購入後に学ぶことができます。</string>
    <string name="PrimalityTest">素数判定法</string>
    <string name="PrimalityTest0">「素数判定法」は、ある自然数が素数であるかどうかを判定する方法です。</string>
    <string name="PrimalityTest1">素数(prime number)とは、１と自分自身以外に約数を持たない自然数(ｎ＞１)のことです。</string>
    <string name="PrimalityTest100">素数判定法の解説に入る前に、mod演算について解説します。</string>
    <string name="PrimalityTest101">mod演算は、割り算の余りを求める演算です。</string>
    <string name="PrimalityTest102">Ａ mod Ｂ は、ＡをＢで割った時の余りＣを示します。</string>
    <string name="PrimalityTest103">具体的な数字を使った演算例を示します。</string>
    <string name="PrimalityTest17">つまり、3599は素数ではない、という結果になります。</string>
    <string name="PrimalityTest18">しかし、この方法は、素数かどうかを判定したい数字が大きくなるにつれて、演算に時間がかかってしまい、現実的でありません。</string>
    <string name="PrimalityTest19">この問題を解決する方法として「フェルマーテスト」があります。</string>
    <string name="PrimalityTest2">現代の暗号化技術において、よく使用される「RSA暗号」では、とても大きな素数を扱います。</string>
    <string name="PrimalityTest20">フェルマーテストは確率的素数判定法と呼ばれ、ある数が「素数の可能性が高いかどうか」を判定するものです。</string>
    <string name="PrimalityTest21">フェルマーテストの前提知識として、素数がもつ性質を見ていきましょう。</string>
    <string name="PrimalityTest22">例として、素数である５という数字の性質を考えてみます。</string>
    <string name="PrimalityTest23">素数５より小さい数をそれぞれ５乗した結果は、図のとおりです。</string>
    <string name="PrimalityTest28">次に、それぞれの数字をmod演算し、５で割った余りを求めると…</string>
    <string name="PrimalityTest29">計算結果は、図のとおりとなりました。</string>
    <string name="PrimalityTest3">このRSA暗号において、「素数判定法」は重要な役割を果たします。</string>
    <string name="PrimalityTest30">元の数と余りに注目すると、両者が一致していることが分かります。</string>
    <string name="PrimalityTest31">このことより、少なくとも素数である５については、図の式が成り立っていることがわかります。</string>
    <string name="PrimalityTest32">今度は、合成数(composite number)である６という数字について考えてみます。</string>
    <string name="PrimalityTest33">合成数というのは、素数ではない自然数のことを意味します。６という数字は、２×３で表すことができるため、素数ではありません。</string>
    <string name="PrimalityTest34">同様の計算を行うと…</string>
    <string name="PrimalityTest4">それでは、例として、3599という数字が素数かどうかを判定してみましょう。</string>
    <string name="PrimalityTest41">５と２の場合、元の数と余りが一致しないことが分かりました。</string>
    <string name="PrimalityTest42">想像のとおり、素数５に限らず全ての素数ｐに対して、図の式が成り立つことが証明されています。</string>
    <string name="PrimalityTest43">これを「フェルマーの小定理」と呼びます。</string>
    <string name="PrimalityTest44">また、フェルマーの小定理を満たすかどうかで素数を判定をする方法を「フェルマーテスト」と呼びます。</string>
    <string name="PrimalityTest45">フェルマーテストを使って113という数が素数かどうか判定してみましょう。</string>
    <string name="PrimalityTest46">113より小さい数を適当に３つ挙げてみました。</string>
    <string name="PrimalityTest47">これらの数を113乗したのち、113で割った余りを求めます。</string>
    <string name="PrimalityTest48">どの数においても、元の数と余りが一致しました。</string>
    <string name="PrimalityTest49">一致するかどうかを確認する回数が多いほど、素数である可能性が高まります。</string>
    <string name="PrimalityTest5">単純な方法として、 3599を２より大きな数で順番に割っていき、割り切れるかどうかを確認する方法が考えられます。</string>
    <string name="PrimalityTest50">ただし、ｐより小さい全ての数で確認するのは、とても時間がかかります。</string>
    <string name="PrimalityTest51">実際には、いくつかの数で確認した結果、素数である可能性が十分高いと判断できれば、それで実用上素数と判定しています。</string>
    <string name="PrimalityTest52">例えば、RSA暗号で使われる素数判定にはフェルマーテストを改良した「ミラー・ラビンテスト」が使われていますが…</string>
    <string name="PrimalityTest53">テストを繰り返していき、素数ではない確率が0.5の80乗より小さくなった段階で、その数を素数と判定します。</string>
    <string name="PrimalityTest54">また、たとえフェルマーテストを全て満たすとしても、素数であることは確定しません。</string>
    <string name="PrimalityTest55">調べる数字が素数であれば、フェルマーテストを全て満たします。</string>
    <string name="PrimalityTest56">一方、調べる数字が合成数である場合、フェルマーテストのどこかでひっかかる数字がほとんどですが…</string>
    <string name="PrimalityTest57">素数と同じく、フェルマーテストを全て満たしてしまう合成数が、極めて限られた確率ながら存在しています。</string>
    <string name="PrimalityTest58">例えば、561という数字について考えてみます。</string>
    <string name="PrimalityTest59">561という数字は、３×187や11×51などで表すことのできる合成数であり、素数ではありません。</string>
    <string name="PrimalityTest6">「割り切れる」ということは、余りを求める演算であるmod演算の結果が、０であることを意味します。</string>
    <string name="PrimalityTest60">しかし、フェルマーテストを満たしてしまいます。</string>
    <string name="PrimalityTest63">このような合成数を、「カーマイケル数」(Carmichael number)、または「絶対擬素数」と呼びます。</string>
    <string name="PrimalityTest64">カーマイケル数を小さい順にいくつか並べると図のとおりとなりますが、その数は少ないことが分かります。</string>
    <string name="PrimalityTest65">素数がフェルマーテストを全て満たすことは正しいですが、フェルマーテストを全て満たしたからといって、その数が素数であるとは言い切れません。</string>
    <string name="PrimalityTest66">あくまでも、フェルマーテストは確率的素数判定法です。</string>
    <string name="PrimalityTest67">しかし、効率的な判定方法が他にないことから、多くの場面で利用されています。</string>
    <string name="PrimalityTest68">これで「素数判定法」の解説を終わります。</string>
    <string name="PrimalityTest7">3599の平方根は、59.99…であるため、２から59までの数字で順にmod演算をすればよいはずです。</string>
    <string name="PrimalityTest8">実際にmod演算を行った結果、3599は59で割り切れることが分かりました。</string>
    <string name="PrimalityTestDescription">「素数判定法」では、確率的素数判定法のひとつであるフェルマーテストを解説しています。この項目は、全アルゴリズムのご購入後に学ぶことができます。</string>
    <string name="Queue">キュー</string>
    <string name="Queue0">「キュー」はデータ構造のひとつです。</string>
    <string name="Queue1">キューは「待ち行列」とも呼ばれ、その名の通り行列に並ぶことを考えるとイメージしやすいです。</string>
    <string name="Queue10">これで「キュー」の解説を終わります。</string>
    <string name="Queue2">行列においては、先に並んだ人ほど優先されます。</string>
    <string name="Queue3">キューにデータを追加する場合、データは一番最後に追加されます。</string>
    <string name="Queue5">キューにデータを追加する操作を「enqueue」と呼びます。</string>
    <string name="Queue6">キューからデータを取り出す場合、最も古くに追加されたデータから取り出されます。</string>
    <string name="Queue8">キューからデータを取り出す操作を「dequeue」と呼びます。</string>
    <string name="Queue9">このような、先に入れたものを先に出す「先入れ先出し」の仕組みを、「First In First Out」を略して「FIFO」と呼びます。</string>
    <string name="QuickSort">クイックソート</string>
    <string name="QuickSort0">クイックソートは数列を整列するアルゴリズムのひとつです。</string>
    <string name="QuickSort1">他のアルゴリズムに比べ、数の比較と交換回数が少ないのが特徴で、多くのケースで高速にソートができます。</string>
    <string name="QuickSort100">それでは、実際にアルゴリズムの流れを見てみましょう。</string>
    <string name="QuickSort101">わかりやすいようにpivotにマーカーを設置します。</string>
    <string name="QuickSort102">つづいて、一番左の数に左マーカー、右の数に右マーカーを設置します。</string>
    <string name="QuickSort103">クイックソートはこれらのマーカーを使い、一連の操作を再帰的に繰り返すアルゴリズムです。</string>
    <string name="QuickSort105">このように、左マーカーの役割は、pivot以上の数を見つけること、右マーカーの役割はpivotより小さな数を見つけることです。</string>
    <string name="QuickSort106">数を入れ替えることで、数列の左側にpivotより小さな数、右側にpivot以上の数を集めることができます。</string>
    <string name="QuickSort107">これで初回の操作が完了しました。</string>
    <string name="QuickSort11">４＜６なので、止まりました。</string>
    <string name="QuickSort12">左右のマーカーが止まった時、マーカーの数を入れ替えます。</string>
    <string name="QuickSort13">入れ替えたあとは、再び左マーカーを右に動かしていきます。</string>
    <string name="QuickSort14">さきほどと同様に、左マーカーはpivotの数以上の数にたどり着いた場合に止まります。</string>
    <string name="QuickSort18">９＞＝６なので、止まりました。</string>
    <string name="QuickSort19">つづいて、右マーカーを左に動かします。</string>
    <string name="QuickSort2">初回の操作の対象は数列の全ての数とします。</string>
    <string name="QuickSort21">右マーカーは左マーカーにぶつかった場合も、動きを止めます。</string>
    <string name="QuickSort22">左右のマーカーが停止し、かつ同じ位置にある場合、その数とpivotの数を入れ替えます。</string>
    <string name="QuickSort23">左右のマーカーがある数をソート済みにします。</string>
    <string name="QuickSort24">一連の操作によって数列を…</string>
    <string name="QuickSort25">pivotより左の「pivotより小さな数」と</string>
    <string name="QuickSort26">pivotより右の「pivotより大きな数」に分けることができました。</string>
    <string name="QuickSort27">２つに分かれた各数列に対して、一連の操作を再帰的に行っていきます。</string>
    <string name="QuickSort28">次は、分かれた左側の方の数列を操作の対象とします。</string>
    <string name="QuickSort29">３つのマーカーを設置します。</string>
    <string name="QuickSort3">ソートの基準となる数をひとつ選びます。この数のことをpivotと呼びます。</string>
    <string name="QuickSort30">さきほどと同様の操作を行っていきます。</string>
    <string name="QuickSort4">左マーカーを右に動かしていきます。</string>
    <string name="QuickSort40">一連の操作が終了し…</string>
    <string name="QuickSort41">pivotより左の「pivotより小さな数」と…</string>
    <string name="QuickSort42">pivotより右の「pivotより大きな数」に分けることができました。</string>
    <string name="QuickSort43">さらに、再帰的に一連の操作を繰り返していきます。</string>
    <string name="QuickSort44">２つに分かれた左側の数列を操作の対象とします。</string>
    <string name="QuickSort45">対象の数列の数が１つだった場合、ソート済みにします。</string>
    <string name="QuickSort47">２回目の操作で分かれた右側の数列を操作の対象とします。</string>
    <string name="QuickSort48">３つのマーカーを設置します。</string>
    <string name="QuickSort49">左マーカーを右に動かしていきます。</string>
    <string name="QuickSort50">左マーカーは右マーカーとぶつかっても止まりません。その点は右マーカーの動きとは異なります。</string>
    <string name="QuickSort51">左マーカーは操作の対象数列の右端にたどり着いたら止まります。</string>
    <string name="QuickSort52">この場合、操作対象の範囲内でpivotの数が一番大きな数ということになります。</string>
    <string name="QuickSort53">次に、右マーカーを動かしますが、左マーカーに追い越されている場合には動かさずに終了します。</string>
    <string name="QuickSort54">左マーカーが、操作対象の右端に達している場合、pivotの数をソート済みにし、一連の操作を終わります。</string>
    <string name="QuickSort55">以下、同様の操作を全ての数がソート済みになるまで繰り返します。</string>
    <string name="QuickSort6">左マーカーが、pivotの数以上の数にたどり着いた場合、動きを止めます。</string>
    <string name="QuickSort7">今回は８＞＝６なので、止まりました。</string>
    <string name="QuickSort8">つづいて、右マーカーを左に動かしていきます。</string>
    <string name="QuickSort83">全ての数がソート済みになりました。</string>
    <string name="QuickSort84">これで「クイックソート」の解説を終わります。</string>
    <string name="QuickSort9">右マーカーは、pivotより小さい数にたどり着いた場合、動きを止めます。</string>
    <string name="QuickSort99">pivotは通常ひとつの数をランダムで選択します。今回は便宜上、常に一番右の数をpivotとして選ぶことにします。</string>
    <string name="QuickSortDescription">「クイックソート」は、データの比較と交換回数が少ない点に特徴があります。この項目は、全アルゴリズムのご購入後に学ぶことができます。</string>
    <string name="Random">Random</string>
    <string name="RateThisApp">アプリを評価・レビューする</string>
    <string name="RecursionSection">再帰</string>
    <string name="Restore">購入記録の復元</string>
    <string name="RestoreAlert">購入記録が確認できたので復元いたします。この操作により課金は行われません。</string>
    <string name="RestoreBuyingLog">購入記録を復元する</string>
    <string name="RestoreSuccessed">購入記録の復元が完了しました</string>
    <string name="Reversed">Reversed</string>
    <string name="ReviewConfirmation">AppStoreを開きます</string>
    <string name="ReviewConfirmationAndroid">Google Playを開きます</string>
    <string name="RunLength">ランレングス符号</string>
    <string name="RunLength0">５×５のマスに３色を用いて描かれた画像を符号化してみましょう。</string>
    <string name="RunLength1">まずは単純な手法を用います。</string>
    <string name="RunLength10">この操作は、「圧縮」に対し「解凍」と呼ばれます。</string>
    <string name="RunLength11">ランレングス符号には、向いているデータと向いていないデータがあります。</string>
    <string name="RunLength12">符号化されたものをよく見てみると、全体としては文字数が減っているものの…</string>
    <string name="RunLength13">同じ色が連続しない箇所については、ランレングス符号化した後の方が、文字数が増えてしまっています。</string>
    <string name="RunLength14">例えば、図のようなデータの連続性に乏しいものをランレングス符号化すると…</string>
    <string name="RunLength15">符号は倍の50文字となってしまいました。</string>
    <string name="RunLength16">逆に、図のようなデータの連続性があるものをランレングス符号化すると…</string>
    <string name="RunLength17">符号は10文字となりました。元の25文字と比較すると、かなりの圧縮率となります。</string>
    <string name="RunLength18">このように、ランレングス符号は符号化対象のデータによっては、圧縮の効果がある場合と、ない場合があります。</string>
    <string name="RunLength19">そのため、データが一定数以上連続した場合にのみランレングス符号化するなど、さまざまな工夫が必要となります。</string>
    <string name="RunLength2">３色それぞれにＹ(Yellow)、Ｇ(Green)、Ｂ(Blue)の文字を割り当てました。</string>
    <string name="RunLength20">ランレングス符号の使用例として、モノクロ・ファックスの場合を考えてみましょう。</string>
    <string name="RunLength21">図の図形を送信するにあたり、単純に各マス目をＷ(White)、Ｂ(Black)の文字で表すと、25文字になります。</string>
    <string name="RunLength22">通信量を抑えるために、ランレングス符号化で、データを圧縮しましょう。</string>
    <string name="RunLength23">符号化の結果、１文字増えて、26文字となってしまいました。これでは、ランレングス符号を用いる意味はありません。</string>
    <string name="RunLength24">しかし、モノクロ画像で使用されているのは白と黒の２色のみです。</string>
    <string name="RunLength25">そのため、例えば、白いマス目が続いた後に来るのは、黒いマス目と決まっています。</string>
    <string name="RunLength26">ＷとＢという文字がなくても、符号から図形を復元することができそうです。</string>
    <string name="RunLength27">ＷとＢという文字を省きました。その結果、13文字となり、約半分のサイズに圧縮することができました。</string>
    <string name="RunLength28">ただし、符号の最初の数字は白色のマス目の連続数であるという決まり事を作る必要があります。</string>
    <string name="RunLength29">その決まり事があれば、符号から元の画像を正しく復元することができます。</string>
    <string name="RunLength3">図形の左上を起点として一行ずつＹ、Ｇ、Ｂの文字に変換した結果、図形を25文字に符号化することができました。</string>
    <string name="RunLength30">では、次のような画像を符号化する場合には、どうすればよいでしょうか。</string>
    <string name="RunLength31">先ほどとは異なり、画像の最初のマス目は、白色ではなく、黒色になっています。</string>
    <string name="RunLength32">ひとまず、同じ操作で、図形を符号化してみました。</string>
    <string name="RunLength33">符号の最初の数字６は黒色のマス目の連続数を示してしますが…</string>
    <string name="RunLength34">「符号の最初の数字は白色のマス目数である」という決まり事が守られていません。</string>
    <string name="RunLength35">このまま復元すると、白黒が反転した画像となってしまいます。</string>
    <string name="RunLength36">あくまでも、「符号の最初の数字は白色のマス目数である」という決まり事を守るため、符号の先頭に０を加えました。</string>
    <string name="RunLength37">図形の最初に白色のマス目が０マスある、つまり、白色のマス目はない、という意味になります。</string>
    <string name="RunLength38">先頭に０を加えたことで、文字数は１文字増えましたが、同じ決まり事に則って、データを圧縮することができました。</string>
    <string name="RunLength39">ランレングス符号は、一般的に、データの連続性に乏しいテキストデータよりも、画像データの圧縮に向いていると言えます。</string>
    <string name="RunLength4">次に、この画像をランレングス符号化することで、25文字より短い文字数で表現してみましょう。</string>
    <string name="RunLength40">いずれの場合でも、より高い圧縮効果を常に発揮できるような工夫が求められます。</string>
    <string name="RunLength41">これで「ランレングス符号」の解説を終わります。</string>
    <string name="RunLength5">ランレングス符号は、符号と、それが連続する回数を１セットにして符号化する手法です。</string>
    <string name="RunLength6">例えば、最初の「ＹＹＹＹ」の箇所は「Ｙ４」と表現することで、２文字短く表現することができます。</string>
    <string name="RunLength7">同様の操作を繰り返し、ランレングス符号化が完了しました。</string>
    <string name="RunLength8">結果、符号は５文字短くなり、20文字に圧縮されました。</string>
    <string name="RunLength9">画像が１行５マスでできていることが共有されていれば、符号から元の画像を取り出すことができます。</string>
    <string name="SecurityBase">暗号の基礎</string>
    <string name="SecurityBase0">現代のインターネット社会において、暗号技術がなぜ必要なのでしょうか。</string>
    <string name="SecurityBase1">ＡさんがＢさんにインターネット経由でデータを送ろうとしているとします。</string>
    <string name="SecurityBase10">データを暗号化しておけば、たとえ悪意のある第三者に盗み見されたとしても安心です。</string>
    <string name="SecurityBase11">このように、現代のインターネット社会では暗号化の技術はとても大切なものになっています。</string>
    <string name="SecurityBase12">次に、暗号化とは具体的にどのような操作をすることなのかを見ていきましょう。</string>
    <string name="SecurityBase13">まず、コンピュータはどのようなデータも、０と１の数字を用いた２進数で管理しています。</string>
    <string name="SecurityBase14">データにはテキスト、音楽、画像などさまざまな形式がありますが</string>
    <string name="SecurityBase15">全てのデータがコンピュータ内では、２進数の数値として管理されています。</string>
    <string name="SecurityBase150">本解説で、暗号技術の必要性、データは数字で管理されていること、暗号化とは数値計算であることを説明しました。</string>
    <string name="SecurityBase16">これをふまえて、データを暗号化することを考えてみます。</string>
    <string name="SecurityBase17">データはコンピュータにとって意味のある数字の羅列です。</string>
    <string name="SecurityBase18">暗号文もまた数字の羅列として管理されていますが、コンピュータが解釈できないランダムな数字になっています。</string>
    <string name="SecurityBase19">暗号化とは、データに何らかの演算を行うことで、コンピュータが解釈できない数に変えることを意味します。</string>
    <string name="SecurityBase2">データはインターネット上のさまざまなネットワーク、機器を経由してＢさんに届きます。</string>
    <string name="SecurityBase20">暗号化の数値計算では「鍵」を利用します。</string>
    <string name="SecurityBase21">鍵もまた数値でできています。</string>
    <string name="SecurityBase22">つまり、暗号化とは鍵を用いて数値計算することで、データを読み取れないものに変換することです。</string>
    <string name="SecurityBase23">逆に、復号とは鍵を用いて数値計算することで、暗号文を元のデータに戻すことです。</string>
    <string name="SecurityBase24">例として、仮にデータと鍵を図の値とし、計算方法を「XOR」としたときの、具体的な流れを見ていきましょう。</string>
    <string name="SecurityBase25">XOR(排他的論理和)とは図の真理値表で計算できる演算のことです。</string>
    <string name="SecurityBase26">XORの特徴として、図の式が成立します。</string>
    <string name="SecurityBase27">つまり、ある値Ａとある値ＢをXORで計算した結果をＣとした場合、</string>
    <string name="SecurityBase28">Ｃに対してＡかＢを再びXORで計算することで、もう一方の値が取り出せることを意味します。</string>
    <string name="SecurityBase29">データに対して鍵を用いてXORを計算すると…</string>
    <string name="SecurityBase3">そのため、そのままのデータを送信しようとすると…</string>
    <string name="SecurityBase30">このような暗号文が取得できました。</string>
    <string name="SecurityBase31">今度は、暗号文を復号してみましょう。</string>
    <string name="SecurityBase32">暗号文に対して、再び鍵を用いてXORを計算すると…</string>
    <string name="SecurityBase33">元のデータを取得することができました。</string>
    <string name="SecurityBase34">このように、XORという計算方法を用いた暗号では、暗号化と復号に同じ鍵を用いることになります。</string>
    <string name="SecurityBase35">これで「暗号の基礎」の解説を終わります。</string>
    <string name="SecurityBase4">悪意のある第三者にデータを盗み見される可能性があります。</string>
    <string name="SecurityBase5">そのため、秘密にしたいデータは暗号化して送る必要があります。</string>
    <string name="SecurityBase6">暗号化されたデータを「暗号文」と呼びます。</string>
    <string name="SecurityBase7">暗号文をＢさんに送信します。</string>
    <string name="SecurityBase8">ＢさんはＡさんから受け取った暗号文を解除し、元のデータを取得します。</string>
    <string name="SecurityBase9">暗号文を元のデータに戻すことを「復号」と呼びます。</string>
    <string name="SecurityBasic">セキュリティの基礎</string>
    <string name="SecurityBasic0">インターネットを経由してデータをやりとりする場合、データはさまざまなネットワーク、機器を経由して相手に届きます。</string>
    <string name="SecurityBasic1">そのため、インターネットを安全に利用するためには、セキュリティの技術が不可欠となります。</string>
    <string name="SecurityBasic10">この問題を「なりすまし」と言います。</string>
    <string name="SecurityBasic11">第３の問題として、ＡさんからＢさんへのメッセージの送信が確かに完了したとしても…</string>
    <string name="SecurityBasic12">経路の途中で、Ｘさんによってメッセージが書き換えられていた可能性があります。</string>
    <string name="SecurityBasic13">この問題を「改ざん」と言います。</string>
    <string name="SecurityBasic14">第三者による意図した改ざん以外にも、通信上のなんらかの障害で、届いたデータが破損している可能性もあります。</string>
    <string name="SecurityBasic15">第４の問題として、ＢさんがＡさんからメッセージを受け取ったつもりでいても…</string>
    <string name="SecurityBasic16">メッセージの送り主であるＡさんに悪意がある場合…</string>
    <string name="SecurityBasic17">後になってＡさんが「それは自分が送ったメッセージではない」と言い張る可能性があります。</string>
    <string name="SecurityBasic18">このようなことが起これば、インターネット上での商取引や契約行為が成り立たなくなります。</string>
    <string name="SecurityBasic19">この問題を「事後否認」と言います。</string>
    <string name="SecurityBasic2">まずは、インターネットでデータをやりとりする際に起こりうる、代表的な４つの問題を見ていきましょう。</string>
    <string name="SecurityBasic20">代表的な４つの問題を紹介しました。</string>
    <string name="SecurityBasic21">なお、以上の問題は人同士のやり取りに限らず、ウェブサイトを閲覧する場合も同様に起こり得ます。</string>
    <string name="SecurityBasic22">続いて、これらの問題を解決するために、どのようなセキュリティ技術があるのか、その対応を簡単に見ていきましょう。</string>
    <string name="SecurityBasic23">１つ目の問題である「盗聴」を防ぐには、「暗号化」の技術を用います。</string>
    <string name="SecurityBasic24">２つ目の問題「なりすまし」を防ぐには、「メッセージ認証コード」か…</string>
    <string name="SecurityBasic25">「デジタル署名」の技術を用います。</string>
    <string name="SecurityBasic26">３つ目の問題である「改ざん」を防ぐ場合も同様に、「メッセージ認証コード」か…</string>
    <string name="SecurityBasic27">「デジタル署名」の技術を用います。</string>
    <string name="SecurityBasic28">この「デジタル署名」の技術は、４つ目の問題である「事後否認」を防ぐにも役立ちます。</string>
    <string name="SecurityBasic29">表にまとめると、図のようになります。</string>
    <string name="SecurityBasic3">第１に、ＡさんがＢさんにメッセージを送ろうとしているときに…</string>
    <string name="SecurityBasic30">なお、「デジタル署名」の技術において課題となる、「公開鍵の所持者が特定できない問題」を解決するために、「デジタル証明書」という技術もあります。</string>
    <string name="SecurityBasic31">本アプリでは、これらのセキュリティ技術それぞれついて、詳しく解説しています。</string>
    <string name="SecurityBasic32">これで「セキュリティの基礎」の解説を終わります。</string>
    <string name="SecurityBasic4">経路の途中で、Ｘさんにメッセージの内容を盗み見される可能性があります。</string>
    <string name="SecurityBasic5">この問題を「盗聴」と呼びます。</string>
    <string name="SecurityBasic6">また第２の問題として、ＡさんがＢさんにメッセージを送ったつもりでいても…</string>
    <string name="SecurityBasic7">ＸさんがＢさんを騙っていた可能性があります。</string>
    <string name="SecurityBasic8">逆に、ＢさんがＡさんからメッセージを受け取ったつもりでいても…</string>
    <string name="SecurityBasic9">ＸさんがＡさんを騙っていた可能性があります。</string>
    <string name="SecuritySection">セキュリティ</string>
    <string name="SelectionSort">選択ソート</string>
    <string name="SelectionSort0">「選択ソート」は数列を整列するアルゴリズムのひとつです。</string>
    <string name="SelectionSort1">数列を線形探索し、最小値を探します。「線形探索」については本アプリで詳しく解説しています。</string>
    <string name="SelectionSort2">最小値を列の左端の数と交換し、ソート済みにします。</string>
    <string name="SelectionSort3">なお、最小値がすでに左端であった場合には、何の操作も行いません。</string>
    <string name="SelectionSort4">同様の操作を、全ての数字がソート済みになるまで繰り返します。</string>
    <string name="SelectionSort6">ソートが完了しました。</string>
    <string name="SelectionSort7">これで「選択ソート」の解説を終わります。</string>
    <string name="Setting">設定</string>
    <string name="SettingNotShowUnreadButtons">未読マークを表示しない</string>
    <string name="Share">アプリをシェア・評価する</string>
    <string name="ShareOnFacebook">Facebookでシェアする</string>
    <string name="ShareOnTwitter">Twitterでシェアする</string>
    <string name="Shuffle">Shuffle</string>
    <string name="SortSection">ソート</string>
    <string name="Stack">スタック</string>
    <string name="Stack0">「スタック」はデータ構造のひとつです。</string>
    <string name="Stack1">スタックの仕組みは、物を縦に積み上げることを考えるとイメージしやすいです。</string>
    <string name="Stack10">これで「スタック」の解説を終わります。</string>
    <string name="Stack2">積み上げられた山から物を取り出す場合、上から順番に取り出すことになります。</string>
    <string name="Stack3">スタックにデータを追加する場合、データは一番最後に追加されます。</string>
    <string name="Stack5">スタックにデータを追加する操作を「push」と呼びます。</string>
    <string name="Stack6">スタックからデータを取り出す場合、最も新しく追加されたデータから取り出されます。</string>
    <string name="Stack8">スタックからデータを取り出す操作を「pop」と呼びます。</string>
    <string name="Stack9">このような、後から入れたものを先に出す「後入れ先出し」の仕組みを、「Last In First Out」を略して「LIFO」と呼びます。</string>
    <string name="ThankYouForUnlocking">全アルゴリズムをご購入いただき、誠にありがとうございます。引き続き「アルゴリズム図鑑」をお楽しみください。</string>
    <string name="ToSendUs">ご要望や・不具合につきましては「ご意見・ご要望」よりお寄せ下さい。</string>
    <string name="Unlock">全アルゴリズムの購入</string>
    <string name="UnlockSuccessed">アルゴリズムの購入が完了しました</string>
    <string name="WEB">WEB</string>
    <string name="YouCanLearnAfter">「%@」は全アルゴリズムのご購入後に学ぶことができます。</string>
    <string name="YouCanLearnAfterAndroid">「%s」は全アルゴリズムのご購入後に学ぶことができます。</string>
    <string name="YouCanRestore">すでに全アルゴリズムをご購入済みの場合、購入記録を復元することで、再び全ての項目を閲覧することができます。</string>
    <string name="abc_action_bar_home_description">ホームへ移動</string>
    <string name="abc_action_bar_up_description">上へ移動</string>
    <string name="abc_action_menu_overflow_description">その他のオプション</string>
    <string name="abc_action_mode_done">完了</string>
    <string name="abc_activity_chooser_view_see_all">すべて表示</string>
    <string name="abc_activitychooserview_choose_application">アプリの選択</string>
    <string name="abc_capital_off">OFF</string>
    <string name="abc_capital_on">ON</string>
    <string name="abc_search_hint">検索…</string>
    <string name="abc_searchview_description_clear">検索キーワードを削除</string>
    <string name="abc_searchview_description_query">検索キーワード</string>
    <string name="abc_searchview_description_search">検索</string>
    <string name="abc_searchview_description_submit">検索キーワードを送信</string>
    <string name="abc_searchview_description_voice">音声検索</string>
    <string name="abc_shareactionprovider_share_with">共有</string>
    <string name="abc_shareactionprovider_share_with_application">%sと共有</string>
    <string name="abc_toolbar_collapse_description">折りたたむ</string>
    <string name="app_name">アルゴリズム図鑑</string>
    <string name="en">英語</string>
    <string name="es">スペイン語</string>
    <string name="goal">GOAL</string>
    <string name="ja">日本語</string>
    <string name="ko">韓国語</string>
    <string name="min">min</string>
    <string name="pt">ポルトガル語</string>
    <string name="ru">ロシア語</string>
    <string name="search">search</string>
    <string name="search_menu_title">検索</string>
    <string name="status_bar_notification_info_overflow">999+</string>
    <string name="zh">中国語（簡体字）</string>
</resources>
