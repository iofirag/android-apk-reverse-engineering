<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="AStarSearch">Алгоритм A*</string>
    <string name="AStarSearch0">Алгоритм \"A*\" (произносится как А звезда) является развитием алгоритма Дейкстры. Для начала, давайте найдем кратчайший путь в лабиринте используя алгоритм Дейкстры.</string>
    <string name="AStarSearch1">В данном лабиринте, мы предполагаем, что вес перехода между вершинами равен 1.</string>
    <string name="AStarSearch10">Может быть, будет легче понять, если мы представим себе что расчётная стоимость вершины это её высота.</string>
    <string name="AStarSearch100">Более эффективный поиск стал возможен, благодаря расчёту стоимости хода, основанному на заранее известных данных.</string>
    <string name="AStarSearch101">Фактическая стоимость от стартовой вершины до текущего местоположения + расчетная стоимость до целевой вершины и даёт нам стоимость от стартовой вершины до цели.</string>
    <string name="AStarSearch11">Цель в правом нижнем углу будет самая низкая точка, а точка в верхнем левом углу стоимостью 8 будет самая высокая точка. Идти с горы легче, чем подниматься на неё.</string>
    <string name="AStarSearch12">В процессе исследования лабиринта, если мы будем двигаться в сторону меньшей стоимости хода (как будто мы двигаемся вниз с горы), мы быстрее достигнем цели.</string>
    <string name="AStarSearch13">Теперь попробуем решить лабиринт, используя A*.</string>
    <string name="AStarSearch14">Для начала, будем считать, что стартовая вершина полностью исследована.</string>
    <string name="AStarSearch15">Далее рассчитаем стоимость перемещения к каждой вершине, достижимой из стартовой вершины.</string>
    <string name="AStarSearch16">Эта стоимость рассчитывается как общая стоимость перемещения к данной вершине и остаточная стоимость до целевой вершины.</string>
    <string name="AStarSearch17">Мы выбираем одну из точек с самой низкой стоимостью.</string>
    <string name="AStarSearch18">Выбранная точка считается полностью исследованной.</string>
    <string name="AStarSearch19">Снова вычисляем стоимость каждой вершины, к которой мы можем двигаться от исследованной вершины.</string>
    <string name="AStarSearch2">С этим допущением, давайте найдем кратчайший путь, используя алгоритм Дейкстры.</string>
    <string name="AStarSearch20">И снова мы выбираем одну из точек с самой низкой стоимостью.</string>
    <string name="AStarSearch21">Выбранная вершина считается полностью исследованной.</string>
    <string name="AStarSearch22">Далее, повторяются похожие действия, до тех пор, пока цель не будет достигнута.</string>
    <string name="AStarSearch24">По сравнению с использованием алгоритма Дейкстры, мы смогли исследовать лабиринт более эффективно.</string>
    <string name="AStarSearch25">Что мы можем сделать, чтобы исследовать лабиринт еще более эффективней?</string>
    <string name="AStarSearch26">Давайте попробуем использовать реальную стоимость пути вместо линейного расстояния.</string>
    <string name="AStarSearch28">В этот раз мы достигли цели по кратчайшему маршруту, без учёта ненужных путей.</string>
    <string name="AStarSearch29">На самом же деле, мы никогда не будем знать реальную стоимость кратчайшего пути. Если бы мы уже знали его, то зачем его искать?</string>
    <string name="AStarSearch30">Как можно видеть, в зависимости от того, как Вы установите эвристическую функцию, это может быть решающим фактором для оптимизации алгоритма A*.</string>
    <string name="AStarSearch31">Чем ближе эвристическая стоимость к реальной, тем более эффективней будет исследован лабиринт.</string>
    <string name="AStarSearch32">С другой стороны, давайте посмотрим на то, что же произойдёт, когда эвристическая функция определена неверно.</string>
    <string name="AStarSearch33">Сейчас показан специальный подобранный пример. Мы оставили эвристическую стоимость только на кратчайшем пути, всем другим ячейкам присвоили 0.</string>
    <string name="AStarSearch35">Эффективность поиска была даже хуже чем в алгоритме Дейкстры. Однако, кратчайший путь всё же был найден правильно.</string>
    <string name="AStarSearch36">В алгоритме A*, пока эвристическая стоимость равна или меньше минимальной стоимости от текущей вершины до цели, нахождение кратчайшего пути гарантировано, независимо от эффективности.</string>
    <string name="AStarSearch37">В качестве плохого примера, давайте установим эвристическую стоимость больше минимальной стоимости от текущей вершины до цели.</string>
    <string name="AStarSearch38">Тут мы оставили стоимость только на кратчайшем пути и удвоили предыдущие значения. Поступив таким образом, мы сильно превысили минимальную стоимость от текущей вершины до цели.</string>
    <string name="AStarSearch4">Самый короткий путь был найден, но был исследован практически каждый путь.</string>
    <string name="AStarSearch40">Алгоритм решил, что поиск закончен, однако найденный путь не является кратчайшим.</string>
    <string name="AStarSearch41">Таким образом, мы видим, качество алгоритма A* будет зависеть того, насколько Вы правильно его отрегулируете.</string>
    <string name="AStarSearch42">Алгоритм A* часто используется в программировании игр, в таких вещах как искусственный интеллект врага, который должен преследовать игрока.</string>
    <string name="AStarSearch43">Однако, большое количество расчетов может иметь негативное влияние на общую скорость игры. Вам необходимо подумать о том, как именно его использовать, может стоит комбинировать его с другими алгоритмами или ограничить его использование.</string>
    <string name="AStarSearch44">На этом моменте мы завершаем объяснение алгоритма A*.</string>
    <string name="AStarSearch5">Алгоритм Дейкстры учитывает только вес от стартовой вершины, прежде чем перейти к следующей.</string>
    <string name="AStarSearch6">Из-за этого, он уходит по направлениям указанными стрелками, не понимая, что уходят дальше от целевой вершины.</string>
    <string name="AStarSearch7">А* учитывает не только цену пути от начальной вершины, но так же и расчетную стоимость хода от текущей точки до целевой вершины.</string>
    <string name="AStarSearch8">Эта примерная стоимость хода может быть легко определена. В данном случае, значения были определены округлением линейного расстояния от целевой вершины до нижнего правого угла.</string>
    <string name="AStarSearch9">Расчетная стоимость, устанавливаемая заранее, называется \"эвристической функцией\".</string>
    <string name="AStarSearchDescription">Алгоритм \"A*\" это улучшенная версия алгоритма Дейкстры. Вы можете изучить эту тему после покупки всех алгоритмов.</string>
    <string name="AboutDev">О приложении</string>
    <string name="AlgorithmText1">Шифрование RSA</string>
    <string name="AlgorithmText2">Криптография на эллиптических кривых</string>
    <string name="AlreadyBought">Куплено</string>
    <string name="AlreadyBoughtRestore">Если Вы переустановили приложение или установили его на другое устройство iOS, пожалуйста используйте опцию \"Восстановить покупки\".</string>
    <string name="AlreadyBoughtRestoreAndroid">Если Вы переустановили приложение или установили его на другое устройство Android пожалуйста используйте опцию \"Восстановить покупки\"</string>
    <string name="AppTitle">Алгоритмы: Понятные и анимированные</string>
    <string name="Array">Массивы</string>
    <string name="Array0">\"Массивы\" - это тип структуры данных, позволяющий хранить несколько значений.</string>
    <string name="Array1">Каждый элемент может быть доступен через его индекс (число которое означает положение элемента в массиве)</string>
    <string name="Array10">Для начала, мы должны зарезервировать свободное место в конце массива.</string>
    <string name="Array11">Для освобождения места в нужной позиции значения сдвигаются по одному элементу за раз.</string>
    <string name="Array13">\"Зеленый\" добавляется в свободное место, завершая добавление элемента.</string>
    <string name="Array14">Если мы удаляем второй элемент, мы действуем наоборот</string>
    <string name="Array15">Сначала мы удаляем элемент,</string>
    <string name="Array16">затем сдвигаем элементы, заполняя пустое место, которое появилось при удалении элемента</string>
    <string name="Array18">В заключении удаляем пустое место в конце массива, завершая удаление элемента массива.</string>
    <string name="Array19">На этом моменте заканчивается объяснение структуры данных \"массив\".</string>
    <string name="Array2">Данные хранятся в памяти последовательно</string>
    <string name="Array3">Так как данные располагаются последовательно, адреса в памяти могут вычислены с помощью индексов позволяя организовать произвольный доступ к данным.</string>
    <string name="Array8">Другой особенностью массивов является высокая стоимость добавления или удаления данных по сравнению со списками.</string>
    <string name="Array9">Давайте представим, что мы хотим добавить объект \"зеленый\" на вторую позицию.</string>
    <string name="BellmanFord">Алгоритм Беллмана-Форда</string>
    <string name="BellmanFord0">Алгоритм \"Беллмана-Форда\" используется для нахождения кратчайшего пути в графах.</string>
    <string name="BellmanFord1">Всем узлам графа присваивается начальный вес. Стартовому узлу присваивается вес равный нулю, остальным узлам - вес равный бесконечности.</string>
    <string name="BellmanFord10">Далее, рассчитаем стоимость пути в обратном направлении, от точки B к точке A.</string>
    <string name="BellmanFord11">Вес B равен 9, значит, стоимость обхода от точки B к точке A будет равно 9 + 9 = 18.</string>
    <string name="BellmanFord12">Затем мы сравниваем полученное значение с текущим весом точки A, текущий вес меньше - значит, он не изменяется.</string>
    <string name="BellmanFord13">Когда мы двигаемся от точки с большим весом к точке с меньшим весом, вес ребра не изменяется до тех пор, пока он положительный.</string>
    <string name="BellmanFord14">Такая же операция будет выполнена на всех ребрах. Для удобства будем делать вычисления начиная от ребер с левой стороны.</string>
    <string name="BellmanFord15">Мы выбираем ребро...</string>
    <string name="BellmanFord150">Для примера, были найдены кратчайшие пути к точке C (1 шаг) и к точке D (2 шага).</string>
    <string name="BellmanFord16">и изменяем вес.</string>
    <string name="BellmanFord17">Аналогично выбираем другое ребро...</string>
    <string name="BellmanFord18">и обновляем вес.</string>
    <string name="BellmanFord19">Теперь мы видим, что стоимость перемещения из точки A в точку B, меньше, когда мы проходим через точку C.</string>
    <string name="BellmanFord2">Выбирается одно из ребер графа. Для удобства мы выбрали ребро A-B.</string>
    <string name="BellmanFord20">Выполняется обновление весов по всем рёбрам.</string>
    <string name="BellmanFord21">Выполнен первый цикл коррекции весов.</string>
    <string name="BellmanFord22">Данная операция повторяется на всех ребрах, до тех пор, пока не будет больше требоваться обновления весов.</string>
    <string name="BellmanFord24">Изменений весов больше не происходит, поэтому мы прекращаем работу.</string>
    <string name="BellmanFord25">На этом этапе, алгоритм заканчивает поиск, найдены все кратчайшие пути от стартовой точки ко всем остальным.</string>
    <string name="BellmanFord26">Давайте подумаем, почему с помощью данных операций найден кратчайший путь.</string>
    <string name="BellmanFord27">Мы вернули схему к начальному состоянию.</string>
    <string name="BellmanFord28">В этот раз, будем делать вычисление весов для всех ребер в обратном порядке. Другими словами, мы начнем с правой стороны и ребра которые выходят из стартовой точки A будут обработаны последними.</string>
    <string name="BellmanFord3">Вычисляется стоимость обхода каждого узла на выделенном ребре графа. Вычисление стоимости выполняется путем сложения веса начального узла + стоимость перемещения (вес ребра).</string>
    <string name="BellmanFord30">Первый цикл обновления весов закончен.</string>
    <string name="BellmanFord31">После первого цикла можно видеть, что обновились веса только тех узлов, которые достижимы из точки A.</string>
    <string name="BellmanFord32">Сделаем второй цикл обновления весов.</string>
    <string name="BellmanFord34">Второй цикл обновления весов закончен.</string>
    <string name="BellmanFord35">После второго цикла, мы видим, что изменились веса узлов, которые находятся в двух ходах от стартовой точки.</string>
    <string name="BellmanFord36">На самом деле, после выполнения операции обновления весов N раз, гарантировано будут найдены кратчайшие пути для всех узлов, расположенных от стартовой точки на расстоянии N или менее шагов.</string>
    <string name="BellmanFord37">На схеме было сделано 2 цикла обновлений весов, это означает, что как минимум были найдены кратчайшие пути ко всем точкам, расположенных от стартового узла на расстоянии 2 шагов или меньше.</string>
    <string name="BellmanFord38">Даже если путь к точке F через путь B-C-D-F имеет цену ниже, он потребует 3 шага, и поэтому не рассматривается из-за того, что найдены кратчайшие пути только для узлов в 2 шагах или менее.</string>
    <string name="BellmanFord39">Также, несмотря на то, что найденный кратчайший путь к B состоит из 3х шагов, это стало известно только из-за порядка обхода рёбер.</string>
    <string name="BellmanFord4">Расчет выполняется по очереди в одном из направлений. Для удобства, мы будем сначала вычислять в направлении от узла с меньшим весом к узлу с большим весом.</string>
    <string name="BellmanFord40">Другими словами, в зависимости от порядка обхода рёбер, бывает случаи, что кратчайшие пути требуют больше ходов, чем количество циклов обновления весов.</string>
    <string name="BellmanFord41">Итак, если после N циклов обновления найдено кратчайшие пути из N шагов или меньше, сколько раз мы должны провести операцию обновления?</string>
    <string name="BellmanFord42">Дано N узлов, учитывая то, что мы посещаем каждый узел по одному разу, мы уверены, что достигнем всех узлов за N - 1 ходов.</string>
    <string name="BellmanFord43">Другими словами, если мы выполним N - 1 циклов обновления весов, в лучшем случае будут найдены кратчайшие пути ко всем узлам.</string>
    <string name="BellmanFord44">Также, если в процессе обновления веса не изменятся, можем сказать, что кратчайшие пути уже определены и процесс останавливается.</string>
    <string name="BellmanFord45">Теперь же, давайте запустим операции обновления на схеме до тех пор, пока не будут найдены кратчайшие пути ко всем узлам.</string>
    <string name="BellmanFord47">Обновлений весов больше нет - останавливаем операции.</string>
    <string name="BellmanFord48">Нам удалось определить кратчайшие пути ко всем узлам, как и раньше.</string>
    <string name="BellmanFord49">Более того, даже если цена различна в обе стороны, как показано на схеме (в случае A и B), и даже если движение по ребрам графа возможно только в одну сторону (как в случае остальных ребер на схеме)...</string>
    <string name="BellmanFord5">Так как текущий вес узла A меньше, то сначала мы рассчитаем стоимость обхода от точки A к точке B.</string>
    <string name="BellmanFord50">алгоритм Беллмана-Форда корректно найдет кратчайшие пути.</string>
    <string name="BellmanFord51">Графы, у которых зафиксировано направление ребер, как на схеме, называются \"ориентированные графы\", а графы, не имеющие направления у ребер, называются \"неориентированные графы\".</string>
    <string name="BellmanFord52">Итак, что же произойдет, если появятся \"отрицательные веса\"?</string>
    <string name="BellmanFord53">На рисунке у ребра C-B отрицательный вес -3.</string>
    <string name="BellmanFord54">Трудно представить, что означает отрицательное значение веса...</string>
    <string name="BellmanFord55">но в качестве примера, давайте представим, что мы двигаемся на машине от начальной точки A до конечной точки G. Можно представлять стоимость перехода как количество потребляемого топлива.</string>
    <string name="BellmanFord56">В данной ситуации будет легче понять, если мы будем представлять заправочную станцию в области с отрицательным весом.</string>
    <string name="BellmanFord57">С помощью алгоритма Беллмана-Форда, даже в ситуациях, в которых есть отрицательные веса, кратчайшие пути будет найдены корректно.</string>
    <string name="BellmanFord58">Что же случится если вес на ребре C-B изменится с -3 до -6 ?</string>
    <string name="BellmanFord59">Казалось бы, что кратчайший путь будет найден без проблем...</string>
    <string name="BellmanFord6">Вес A равен 0, значит стоимость обхода от точки A к B равно 0 + 9 = 9.</string>
    <string name="BellmanFord60">но общий вес пути A-C-B равен -1.</string>
    <string name="BellmanFord61">Такие пути называются \"отрицательные циклы\".</string>
    <string name="BellmanFord62">Когда есть отрицательный цикл, вес будет делаться всё ниже и ниже без остановки, в процессе работы алгоритма.</string>
    <string name="BellmanFord63">Таким образом, нет способа, чтобы найти кратчайший путь.</string>
    <string name="BellmanFord64">Когда Вы будете пытаться найти кратчайший путь в этом графе алгоритмом Беллмана-Форда, неважно сколько раз Вы будете делать циклов обновлений, вес будет постоянно изменяться и это никогда не закончится.</string>
    <string name="BellmanFord65">На самом деле, в алгоритме Беллмана-Форда цикл обновлений весов следует завершить после (число узлов - 1) операций, так что...</string>
    <string name="BellmanFord66">если число циклов достигнет или превысит N, то это означает, что в графе где-то есть отрицательный цикл.</string>
    <string name="BellmanFord67">Как Вы только что видели, алгоритм Беллмана-Форда это алгоритм с большим объемом вычислений, но он может найти кратчайший путь, даже если есть отрицательные веса...</string>
    <string name="BellmanFord68">и он также обнаруживает отрицательные циклы в графе.</string>
    <string name="BellmanFord69">На этом моменте мы завершаем объяснение алгоритма Беллмана-Форда.</string>
    <string name="BellmanFord7">Если полученный результат меньше текущего веса узла, то вес обновляется вычисленным значением.</string>
    <string name="BellmanFord8">Текущий вес точки B - бесконечность, следовательно, вес изменяется на 9.</string>
    <string name="BellmanFord9">После обновления веса мы сохраняем путь. На схеме путь показан оранжевым цветом.</string>
    <string name="BinarySearch">Бинарный поиск</string>
    <string name="BinarySearch0">\"Бинарный поиск\" - это алгоритм для поиска в элементах отсортированного массива.</string>
    <string name="BinarySearch1">Давайте попытаемся найти число 6.</string>
    <string name="BinarySearch10">Сморим на число в центре массива. В данный момент это 6.</string>
    <string name="BinarySearch11">Так как 6=6 значит, мы нашли число, которое искали.</string>
    <string name="BinarySearch12">Таким образом, бинарный поиск использует тот факт, что массив предварительно отсортирован и для эффективного поиска постоянно делит массив пополам.</string>
    <string name="BinarySearch13">На этом моменте завершается объяснение бинарного поиска.</string>
    <string name="BinarySearch2">Для начала посмотрим на число в центре массива. В нашем случае это 5.</string>
    <string name="BinarySearch3">Мы сравниваем 5 с числом 6, которое мы ищем. Так как 5 меньше 6 мы знаем, что число 6 находится справа от 5.</string>
    <string name="BinarySearch4">Из кандидатов мы убираем числа, которые нам больше не нужны.</string>
    <string name="BinarySearch6">Снова посмотрим на число в центре оставшегося массива. Сейчас это число 7.</string>
    <string name="BinarySearch7">Сравниваем 7 и 6. Так как 6 меньше чем 7, мы знаем, что число 6 слева от числа 7.</string>
    <string name="BinarySearch8">Снова мы убираем числа, которые нам больше не нужны, из возможных кандидатов.</string>
    <string name="BinaryTree">Бинарные деревья поиска (BST)</string>
    <string name="BinaryTree0">\"Бинарные деревья поиска\" - одна из разновидностей структур данных.</string>
    <string name="BinaryTree1">Пронумерованные точки называются \"узлы\".</string>
    <string name="BinaryTree10">И наоборот, самый большой узел находится в самом конце правого поддерева, также начиная от самого верхнего узла.</string>
    <string name="BinaryTree11">Давайте посмотрим на процесс добавления узлов в бинарное дерево.</string>
    <string name="BinaryTree12">Для примера, попробуем добавить 1.</string>
    <string name="BinaryTree13">Мы начнем добавление с самого верхнего узла бинарного дерева поиска для того, чтобы найти правильное место для узла.</string>
    <string name="BinaryTree14">1 меньше чем 15, значит идем в левую сторону.</string>
    <string name="BinaryTree16">1 меньше чем 9 значит, снова идем влево.</string>
    <string name="BinaryTree18">1 меньше чем 3 значит, мы должны идти влево еще, но там нет узла, куда бы мы могли двигаться, в этом случае 1 добавляется как новый узел.</string>
    <string name="BinaryTree2">У бинарных деревьев поиска имеется два свойства.</string>
    <string name="BinaryTree20">Добавление узла со значением 1 завершено.</string>
    <string name="BinaryTree21">Давайте теперь попробуем добавить 4.</string>
    <string name="BinaryTree22">Как и ранее, мы начнем с самого верхнего узла, для того чтобы найти правильное место для 4.</string>
    <string name="BinaryTree23">4 меньше 15, идем влево.</string>
    <string name="BinaryTree25">4 меньше 9, снова идем влево.</string>
    <string name="BinaryTree27">4 больше 3, значит идем вправо.</string>
    <string name="BinaryTree29">4 меньше 8, идем влево, но так как там нет узла, 4 добавляется как новый узел.</string>
    <string name="BinaryTree3">Первое свойство заключается в том, что все узлы больше чем узлы левого поддерева.</string>
    <string name="BinaryTree31">Добавление узла 4 завершено.</string>
    <string name="BinaryTree32">Теперь взглянем на процесс удаления узлов из бинарного дерева поиска.</string>
    <string name="BinaryTree33">Для примера, попробуем удалить 28.</string>
    <string name="BinaryTree34">Если у узла нет потомков...</string>
    <string name="BinaryTree35">целевой узел просто удаляется и процесс на этом завершается.</string>
    <string name="BinaryTree36">Теперь же попробуем удалить 8.</string>
    <string name="BinaryTree37">У узла есть 1 потомок...</string>
    <string name="BinaryTree38">Удаляется целевой узел...</string>
    <string name="BinaryTree39">и узел потомка перемещается на место удаленного узла, процесс закончен.</string>
    <string name="BinaryTree4">Для примера, узел 9 больше всех узлов левого поддерева.</string>
    <string name="BinaryTree40">В заключение попробуем удалить 9.</string>
    <string name="BinaryTree41">У данного узла есть 2 потомка...</string>
    <string name="BinaryTree42">Для начала удалим целевой узел...</string>
    <string name="BinaryTree43">из левого поддерева удаленного узла находим наибольший узел...</string>
    <string name="BinaryTree44">и перемещаем его на место удаленного узла.</string>
    <string name="BinaryTree45">Поступив так, нам удалось удалить узел, сохранив целостность двоичного дерева поиска.</string>
    <string name="BinaryTree46">Кроме того, если у перемещенного узла имелись потомки, процесс повторяется рекурсивно.</string>
    <string name="BinaryTree47">Кроме того, несмотря на то, что мы в данный момент использовали наибольший узел из левого поддерева, использование самого маленького узла из правого поддерева работает также хорошо.</string>
    <string name="BinaryTree48">Сейчас посмотрим на процесс поиска узла в бинарном дереве поиска.</string>
    <string name="BinaryTree49">Для примера, попробуем найти 12.</string>
    <string name="BinaryTree5">Также узел 15 больше всех узлов его левого поддерева.</string>
    <string name="BinaryTree50">Начнём с верхнего узла.</string>
    <string name="BinaryTree51">12 меньше чем 15, переходим влево.</string>
    <string name="BinaryTree53">12 больше чем 4, значит идем вправо.</string>
    <string name="BinaryTree55">Мы нашли 12.</string>
    <string name="BinaryTree56">Как Вы можете видеть, процесс поиска при использовании бинарного дерева поиска довольно эффективен.</string>
    <string name="BinaryTree57">Однако если дерево будет похоже на прямую линию, эффективность поиска в нем сильно упадет, и будет сравнима с линейным поиском.</string>
    <string name="BinaryTree58">С другой стороны, двоичные деревья поиска которые всегда сбалансированы, называются \"самобалансированные двоичные деревья поиска\" и они способны поддерживать эффективность поиска.</string>
    <string name="BinaryTree59">На этом моменте мы завершаем объяснение структуры данных двоичное дерево поиска.</string>
    <string name="BinaryTree6">И напротив, их второе свойство в том, что все узлы меньше, чем узлы правого поддерева.</string>
    <string name="BinaryTree7">Для примера, узел 15, меньше узлов правого поддерева.</string>
    <string name="BinaryTree8">Из этих двух свойств вытекают следующие утверждения.</string>
    <string name="BinaryTree9">Первое, самый малый по значению узел находится в самом конце левого поддерева следуя от самого верхнего узла.</string>
    <string name="BinaryTreeDescription">\"Двоичные деревья поиска\" являются основными из поисковых деревьев. Вы можете изучить эту тему после покупки всех алгоритмов.</string>
    <string name="BreadthFirstSearch">Поиск в ширину</string>
    <string name="BreadthFirstSearch0">\"Поиск в ширину\" - это алгоритм поиска в графах.</string>
    <string name="BreadthFirstSearch1">Мы начнем поиск с точки A и установим точку G как целевую для поиска.</string>
    <string name="BreadthFirstSearch11">Среди кандидатов, точки C и D были добавлены одними из первых. Из них выбираем C, находящуюся слева.</string>
    <string name="BreadthFirstSearch12">Двигаемся к выбранной точке.</string>
    <string name="BreadthFirstSearch13">H достижима из текущей точки С и добавляется как новый кандидат.</string>
    <string name="BreadthFirstSearch14">Далее операции повторяются до тех пор, пока цель не будет достигнута или все точки не будут полностью исследованы.</string>
    <string name="BreadthFirstSearch2">Точки B, C и D достижимы из точки A и они будут рассмотрены в качестве кандидатов для дальнейшего поиска.</string>
    <string name="BreadthFirstSearch3">Одна точка выбирается из числа кандидатов. Основанием для отбора служит какая-либо из точек добавленной первой в качестве кандидата.</string>
    <string name="BreadthFirstSearch38">Целевая точка достигнута, значит, поиск останавливается.</string>
    <string name="BreadthFirstSearch39">Как вы можете видеть, уникальность поиска в ширину в том, что поиск ведется в ширину от точек близких к стартовой точке.</string>
    <string name="BreadthFirstSearch4">Для точек, которые становятся кандидатами одновременно, можно выбирать любую. Сейчас, для удобства, выберем точки с левой стороны.</string>
    <string name="BreadthFirstSearch40">На этом моменте мы завершаем объяснение алгоритма поиска в ширину.</string>
    <string name="BreadthFirstSearch5">Поскольку они все становятся кандидатами одновременно, в данном случае мы выберем B.</string>
    <string name="BreadthFirstSearch6">Двигаемся к выбранной точке.</string>
    <string name="BreadthFirstSearch7">E и F достижимы из текущей точки B и будут добавлены в качестве новых кандидатов.</string>
    <string name="BreadthFirstSearch8">Кандидаты организуются с помощью принципа FIFO (первым пришёл — первым ушёл) поэтому мы можем использовать структуру данных \"очередь\".</string>
    <string name="BreadthFirstSearch9">Более детальное объяснение термина \"Очередь\", Вы можете найти в другом разделе этого приложения</string>
    <string name="BubbleSort">Пузырьковая сортировка</string>
    <string name="BubbleSort0">\"Пузырьковая сортировка\" - это один из алгоритмов, используемых для сортировки последовательности чисел.</string>
    <string name="BubbleSort1">Весы, расположенные в правой стороне последовательности, будут сравнивать числа с левой и правой сторон.</string>
    <string name="BubbleSort16">Весы достигли левой стороны.</string>
    <string name="BubbleSort2">Сейчас они сравнят 7 и 6.</string>
    <string name="BubbleSort20">После одного прохода, минимальное значение последовательности переместилось в левую сторону.</string>
    <string name="BubbleSort21">Число с левой стороны считается полностью отсортированным...</string>
    <string name="BubbleSort22">и весы перемещаются назад в правую сторону.</string>
    <string name="BubbleSort23">Те же операции повторяются до тех пор, пока числа не будут полностью отсортированы.</string>
    <string name="BubbleSort25">Сортировка выполнена.</string>
    <string name="BubbleSort26">На этом моменте мы завершаем объяснение пузырьковой сортировки.</string>
    <string name="BubbleSort3">После сравнения, если число справа окажется меньше, то числа меняются местами.</string>
    <string name="BubbleSort4">6 меньше 7, таким образом, числа поменялись местами.</string>
    <string name="BubbleSort5">После сравнения весы двигаются на одну позицию влево.</string>
    <string name="BubbleSort6">Числа снова сравниваются.</string>
    <string name="BubbleSort7">В этом случае 6 больше чем 4 и позиции чисел остаются прежними.</string>
    <string name="BubbleSort8">Весы сдвигаются влево на одну позицию.</string>
    <string name="BubbleSort9">Эта операция повторяется до тех пор, пока они не достигнут левой стороны.</string>
    <string name="BuyAllAlgorithms">Купить все алгоритмы: %@</string>
    <string name="BuyAllAlgorithmsAndroid">Купить все алгоритмы:</string>
    <string name="CKC">Криптосистема с общим ключом</string>
    <string name="CKC0">\"Криптосистема с общим ключом\" - это система шифрования, которая использует общий ключ для шифрования и расшифрования.</string>
    <string name="CKC1">Давайте посмотрим, каким образом происходит обмен данными с помощью криптосистемы с общим ключом.</string>
    <string name="CKC10">Сторона B использует ключ, для расшифровки, полученной от стороны A шифрограммы.</string>
    <string name="CKC11">И сторона B получает исходные данные.</string>
    <string name="CKC12">Если Вы зашифруете свои данные, нет повода для беспокойства, даже если кто-то перехватит их.</string>
    <string name="CKC13">Использование одинакового ключа для шифрования данных и их расшифрования, является свойством криптосистемы с общим ключом.</string>
    <string name="CKC14">На схеме показаны некоторые методы, используемые в криптосистеме с общим ключом.</string>
    <string name="CKC15">На сегодняшний день, широко используется метод называемый \"AES\".</string>
    <string name="CKC16">Давайте порассуждаем о некоторых моментах, связанных с криптосистемой с общим ключом.</string>
    <string name="CKC17">Вернемся к предыдущей ситуации. В данный момент, сторона B только что получила шифрограмму, отправленную стороной A.</string>
    <string name="CKC18">Возможно, что шифрограмма была перехвачена стороной X.</string>
    <string name="CKC19">Далее, в силу того что стороны A и B не являются хорошими знакомыми...</string>
    <string name="CKC2">Допустим, сторона A хочет отправить данные стороне B через Интернет.</string>
    <string name="CKC20">подумаем о том, что произойдет, если сторона B не знает, какой ключ используется для шифрования.</string>
    <string name="CKC21">Стороне A необходимо каким-то образом передать ключ стороне B.</string>
    <string name="CKC22">Таким же образом, как это было сделано с шифрограммой, сторона A отправляет ключ через Интернет.</string>
    <string name="CKC23">Стороне B, используя ключ, полученный от стороны A...</string>
    <string name="CKC24">удается расшифровать шифрограмму.</string>
    <string name="CKC25">Однако, есть вероятность, что сторона X перехватит их ключ.</string>
    <string name="CKC26">В этом случае, сторона X, используя полученный ключ, тоже может расшифровать шифрограмму.</string>
    <string name="CKC27">Мы видим, что существует проблема, связанная со способом передачи ключа.</string>
    <string name="CKC28">Так как сторона A, позаботилась о шифровании ключа, то теперь она может не беспокоиться о перехвате его стороной X.</string>
    <string name="CKC29">А так как для компьютера ключ не более чем некоторое количество данных.</string>
    <string name="CKC3">Доставляемые данные, проходят множество устройств и сетей в процессе доставки.</string>
    <string name="CKC30">Следовательно...</string>
    <string name="CKC31">мы можем зашифровать его новым ключом.</string>
    <string name="CKC32">И эта шифрограмма содержит ключ...</string>
    <string name="CKC33">отправленный стороне B.</string>
    <string name="CKC34">В данный момент, у стороны B имеется зашифрованные данные, а также зашифрованный ключ для расшифровки этих данных.</string>
    <string name="CKC35">Существует шанс, что сторона X перехватит зашифрованный ключ.</string>
    <string name="CKC36">Теперь же, всё, что остаётся - это передать новый ключ, который был использован, для шифрования ключа, который был передан стороне B.</string>
    <string name="CKC37">но как сторона A, должна передать этот новый ключ стороне B?</string>
    <string name="CKC38">Если его не зашифровать, то сторона X может точно так же перехватить его и использовать для расшифрования.</string>
    <string name="CKC39">Если же мы зашифруем его, нам понадобится новый ключ, и данная проблема повторится снова.</string>
    <string name="CKC4">Таким образом, если пытаться отправить данные в неизменном виде...</string>
    <string name="CKC40">В заключение, можно сказать, что криптосистемы с общим ключом нуждаются в безопасном методе передачи ключей.</string>
    <string name="CKC41">Эта проблема называется \"проблемой доставки ключа\".</string>
    <string name="CKC42">Существует два варианта решения данной проблемы: 1) методы, использующие протоколы обмена ключами и... 2) методы, использующие криптосистемы с открытым ключом. О каждой из них, рассказывается более детально в другом разделе данного приложения.</string>
    <string name="CKC43">На этом моменте мы завершаем объяснение криптосистем с общим ключом.</string>
    <string name="CKC5">существует шанс их перехвата злонамеренной третьей стороной.</string>
    <string name="CKC6">По этой причине необходимо зашифровать данные перед отправкой, если Вы хотите чтобы они остались приватными.</string>
    <string name="CKC7">Используем ключ...</string>
    <string name="CKC8">данные зашифрованы в шифрограмму.</string>
    <string name="CKC9">Шифрограмма отправлена стороне B.</string>
    <string name="Cancel">Отменить</string>
    <string name="CannotPayAlert">Покупки ограничены. Пожалуйста, измените настройки устройства.</string>
    <string name="CannotRestoreAlert">Покупки не были подтверждены. Пожалуйста, убедитесь что Вы вошли в правильный аккаунт iTunes, в котором Вы делали покупку.</string>
    <string name="CannotRestoreAlertAndroid">Данные покупки не подтверждены. Пожалуйста, проверьте, что Вы вошли в правильный аккаунт магазина Google Play который Вы использовали когда делали покупку.</string>
    <string name="ChangeConfirmation">Вы подтверждаете изменение настроек?</string>
    <string name="ClusteringSection">Кластеризация</string>
    <string name="CompressionSection">Сжатие данных</string>
    <string name="Config">Настройки</string>
    <string name="DataStructureSection">Структуры данных</string>
    <string name="DepthFirstSearch">Поиск в глубину</string>
    <string name="DepthFirstSearch0">\"Поиск в глубину\" - это алгоритм поиска в графах.</string>
    <string name="DepthFirstSearch1">Мы начнем поиск с точки А, а точку G возьмём в качестве целевой.</string>
    <string name="DepthFirstSearch11">К кандидатам последними были добавлены E и F. Выберем E с левой стороны.</string>
    <string name="DepthFirstSearch12">Мы переходим к выбранной точке.</string>
    <string name="DepthFirstSearch13">K достижима из текущей точки E и добавлена как новый кандидат.</string>
    <string name="DepthFirstSearch14">Далее, такая же операция повторяется до тех пор, пока цель не будет достигнута или не будут полностью исследованы все точки.</string>
    <string name="DepthFirstSearch2">Точки B, C и D достижимы из точки A, они будут рассмотрены в качестве кандидатов для следующей точки, в которую мы переместимся.</string>
    <string name="DepthFirstSearch28">Цель достигнута, значит, поиск останавливается.</string>
    <string name="DepthFirstSearch29">Как можно видеть, поиск в глубину уникален в том, как он \"копает глубже\" по определенному пути.</string>
    <string name="DepthFirstSearch3">Одна точка выбирается из числа кандидатов. Основой для выбора является то, какая точка была добавлена в качестве последнего кандидата.</string>
    <string name="DepthFirstSearch30">На этом моменте, мы завершаем объяснение поиска в глубину.</string>
    <string name="DepthFirstSearch4">Для точек одновременно ставших кандидатами, нет разницы, какую из них выбрать. В этот раз, для удобства, мы выберем точки с левой стороны.</string>
    <string name="DepthFirstSearch5">Поскольку все они стали кандидатами в то же время в данном случае мы выберем B.</string>
    <string name="DepthFirstSearch6">Мы переходим к выбранной точке.</string>
    <string name="DepthFirstSearch7">Точки E и F достижимы из текущей точки B и добавлены в качестве новых кандидатов.</string>
    <string name="DepthFirstSearch8">Точки, которые рассматриваются в качестве кандидатов, обрабатываются по методу \"последний вошел - первый вышел\" (LIFO), поэтому мы можем использовать структуру данных \"стек\".</string>
    <string name="DepthFirstSearch9">Структура данных \"Стек\" подробнее объясняется в другом месте данного приложения.</string>
    <string name="DiffieHellman">Протокол обмена ключами Диффи-Хеллмана</string>
    <string name="DiffieHellman0">\"Протокол обмена ключами Диффи-Хеллмана\" - это метод, позволяющий двум сторонам безопасно обмениваться ключами.</string>
    <string name="DiffieHellman1">Перед использованием математических формул, давайте посмотрим на более концептуальное пояснение на схеме.</string>
    <string name="DiffieHellman10">он может быть использован как компонент для создания нового ключа.</string>
    <string name="DiffieHellman11">В этом примере на схеме, с помощью ключей P и P-S, создан новый ключ P-P-S.</string>
    <string name="DiffieHellman12">Другими словами, любой комбинированный ключ, может быть скомбинирован с другим ключом.</string>
    <string name="DiffieHellman13">Давайте попробуем безопасно обменяться ключами между сторонами А и B, используя данный метод.</string>
    <string name="DiffieHellman14">Сначала, сторона A готовит ключ P. Ключ P может без проблем быть известен кому угодно.</string>
    <string name="DiffieHellman15">Сторона A отправляет ключ P стороне B.</string>
    <string name="DiffieHellman16">Далее, стороны A и B готовят секретные ключи SA и SB, соответственно.</string>
    <string name="DiffieHellman17">Ключи SA и SB нужно контролировать так, чтобы никто другой их не получил.</string>
    <string name="DiffieHellman18">Сторона A создает новый ключ P-SA из ключа P и секретного ключа SA.</string>
    <string name="DiffieHellman19">Аналогично, сторона B создает новый ключ P-SB из ключа P и секретного ключа SB.</string>
    <string name="DiffieHellman2">Допустим, есть специальный метод для объединения двух ключей.</string>
    <string name="DiffieHellman20">Сторона A отправляет ключ P-SA стороне B.</string>
    <string name="DiffieHellman21">И сторона B отправляет ключ P-SB стороне A.</string>
    <string name="DiffieHellman22">Сторона A объединяет секретный ключ SA с полученным от стороны B ключом P-SB для получения нового ключа P-SA-SB.</string>
    <string name="DiffieHellman23">Аналогично, сторона B объединяет секретный ключ SB с полученным от стороны A ключом P-SA для получения нового ключа P-SA-SB.</string>
    <string name="DiffieHellman24">Таким образом, обе стороны смогли получить ключ P-SA-SB.</string>
    <string name="DiffieHellman25">И данный ключ будет использован как ключ для шифрования/дешифрования.</string>
    <string name="DiffieHellman26">Давайте проверим безопасность данного метода обмена ключами.</string>
    <string name="DiffieHellman27">Так как ключи P, P-SA, P-SB отправлены через Интернет...</string>
    <string name="DiffieHellman28">существует вероятность того, что они будут перехвачены третьей, злонамеренной стороной X.</string>
    <string name="DiffieHellman29">Однако сторона X не может создать ключ P-SA-SB из полученных ключей.</string>
    <string name="DiffieHellman3">Когда ключи P и S объединяются с помощью данного метода...</string>
    <string name="DiffieHellman30">Кроме того, так как ключи не могут быть разобраны на составляющие, секретные ключи SA и SB не могут быть получены.</string>
    <string name="DiffieHellman31">Следовательно, из-за того что сторона X не может создать ключ P-SA-SB, данный метод обмена ключами является безопасным.</string>
    <string name="DiffieHellman32">Далее, попробуем объяснить данный метод обмена ключами в математических терминах.</string>
    <string name="DiffieHellman33">Для начала, объясним операцию \"mod\".</string>
    <string name="DiffieHellman34">Операция \"mod\" это операция которая находит остаток от деления.</string>
    <string name="DiffieHellman35">Результатом операции A mod B будет C, которое является остатком от A деленного на B.</string>
    <string name="DiffieHellman36">Посмотрим на несколько примеров, с конкретными цифрами.</string>
    <string name="DiffieHellman37">Сейчас, поразмышляем о протоколе обмена ключами, используя математические термины.</string>
    <string name="DiffieHellman38">Ключ P, который был создан в самом начале и был опубликован, будет выражен как 2 числа P и G.</string>
    <string name="DiffieHellman39">P это очень большое простое число. G будет выбрано из простых чисел P, и является так называемым генератором (или первообразным корнем) чисел.</string>
    <string name="DiffieHellman4">новый ключ P-S, построен из компонент ключей P и S.</string>
    <string name="DiffieHellman40">Существует фиксированное число первообразных корней для всех чисел P.</string>
    <string name="DiffieHellman41">Для начала, сторона A приготовит простое число P и первообразный корень G. Эти числа могут быть без проблем известны кому угодно.</string>
    <string name="DiffieHellman42">Сторона A отправляет простое число P и первообразный корень G стороне B.</string>
    <string name="DiffieHellman43">Затем, стороны A и B выбирают секретные числа X и Y, соответственно.</string>
    <string name="DiffieHellman44">Кроме того, секретные числа X и Y должны быть меньше P-2.</string>
    <string name="DiffieHellman45">Обе стороны A и B выполняют следующие вычисления: возводят первообразный корень G в степень их секретного числа, затем вычисляют остаток от деления (mod) на простое число P.</string>
    <string name="DiffieHellman46">Этот расчет концептуально похож на синтез.</string>
    <string name="DiffieHellman47">Стороны A и B отправляют результаты их вычислений друг другу.</string>
    <string name="DiffieHellman48">Далее, стороны A и B возводят в степень их секретного числа, то что они получили от другой стороны и снова вычисляют остаток от деления на P.</string>
    <string name="DiffieHellman49">В результате у них получится одинаковое число.</string>
    <string name="DiffieHellman5">У данного метода объединения есть 2 особенности.</string>
    <string name="DiffieHellman50">Таким образом, стороны A и B смогли обменяться числами, используемыми в качестве ключей.</string>
    <string name="DiffieHellman51">Попробуем убедится в безопасности данного метода обмена ключами.</string>
    <string name="DiffieHellman52">Так как числа отправляются через Интернет...</string>
    <string name="DiffieHellman53">Существует шанс их перехвата стороной X.</string>
    <string name="DiffieHellman54">Однако, числа используемые в качестве ключей, не могут быть вычислены из чисел имеющихся у стороны X.</string>
    <string name="DiffieHellman55">Так же как и не могут быть вычислены секретные числа X и Y.</string>
    <string name="DiffieHellman56">Метод нахождения X в выражении (первообразный корень G в степени X mod простое число P) называется \"проблема дискретного логарифма\" и до сих пор нет эффективного решения данной проблемы.</string>
    <string name="DiffieHellman57">Можно сказать, что протокол обмена ключами Диффи-Хеллмана это метод, который использует проблему дискретного логарифма.</string>
    <string name="DiffieHellman58">На этом моменте мы завершаем объяснение протокола обмена ключами Диффи-Хеллмана.</string>
    <string name="DiffieHellman6">Первая особенность состоит в том, что даже если у кого-то есть ключ P и созданный из него комбинированный ключ P-S...</string>
    <string name="DiffieHellman7">невозможно извлечь из него ключ S.</string>
    <string name="DiffieHellman8">Другими словами, даже если Вы синтезировали ключ, вы не можете разъединить его на компоненты.</string>
    <string name="DiffieHellman9">Вторая особенность состоит в том, что если какой-то ключ состоит из других ключей...</string>
    <string name="DiffieHellmanDescription">\"Алгоритм обмена ключами Диффи -Хеллмана\" это способ безопасного обмена ключами между двумя сторонами. Вы можете изучить эту тему после покупки всех алгоритмов.</string>
    <string name="DigitalCertification">Цифровые сертификаты</string>
    <string name="DigitalCertification0">У криптосистем с открытым ключом и систем цифровых подписей есть проблема с определением того, кому принадлежит открытый ключ.</string>
    <string name="DigitalCertification1">Поэтому, когда сторона А пытается отправить открытый ключ стороне В...</string>
    <string name="DigitalCertification10">Центры сертификации имеют собственные открытые ключи (PC) и секретный ключ (SC), которые они подготавливают сами.</string>
    <string name="DigitalCertification11">Сторона А подготавливает свою персональную информацию, включающую её открытый ключ (PA) и адрес электронной почты...</string>
    <string name="DigitalCertification12">и отправляет это в центр сертификации.</string>
    <string name="DigitalCertification13">После подтверждения, центр сертификации использует его секретный ключ (SC) и создает из данных, предоставленных стороной А, электронную подпись.</string>
    <string name="DigitalCertification14">Более подробное разъяснение системы цифровой подписи может быть найдено в другом разделе данного приложения.</string>
    <string name="DigitalCertification15">Далее, созданная электронная подпись и данные помещаются в один файл...</string>
    <string name="DigitalCertification16">и отправляются стороне А.</string>
    <string name="DigitalCertification17">Данный файл, становится цифровым сертификатом стороны А.</string>
    <string name="DigitalCertification18">Сторона А передает полученный цифровой сертификат стороне В.</string>
    <string name="DigitalCertification19">Сторона В подтверждает, что адрес электронной почты, в полученном сертификате, действительно принадлежит стороне А.</string>
    <string name="DigitalCertification2">злонамеренная третья сторона может подменить открытый ключ получателя другим ключом, без его ведома.</string>
    <string name="DigitalCertification20">После этого, сторона В получает открытый ключ центра сертификации...</string>
    <string name="DigitalCertification21">и проверяет что цифровая подпись в сертификате это действительно подпись центра сертификации.</string>
    <string name="DigitalCertification22">Цифровая подпись в сертификате, может быть проверена только с помощью открытого ключа (PC) из центра сертификации.</string>
    <string name="DigitalCertification23">Другими словами, если результат проверки сертификата был положительным, то цифровой сертификат, без сомнений, был выдан центром сертификации.</string>
    <string name="DigitalCertification24">После того, как подтвердилось что цифровой сертификат принадлежит стороне А и был выдан центром сертификации, из цифровой подписи извлекается открытый ключ стороны А.</string>
    <string name="DigitalCertification25">На этом передача открытого ключа от стороны А к стороне В завершена.</string>
    <string name="DigitalCertification26">Давайте посмотрим, если есть какие-то проблемы с этим способом передачи открытого ключа.</string>
    <string name="DigitalCertification27">Допустим, злонамеренная сторона Х выдаёт себя за сторону А и пытается передать свой открытый ключ.</string>
    <string name="DigitalCertification28">Однако, у стороны В нет оснований доверять ключу, который не был передан в качестве цифрового сертификата.</string>
    <string name="DigitalCertification29">Что же произойдет если сторона Х, которая выдает себя за сторону А, попытается сделать свой собственный ключ, зарегистрированный в центре сертификации?</string>
    <string name="DigitalCertification3">Используя систему \"цифровых сертификатов\" мы можем гарантировать, кто является создателем открытых ключей.</string>
    <string name="DigitalCertification30">В таком случае у стороны Х нет доступа к учетной записи электронной почты стороны А, таким образом сторона Х не сможет получить сертификат.</string>
    <string name="DigitalCertification31">Сторона Х может создать только те сертификаты, которые будут использовать электронный адрес этой стороны. Следовательно, она не сможет получить сертификат стороны А.</string>
    <string name="DigitalCertification32">Как вы увидели, с помощью системы цифрового сертификата, можно проверить владельца открытого ключа.</string>
    <string name="DigitalCertification33">Итак, ранее мы сказали, что сторона В получила открытый ключ центра сертификации...</string>
    <string name="DigitalCertification34">но это вызывает вопрос.</string>
    <string name="DigitalCertification35">Был ли полученный открытый ключ (PC), который получила сторона В, действительно создан центром сертификации?</string>
    <string name="DigitalCertification36">Из-за того что нет никакого способа подтвердить, кто создал сам ключ, он может быть создан стороной Х, которая выдаёт себя за центр сертификации.</string>
    <string name="DigitalCertification37">Другими словами, те же проблемы, которые мы видели у открытых ключей случаются и здесь.</string>
    <string name="DigitalCertification38">На самом деле, этот открытый ключ (PC) центра сертификации...</string>
    <string name="DigitalCertification39">также передается цифровым сертификатом.</string>
    <string name="DigitalCertification4">Посмотрим более детально, как работает система цифровых сертификатов.</string>
    <string name="DigitalCertification40">И сторона, которая \"подписала\" цифровой сертификат центра сертификации...</string>
    <string name="DigitalCertification41">является вышестоящим центром по сертификации.</string>
    <string name="DigitalCertification42">Центры сертификации формируют древовидную структуру, в которой центры с более высоким классом создают цифровые подписи для центров классами ниже.</string>
    <string name="DigitalCertification43">Чтобы увидеть, как функционирует эта структура центров сертификации...</string>
    <string name="DigitalCertification44">предположим для примера, что у нас есть центр сертификации, которому полностью доверяет общество.</string>
    <string name="DigitalCertification45">Даже если новая компания G желает начать работу в качестве центра сертификации, у неё нет авторитета в обществе.</string>
    <string name="DigitalCertification46">Таким образом, у компании G есть цифровой сертификат, выданный компанией Y. Разумеется, компания Y проверит, что компания G сможет адекватно исполнять обязанности центра сертификации.</string>
    <string name="DigitalCertification48">В результате, компания G может рекламировать себя как компания, которая заслужила доверие компании Y.</string>
    <string name="DigitalCertification49">Таким образом, крупные организации обеспечивают доверие к более мелким организациям, формируя древовидную структуру.</string>
    <string name="DigitalCertification5">Допустим, что сторона А является владельцем ключей: открытого и секретного...</string>
    <string name="DigitalCertification50">Итак, кто же находится на вершине дерева центров сертификации?</string>
    <string name="DigitalCertification51">Центры сертификации, которые расположены на самом верхнем уровне называются \"корневыми центрами сертификации (root CA)\" и они сами подтверждают свою надежность.</string>
    <string name="DigitalCertification52">Кроме того, сертификаты, которые они сами сертифицируют , называются \"коренными сертификатами\".</string>
    <string name="DigitalCertification53">Если корневой центр сертификации не является надежной организацией, то он не будет использоваться.</string>
    <string name="DigitalCertification54">Таким образом, значительное число из них являются организациями, которые уже имеют авторитет в обществе, такие как крупные компании и государственные учреждения.</string>
    <string name="DigitalCertification55">Теперь, когда мы рассмотрели передачу открытых ключей между физическими лицами...</string>
    <string name="DigitalCertification56">цифровые сертификаты также используются в процессе обмена данными с веб сайтами.</string>
    <string name="DigitalCertification57">Получив сертификат, содержащий открытый ключ с веб-сайта, мы можем быть уверены, что сайт не подделан третьей стороной.</string>
    <string name="DigitalCertification58">Такой сертификат называется \" сертификатом сервера\", и он также выдан центром сертификации.</string>
    <string name="DigitalCertification59">В случае физического лица, сертификат привязывается к адресу электронной почты...</string>
    <string name="DigitalCertification6">она готова отправить открытый ключ (PA) стороне В.</string>
    <string name="DigitalCertification60">но в случае серверного сертификата, он привязывается к домену.</string>
    <string name="DigitalCertification61">Серверный сертификат гарантирует, что открытый ключ был выдан организацией, которая управляет доменом, к которому привязан сертификат.</string>
    <string name="DigitalCertification62">Другими словами, подтверждается, что организация, управляющая доменом вебсайта и управляющая сервером, на котором хранится содержимое сайта, это одна и та же организация.</string>
    <string name="DigitalCertification63">Таким образом, цифровые сертификаты являются социальными системами, удостоверяющими создателей открытых ключей с помощью центров сертификации.</string>
    <string name="DigitalCertification64">На этом моменте, объяснение цифровых сертификатов заканчивается.</string>
    <string name="DigitalCertification7">Сначала, сторона А должна запросить центр сертификации выдать ей сертификат, с указанием, что она является владельцем открытого ключа (PA).</string>
    <string name="DigitalCertification8">Центр сертификации, это организация, которая управляет цифровыми сертификатами. В принципе, кто угодно может стать такой организацией и их существует очень много.</string>
    <string name="DigitalCertification9">Поэтому, безопаснее использовать надежные организации, например правительство или крупные компании, которые проходят проверку.</string>
    <string name="DigitalCertificationDescription">\"Цифровой сертификат\" это система, подтверждающая создателя открытого ключа. Вы можете изучить эту тему после покупки всех алгоритмов.</string>
    <string name="DigitalSignature">Цифровые подписи</string>
    <string name="DigitalSignature0">\"Цифровая подпись\" - это система гарантирующая достоверность авторства сообщения...</string>
    <string name="DigitalSignature1">в дополнение к аутентификации и обнаружения подделки сообшения, данных двух функций, которые реализованы в кодах аутентификации сообщений.</string>
    <string name="DigitalSignature10">Для примера, после того как сторона А отправила сообщение стороне В, сторона В может заявлять что она является создателем сообщения.</string>
    <string name="DigitalSignature100">Строго говоря, существуют даже случаи, когда методы вычисления подписи отличаются от шифрования.</string>
    <string name="DigitalSignature101">Однако, их объединяет особенность использования разделяемых ключей для создания подписи и использование открытых ключей для её проверки.</string>
    <string name="DigitalSignature11">Также, из-за того, что они используют разделяемые ключи, необходимо сделать новый ключ, если сторона А захочет отправить сообщение кому-либо кроме стороны В.</string>
    <string name="DigitalSignature12">С другой стороны, вместо использования MAC, система цифровой подписи использует данные, которые может создать только отправитель, в качестве основы для идентификации. Эти данные называются \"электронная подпись\".</string>
    <string name="DigitalSignature13">Давайте взглянем на описание процесса.</string>
    <string name="DigitalSignature14">\"Пдп.\" на картинке это цифровая подпись и она может быть создана только стороной А.</string>
    <string name="DigitalSignature15">Поэтому, когда приходит сообщение с цифровой подписью стороны А, гарантируется что отправитель действительно сторона А.</string>
    <string name="DigitalSignature16">Получатель сообщения, сторона В, может подтвердить, что цифровая подпись принадлежит стороне А, однако сторона В не сможет создать такую же цифровую подпись.</string>
    <string name="DigitalSignature17">В отличие от кодов аутентификации сообщений, разделяемый ключ не используется и сторона А может отправить своё сообщение нескольким людям, используя одну и ту же цифровую подпись.</string>
    <string name="DigitalSignature2">Давайте посмотрим еще раз на коды аутентификации сообщений.</string>
    <string name="DigitalSignature20">Давайте внимательнее посмотрим на то, как создается цифровая подпись.</string>
    <string name="DigitalSignature21">В то время как ключ, используемый в процессе создания MAC был общим...</string>
    <string name="DigitalSignature22">когда же мы создаем цифровую подпись, мы пользуемся процессом \"криптосистемы с открытым ключом\".</string>
    <string name="DigitalSignature23">Более детальное объяснение \"криптосистем с открытым ключом\" можно найти в другом разделе данного приложения. Здесь же, мы даём упрощенное пояснение как она работает.</string>
    <string name="DigitalSignature24">Сторона А зашифровала данные и готова отправлять их стороне В.</string>
    <string name="DigitalSignature25">Сначала получатель, сторона В, готовит публичный ключ (P) и секретный ключ (S).</string>
    <string name="DigitalSignature26">Сторона В отправляет публичный ключ стороне А.</string>
    <string name="DigitalSignature27">Сторона А использует публичный ключ, для шифрования данных.</string>
    <string name="DigitalSignature28">Затем она отправляет зашифрованные данные стороне В.</string>
    <string name="DigitalSignature29">Сторона В расшифровывает полученную шифрограмму и получает исходные данные, завершая обмен.</string>
    <string name="DigitalSignature3">Система аутентификации сообщений присваивает MAC сообщению для идентификации отправителя сообщения, который является владельцем ключа шифрования.</string>
    <string name="DigitalSignature30">Итак, в криптосистеме с открытым ключом, открытый ключ был использован для шифрования, а секретный ключ, для расшифрования данных.</string>
    <string name="DigitalSignature31">Таким образом, любой может зашифровать данные с помощью открытого ключа...</string>
    <string name="DigitalSignature32">но из-за того, что секретный ключ доступен только стороне В, гарантируется что только она может осуществить расшифрование.</string>
    <string name="DigitalSignature33">А что же произойдет, если мы обратим процесс, используя секретный ключ для шифрования, а открытый ключ для расшифрования?</string>
    <string name="DigitalSignature34">В данном случае, у стороны А есть секретный ключ, только она может зашифровать данные, но шифрограмма может быть расшифрована кем угодно, у кого есть открытый ключ.</string>
    <string name="DigitalSignature35">С точки зрения метода шифрования это абсолютно не имеет смысла, но если посмотреть на это с другой стороны, можно увидеть что создателем сообщения гарантировано является сторона А, у которой есть секретный ключ.</string>
    <string name="DigitalSignature36">В системе цифровой подписи, данная шифрограмма, которую может создать только сторона А используется в качестве подписи.</string>
    <string name="DigitalSignature37">Давайте посмотрим на то, как работает обмен сообщениями, с использованием цифровой подписи.</string>
    <string name="DigitalSignature38">Вначале, сторона А готовит сообщение, которое она отправляет и секретные и открытые ключи.</string>
    <string name="DigitalSignature39">Из-за того, что отправитель сообщения подготавливает секретные и открытые ключи, данный метод отличается от криптосистемы с открытым ключом.</string>
    <string name="DigitalSignature4">Сейчас, для удобства, давайте отправим сообщение не шифруя его.</string>
    <string name="DigitalSignature40">Сторона А передает открытый ключ стороне В.</string>
    <string name="DigitalSignature41">Затем, она зашифровывает сообщение секретным ключом.</string>
    <string name="DigitalSignature42">Шифрограмма будет служить в качестве подписи и обозначена на схеме как \"Пдп.\".</string>
    <string name="DigitalSignature43">Сторона А отправляет сообщение и подпись стороне В.</string>
    <string name="DigitalSignature44">Сторона В расшифровывает шифрограмму используя открытый ключ.</string>
    <string name="DigitalSignature45">Сторона В подтвердила, что расшифрованное сообщение совпадает с полученным сообщением, обмен завершается .</string>
    <string name="DigitalSignature46">Шифрограмма, которая была расшифрована открытым ключом стороны А, могла быть создана только ей.</string>
    <string name="DigitalSignature47">Таким образом, мы можем подтвердить, что сторона А - это тот, кто отправил сообщение и что сообщение не было подделано.</string>
    <string name="DigitalSignature48">Ещё из-за того, что подпись стороны А не может быть создана стороной В, которая владеет только открытым ключом, функция предотвращения отказа авторства также выполняется.</string>
    <string name="DigitalSignature49">Однако криптосистемы с открытым ключом имеют свойство , как правило, потреблять больше времени для шифрования и дешифрования.</string>
    <string name="DigitalSignature5">Сторона А отправляет сообщение и MAC, а также ключ, используемый для создания MAC стороне B.</string>
    <string name="DigitalSignature50">Поэтому, вместо того, чтобы шифровать сообщения сразу...</string>
    <string name="DigitalSignature51">чтобы сократить время расчета, сначала, определяется хэш сообщения...</string>
    <string name="DigitalSignature52">затем хэш шифруется и используется в качестве подписи.</string>
    <string name="DigitalSignature53">Более детальное объяснение хэширования может быть найдено в статье \"Хэш функции\" данного приложения.</string>
    <string name="DigitalSignature54">Сообщение и подпись отправляются стороне В.</string>
    <string name="DigitalSignature55">Таким же образом, сторона В вычисляет хэш полученного сообщения.</string>
    <string name="DigitalSignature56">Далее, полученная подпись расшифровывается с помощью открытого ключа, и сравнивается с вычисленным хэш значением.</string>
    <string name="DigitalSignature57">Если подтверждается, что эти хеш значения совпали, то обмен с использованием электронной подписи заканчивается.</string>
    <string name="DigitalSignature58">Цифровые подписи обеспечивают функции проверки подлинности, выявления подделки сообщений и предотвращения отказа авторства сообщения, но существует одна проблема.</string>
    <string name="DigitalSignature59">Сторона В, в процессе обмена с использованием электронной подписи, полагает что сторона А была отправителем сообщения...</string>
    <string name="DigitalSignature6">Сторона B заново генерирует MAC используя полученное сообщение и ключ, подтверждая что полученный MAC равен сгенерированному.</string>
    <string name="DigitalSignature60">но в действительности, мы не можем быть полностью уверены в том, что некая злонамеренная сторона X не проводит обмен, выдавая себя в качестве стороны А.</string>
    <string name="DigitalSignature61">Основная причина этой проблемы заключается в том, что в криптосистеме с открытым ключом, мы не знаем, кому этот открытый ключ принадлежит.</string>
    <string name="DigitalSignature62">Нет такой части в открытом ключе, которая бы однозначно указывала кто создал его.</string>
    <string name="DigitalSignature63">Поэтому есть возможность, что открытый ключ был создан кем-то кто выдает себя за сторону А...</string>
    <string name="DigitalSignature64">также как и вероятность того, что сторона А действительно создала публичный ключ, но в этом нет уверенности.</string>
    <string name="DigitalSignature66">Данная проблема может быть решена с помощью системы \"цифрового сертификата\".</string>
    <string name="DigitalSignature67">В цифровом сертификате, информация о создателе открытого ключа является частью ключа и обрабатывается как единый сертификат.</string>
    <string name="DigitalSignature68">Более детальное объяснение \"цифровых сертификатов\" можно найти в другом разделе данного приложения.</string>
    <string name="DigitalSignature69">На этом моменте мы завершаем объяснение цифровых подписей.</string>
    <string name="DigitalSignature8">Исходя из этого, он может быть уверен, что сторона А отправляла сообщение и оно не было подделано.</string>
    <string name="DigitalSignature9">Однако, поскольку коды аутентификации сообщений используют разделяемый ключ, у того, кто владеет ключом, остаётся возможность представляться отправителем сообщения.</string>
    <string name="DigitalSignatureDescription">\"Электронная подпись\" это система, решающая задачи подмены, фальсификации и достоверности авторства сообщений. Вы можете изучить эту тему после покупки всех алгоритмов.</string>
    <string name="Dijkstra">Алгоритм Дейкстры</string>
    <string name="Dijkstra0">\"Алгоритм Дейкстры\" - это алгоритм, используемый для нахождения кратчайшего пути между точками графа. Это более эффективный метод, чем алгоритм Беллмана-Форда.</string>
    <string name="Dijkstra1">Для начала, установим стартовый вес каждой вершины. Вес начальной вершины установим равным 0, для остальных установим его равным бесконечности.</string>
    <string name="Dijkstra10">Определившись с кратчайшим путем, двигаемся к вершине B.</string>
    <string name="Dijkstra100">Кратчайший он потому, что если бы мы выбрали путь, проходящий через точку С, его цена была бы выше, чем у нашего текущего пути.</string>
    <string name="Dijkstra101">Путь A-B-D появился в результате выбора вершин с наименьшим весом. Таким образом, мы знаем, что если будем проходить через любую другую вершину, двигаясь к D, такой путь будет более длинным и не оптимальным.</string>
    <string name="Dijkstra102">В данном случае, вершины B и C становятся кандидатами.</string>
    <string name="Dijkstra11">Вершины, достижимые из текущей вершины, рассматриваются в качестве кандидатов. В данном случае это вершины C, D и E.</string>
    <string name="Dijkstra12">Таким же методом, вычисляем цену для каждого кандидата.</string>
    <string name="Dijkstra13">Полная цена перемещения к вершине С из B равна 2 + 6 = 8, что больше текущего значения 5, значит в вес не изменяется.</string>
    <string name="Dijkstra14">Веса остальных вершин (D и E) изменились.</string>
    <string name="Dijkstra15">Из вершин-кандидатов мы выбираем одну с наименьшим весом. В данном случае этой вершиной является вершина D.</string>
    <string name="Dijkstra16">Мы определили, что путь A-B-D является кратчайшим путём от стартовой вершины к вершине D.</string>
    <string name="Dijkstra17">Таким образом, алгоритм Дейкстры определил кратчайший путь к каждой точке в графе. По одному пути за раз.</string>
    <string name="Dijkstra18">Та же операция повторяется снова, пока не достигнем последней вершины G.</string>
    <string name="Dijkstra2">Начинаем с первой вершины.</string>
    <string name="Dijkstra3">Начиная с текущего расположения, начинаем искать неисследованные вершины. Когда они будут найдены, они становятся кандидатами для нахождения следующих вершин.</string>
    <string name="Dijkstra35">Мы достигли последней вершины G, поиск останавливается.</string>
    <string name="Dijkstra36">В итоге, для того чтобы показать нам кратчайшие пути подсвечиваются оранжевым цветом.</string>
    <string name="Dijkstra37">Толстая линия - это кратчайший путь к вершине G.</string>
    <string name="Dijkstra38">Как Вы можете видеть, по сравнению с алгоритмом Беллмана-Форда, который постоянно вычисляет и обновляет веса всех рёбер графа, алгоритм Дейкстры эффективно ищет кратчайший путь путём выбора следующей вершины.</string>
    <string name="Dijkstra39">Как и алгоритм Беллмана-Форда, даже если существуют однонаправленные рёбра или рёбра с различным весом в обе стороны...</string>
    <string name="Dijkstra4">Рассчитывается стоимость каждого пути. Для расчета стоимости берем вес текущей вершины и добавляем к нему стоимость перехода к вершине-кандидату.</string>
    <string name="Dijkstra40">алгоритм Дейкстры найдет кратчайший путь.</string>
    <string name="Dijkstra41">Графы, в которых направление рёбер фиксировано, как показано на схеме, называются \"ориентированные графы\", а графы у которых не фиксировано направление рёбер называются \"неориентированные графы\".</string>
    <string name="Dijkstra42">Бывают случаи, когда алгоритм Дейкстры не может правильно найти кратчайший путь, если граф содержит путь с \"отрицательным весом\". В данном отношении он отличается от алгоритма Беллмана-Форда.</string>
    <string name="Dijkstra43">В графе, путь A-C-B-G, является кратчайшим путём и он включает в себя отрезок пути, C-B, который имеет отрицательный вес.</string>
    <string name="Dijkstra44">В качестве теста, посмотрим, как поведёт себя алгоритм Дейкстры на этом графе.</string>
    <string name="Dijkstra45">Вершины B и C, которые достижимы из исходной вершины и не были полностью исследованы, имеют вес 2 и 4, соответственно.</string>
    <string name="Dijkstra46">В данный момент, алгоритм Дейкстры определил, что кратчайший путь из начальной вершины A к вершине B это путь A-B.</string>
    <string name="Dijkstra47">Потому-что, любой другой путь , проходящей не через точку С имеет более высокую цену чем этот путь.</string>
    <string name="Dijkstra48">Как вы уже знаете, предполагается, что все рёбра имеют вес больше 0, другими словами это означает, что на графе нет отрицательных весов.</string>
    <string name="Dijkstra49">Алгоритм пришел к выводу, что кратчайший путь из начальной точки А в конечную точку G-это путь А-Б-С, имеющий цену 3. Как было сказано выше, это ошибка.</string>
    <string name="Dijkstra5">Для примера, в случае движения к вершине B, начальный вес равен 0, значит стоимость перемещения к B равна 0 + 2 = 2. Аналогично стоимость перемещения к C равна 0 + 5 = 5.</string>
    <string name="Dijkstra52">Кроме того, с таким графом как этот...</string>
    <string name="Dijkstra53">который содержит \"отрицательный цикл\" что означает отрицательный вес в процессе поиска путей...</string>
    <string name="Dijkstra54">с алгоритмом Дейкстры, ошибочное решение будет всегда, вне зависимости от того, существует кратчайший путь или нет.</string>
    <string name="Dijkstra55">Таким образом, алгоритм Дейкстры не может быть использован в графе, который содержит отрицательные веса.</string>
    <string name="Dijkstra56">И наоборот, для графов, которые не содержат отрицательные веса, можно сказать, что алгоритм Дейкстры находит кратчайший путь с меньшим количеством вычислений, чем алгоритм Беллмана-Форда.</string>
    <string name="Dijkstra57">На этом моменте мы завершаем объяснение алгоритма Дейкстры.</string>
    <string name="Dijkstra6">Если вычисленная стоимость меньше текущего веса, то вес изменяется на рассчитанное значение.</string>
    <string name="Dijkstra7">Так как текущие веса B и C равны бесконечности, вычисленные результаты меньше их, значит веса B и C заменяются новыми значениями.</string>
    <string name="Dijkstra8">Из вершин мы выбираем ту, у которой меньше вес. В данном случае этой вершиной является B.</string>
    <string name="Dijkstra9">На текущий момент, мы определили, что путь A-B является кратчайшим к вершине B от стартовой вершины.</string>
    <string name="DijkstraDescription">\"Алгоритм Дейкстры\" это алгоритм, используемый для нахождения кратчайших путей в графе. Вы можете изучить эту тему после покупки всех алгоритмов.</string>
    <string name="Euclidean">Алгоритм Евклида</string>
    <string name="Euclidean0">\"Алгоритм Евклида\" используется для нахождения наибольшего общего делителя (НОД) двух чисел.</string>
    <string name="Euclidean1">Алгоритм был открыт Евклидом в середине 4 века до нашей эры. Он упоминается как самый старый алгоритм в мире.</string>
    <string name="Euclidean10">Для A mod B мы получаем С, которое является остатком от А делённого на B.</string>
    <string name="Euclidean11">Давайте рассмотрим несколько примеров, используя конкретные числа.</string>
    <string name="Euclidean12">А теперь, рассмотрим алгоритм Евклида в действии.</string>
    <string name="Euclidean13">Для начала мы находим остаток от деления большего числа на меньшее.</string>
    <string name="Euclidean14">Другими словами, мы осуществляем деление по модулю большего числа на меньшее.</string>
    <string name="Euclidean15">Результат операции 417. Это остаток от деления.</string>
    <string name="Euclidean16">Далее мы делим по модулю предыдущий делитель 695 на предыдущий остаток от деления 417.</string>
    <string name="Euclidean17">Получаем 278.</string>
    <string name="Euclidean18">Повторяем ту же операцию деления по модулю с 417 и 278.</string>
    <string name="Euclidean19">Мы получили 139.</string>
    <string name="Euclidean2">Для примера, давайте вычислим наибольший общий делитель (НОД) для чисел 1112 и 695.</string>
    <string name="Euclidean20">Выполняем деление по модулю 278 и 139.</string>
    <string name="Euclidean21">Получили 0.</string>
    <string name="Euclidean22">Другими словами 278 делится нацело на 139.</string>
    <string name="Euclidean23">Когда остаток 0, делитель 139 в последней операции и есть наибольший общий делитель чисел 1112 и 695.</string>
    <string name="Euclidean24">Каким же образом алгоритм Евклида смог найти наибольший общий делитель? Давайте рассмотрим ответ на этот вопрос, используя диаграмму.</string>
    <string name="Euclidean25">Выразим числа 1112 и 695 в виде отрезков некоторой длины.</string>
    <string name="Euclidean26">Разметим отрезки на сегменты n, где n это наибольший общий делитель.</string>
    <string name="Euclidean27">Ранее мы определили, что наибольшим общим делителем этих чисел является 139. Для удобства, поделим 1112 на 8 сегментов, а 695 на 5 сегментов.</string>
    <string name="Euclidean28">На самом деле неизвестно, сколько сегментов в каждом отрезке.</string>
    <string name="Euclidean29">Однако мы знаем, что оба числа 1112 и 695 кратны наибольшему общему делителю n.</string>
    <string name="Euclidean3">С помощью обычного метода мы раскладываем 2 числа на простые числа...</string>
    <string name="Euclidean30">Как и ранее, мы найдем остаток от большего числа, делённого на меньшее.</string>
    <string name="Euclidean31">Мы получили 417. Из диаграммы мы видим, что 417 делится на сегменты ширины n.</string>
    <string name="Euclidean32">Мы повторим операцию деления по модулю, как мы делали это ранее.</string>
    <string name="Euclidean35">Когда 695 разделилось на 417, мы получили остаток 278.</string>
    <string name="Euclidean36">Данный остаток 278 также делится нацело на сегменты ширины n, другими словами он имеет такой же наибольший общий делитель.</string>
    <string name="Euclidean37">Повторяем деление снова.</string>
    <string name="Euclidean38">Так как 278 делится без остатка на 139, получаем остаток 0.</string>
    <string name="Euclidean39">Сейчас становится ясно, что наибольший общий делитель n равен 139.</string>
    <string name="Euclidean4">и находим наибольший общий делитель (НОД) из этих простых чисел</string>
    <string name="Euclidean40">Таким образом, алгоритм Евклида способен найти наибольший общий делитель с помощью простых делений.</string>
    <string name="Euclidean41">Большим преимуществом является то, что даже если два числа очень большие, алгоритм найдет НОД, используя стандартную процедуру.</string>
    <string name="Euclidean42">На этом моменте мы завершаем объяснение алгоритма Евклида.</string>
    <string name="Euclidean5">Теперь мы знаем, что наибольшим общим делителем для 1112 и 695 является 139.</string>
    <string name="Euclidean6">Однако, чем больше числа - тем труднее этим способом разложить их на простые множители.</string>
    <string name="Euclidean7">С помощью алгоритма Евклида мы можем найти наибольшие общие делители более эффективно.</string>
    <string name="Euclidean8">Перед тем, как мы приступим к объяснению алгоритма Евклида, давайте рассмотрим операцию деления по модулю.</string>
    <string name="Euclidean9">Операция деление по модулю (mod), это операция, которая находит остаток от деления.</string>
    <string name="ExperimentalModeTitle">Моделирование</string>
    <string name="FewUnique">Немного уникальных элементоь</string>
    <string name="GetItemInfoFailed">Ошибка получения информации. Проверьте сетевое соединение.</string>
    <string name="GraphSearchSection">Поиск в графах</string>
    <string name="Hanoi">Ханойская башня</string>
    <string name="Hanoi0">\"Ханойская башня\" - это головоломка, основанная на перекладывании дисков.</string>
    <string name="Hanoi1">На диаграмме показаны 3 стержня: A, B и C, с двумя дисками на стержне A.</string>
    <string name="Hanoi101">Давайте посмотрим на пример перестановки дисков, с соблюдением данных условий.</string>
    <string name="Hanoi102">Затем, используя такие же принципы, как и ранее, перемещаем диски со стержня B на C.</string>
    <string name="Hanoi15">Диск меньшего размера находится сверху, значит мы можем переместить его на стержень B.</string>
    <string name="Hanoi16">Перемещаем диск побольше на стержень C.</string>
    <string name="Hanoi17">Переместив диск поменьше на стержень С, мы заканчиваем процесс. В данном случае мы показали что можно достигнуть цель используя 2 диска.</string>
    <string name="Hanoi18">А как насчет трех дисков?</string>
    <string name="Hanoi19">Давайте пока будем игнорировать самый большой диск и подумаем, как будем перемещать оставшиеся диски на стержень B.</string>
    <string name="Hanoi2">Целью является переместить диски со стержня A на стержень C сохраняя порядок расположения дисков.</string>
    <string name="Hanoi20">Если мы переместим оставшиеся диски таким же образом, как делали ранее, когда у нас было всего 2 диска, мы сможем переместить их на стержень B.</string>
    <string name="Hanoi21">Перемещаем самый большой диск на стержень C.</string>
    <string name="Hanoi22">Мы закончили. Таким образом, мы показали, что цель достижима и в случае когда у нас 3 диска.</string>
    <string name="Hanoi23">На самом деле, мы сможем достичь цели независимо от количества дисков на стержне.</string>
    <string name="Hanoi24">Давайте попробуем доказать это, используя математическую индукцию.</string>
    <string name="Hanoi25">Мы можем достичь цели, когда был 1 диск.</string>
    <string name="Hanoi27">Предположим, что мы сможем переместить n дисков.</string>
    <string name="Hanoi29">Теперь подумаем о перемещении n+1 дисков.</string>
    <string name="Hanoi30">Игнорируем самый большой диск.</string>
    <string name="Hanoi31">Основываясь на предположении, что мы можем переместить n дисков, передвигаем их на стержень B.</string>
    <string name="Hanoi32">Затем, перемещаем самый большой диск на стержень C.</string>
    <string name="Hanoi33">Перемещаем n дисков со стержня B на стержень С. Мы закончили.</string>
    <string name="Hanoi34">Используя математическую индукцию мы доказали что цель может быть достигнута с любым количеством дисков.</string>
    <string name="Hanoi35">Давайте подумаем о решении Ханойской башни.</string>
    <string name="Hanoi36">Когда Вы решаете Ханойскую башню с n дисками, можно воспользоваться решением с количеством дисков n-1.</string>
    <string name="Hanoi37">Для решения Ханойской башни с n-1 дисками, можно воспользоваться решением с n-2 дисками и так далее, пока не останется один диск.</string>
    <string name="Hanoi38">Этот рекурсивный способ мышления используется в разных алгоритмах, которые называются \"рекурсивные алгоритмы\".</string>
    <string name="Hanoi39">На этом моменте мы завершаем объяснение Ханойской башни.</string>
    <string name="Hanoi4">Однако, есть два условия при переносе дисков. Первое условие состоит в том, что за один раз можно передвигать только один диск.</string>
    <string name="Hanoi5">Перенос одного диска, к примеру этого, не вызовет трудностей...</string>
    <string name="Hanoi6">но Вы не можете переместить сразу 2 диска, как показано на рисунке.</string>
    <string name="Hanoi9">Второе условие: Вы не можете положить диск большего размера на диск меньшего размера.</string>
    <string name="Hash">Хеш-таблицы</string>
    <string name="Hash0">\"Хеш-таблицы\" - это разновидность структур данных.</string>
    <string name="Hash1">Они подходят для хранения данных в наборах, состоящих из \"ключей\" и \"значений\".</string>
    <string name="Hash10">В коробке 2 тоже не Ally.</string>
    <string name="Hash11">В коробке 3 тоже не Ally.</string>
    <string name="Hash12">Ключ в коробке 4 совпал с Ally.</string>
    <string name="Hash13">Путем извлечения значения соответствующего ключу, мы узнали, что пол Ally - женский (F).</string>
    <string name="Hash14">В этом случае стоимость операции линейного поиска пропорциональна размеру данных.</string>
    <string name="Hash15">Линейный поиск занимает много времени когда ищет данные в массиве, что делает его неподходящим выбором.</string>
    <string name="Hash16">Хеш-таблица решает эту проблему.</string>
    <string name="Hash17">Подготовим массив для хранения некоторых данных. Для удобства у нас будет 5 коробок в массиве.</string>
    <string name="Hash18">Теперь давайте сохраним некоторые данные.</string>
    <string name="Hash19">В процессе сохранения данных для \"Joe\"...</string>
    <string name="Hash2">В данном случае имя является ключом, а пол является значением.</string>
    <string name="Hash20">мы вычисляем хеш значение для ключа используя хеш функцию. Для данного случая результат 4928.</string>
    <string name="Hash21">Более детальное объяснение понятия \"хеш функция\" Вы найдете в другом месте этого приложения, но для нашего примера это такая функция, которая преобразует данные в значение фиксированной длины.</string>
    <string name="Hash22">Найденное хеш значение делится на число коробок, в данном случае 5, и находится остаток от деления.</string>
    <string name="Hash23">Операция, которая находит остаток от деления, называется операцией \"mod\" .</string>
    <string name="Hash24">Для нашего случая остаток от деления будет 3.</string>
    <string name="Hash25">Данные \"Joe\" сохраняются в коробку 3.</string>
    <string name="Hash26">Такая же операция будет повторена для сохранения других данных.</string>
    <string name="Hash27">Когда мы сохраняем данные \"Sue\"...</string>
    <string name="Hash28">мы находим хеш значение ключа и выполняем операцию mod на вычисленном значении используя число коробок в массиве (5). Результатом будет 1.</string>
    <string name="Hash29">Данные \"Sue\" сохраняются в коробке 1.</string>
    <string name="Hash3">Для примера давайте представим данные на диаграмме как массив.</string>
    <string name="Hash30">Если мы сохраняем данные \"Dan\"...</string>
    <string name="Hash31">мы находим хеш значение ключа и выполняем операцию mod на вычисленном значении используя число коробок в массиве (5). Результатом будет 4.</string>
    <string name="Hash32">Данные \"Dan\" сохранятся в коробке 4.</string>
    <string name="Hash33">Когда мы сохраняем данные \"Nell\"...</string>
    <string name="Hash34">мы находим хеш значение ключа и выполняем операцию mod на вычисленном значении используя число коробок в массиве (5). Результатом будет 1.</string>
    <string name="Hash35">Когда мы попытаемся сохранить данные \"Nell\" в коробке 1...</string>
    <string name="Hash36">мы увидим что там уже хранятся данные \"Sue\". Тогда происходит вот это...</string>
    <string name="Hash37">данные соединяются в список.</string>
    <string name="Hash38">Существует несколько типов хеш таблиц, но метод, который использует списки называется \"метод цепочек\".</string>
    <string name="Hash39">Когда мы сохраняем данные \"Ally\"...</string>
    <string name="Hash4">Мы подготовили 6 коробок для массива и сохранили в них данные.</string>
    <string name="Hash40">мы находим хеш значение ключа и выполняем операцию mod на вычисленном значении используя число коробок в массиве (5). Результатом будет 3.</string>
    <string name="Hash41">Так как в коробке 3 находятся данные \"Joe\" то данные \"Ally\" добавляются к списку.</string>
    <string name="Hash42">Когда сохраняются данные \"Bob\"...</string>
    <string name="Hash43">мы находим хеш значение ключа и выполняем операцию mod на вычисленном значении используя число коробок в массиве (5). Результатом будет 3.</string>
    <string name="Hash44">Так как в коробке 3 находятся данные \"Joe\" и \"Ally\", то данные \"Bob\" добавляются к списку.</string>
    <string name="Hash45">Все данные сохранены и хеш таблица заполнена.</string>
    <string name="Hash46">Предположим мы захотели узнать пол \"Dan\".</string>
    <string name="Hash47">Чтобы найти в какой коробке массива находятся данные \"Dan\"...</string>
    <string name="Hash48">мы находим хеш значение и выполняем операцию mod на нём, используя число коробок массива которое равно 5. Результатом будет 4.</string>
    <string name="Hash49">Ключ для данных сохраненных в коробке 4 равен \"Dan\".</string>
    <string name="Hash5">Теперь предположим мы хотим узнать какого пола Ally.</string>
    <string name="Hash50">Извлекая соответствующее значнение мы узнаем что пол \"Dan\" мужской.</string>
    <string name="Hash51">Что же случится если мы попробуем найти пол Ally ?</string>
    <string name="Hash52">Для того чтобы узнать в какой коробке массива находятся данные Ally...</string>
    <string name="Hash53">мы находим хеш значение и выполняем операцию mod на нём, используя число коробок массива которое равно 5. Результатом будет 3.</string>
    <string name="Hash54">Ключ для данных сохраненных в коробке 3 был \"Joe\" а не \"Ally\".</string>
    <string name="Hash55">Далее выполняется линейный поиск по списку начиная с данных \"Joe\".</string>
    <string name="Hash56">Данные, ассоциированные с ключем \"Ally\" были найдены.</string>
    <string name="Hash57">Извлекая соответствующее значение, мы находим что пол Ally равен (F).</string>
    <string name="Hash58">Как Вы можете видеть, используя хеш функцию, в хеш таблицах можно быстро находить данные.</string>
    <string name="Hash59">Когда хеш значения перекрываются, используются списки, что позволяет гибко управлять неопределенным количеством данных.</string>
    <string name="Hash6">Мы не знаем номер коробки в которой находится значение пола для Ally.</string>
    <string name="Hash60">Когда размер массива, используемым хеш таблицей слишком мал, увеличивается перекрытие данных, что приводит к большей нагрузке на линейный поиск.</string>
    <string name="Hash61">И наоборот, если размер массива слишком большой, появляется слишком много коробок без данных, что приводит к нерациональному использованию памяти, поэтому необходима осмотрительность.</string>
    <string name="Hash62">Хеш таблицы, с их гибким способом хранения данных и быстрым поиском, используются в языках программирования в качестве ассоциативных массивов.</string>
    <string name="Hash63">На этом моменте мы завершаем объяснение хеш таблиц.</string>
    <string name="Hash7">Следовательно, нам надо перебирать коробки по порядку. Эта операция называется \"линейный поиск\".</string>
    <string name="Hash8">Ключ в первой коробке под номером 0 оказался Joe, это не Ally.</string>
    <string name="Hash9">В коробке 1 тоже не Ally.</string>
    <string name="HashFunction">Хеш-функции</string>
    <string name="HashFunction0">\"Хеш-функция\" - это функция, которая преобразует входные данные в нерегулярные значения фиксированной длины.</string>
    <string name="HashFunction1">Возможно, будет легче понять, что такое хеш-функция если представить её в виде блендера.</string>
    <string name="HashFunction10">Посмотрим на некоторые особенности хеш-функций.</string>
    <string name="HashFunction11">Первой характеристикой хеш-функций является то, что на её выходе получаются значения фиксированной длины.</string>
    <string name="HashFunction12">Длины выходных значений различаются в зависимости от типа хеш-функции. Например, для SHA-1 длина выходного значения равна 20 байтам.</string>
    <string name="HashFunction13">Даже если на вход хеш-функции поступит огромное количество данных, длина значения на выходе не изменится.</string>
    <string name="HashFunction16">Также, независимо от того, насколько мало будет значение на входе, длина хеш значения будет одинаковой.</string>
    <string name="HashFunction19">Второй характеристикой является то, что при одинаковом значении на входе, хеш-функция неизменно дает один и тот же результат.</string>
    <string name="HashFunction2">Когда мы подаем на вход хеш-функции данные...</string>
    <string name="HashFunction25">Третьей характеристикой является то, что ели входные данные похожи, но отличаются даже на 1 бит, выходные значения будут сильно отличаться.</string>
    <string name="HashFunction3">на выходе получаем нерегулярное значение.</string>
    <string name="HashFunction31">И не возникает такой ситуации, что при похожих значениях на входе, получаются похожие значения на выходе.</string>
    <string name="HashFunction32">Четвертой характеристикой является то, что даже если на входе имеются полностью различные данные, случается так, что хеш значения на выходе могут совпадать.</string>
    <string name="HashFunction38">Это ситуация называется \"хеш коллизия\".</string>
    <string name="HashFunction39">Пятой характеристикой является тот факт, что восстановить входные данные из хеш значения практически невозможно.</string>
    <string name="HashFunction4">Если мы представим хеш-функцию как машину, которая перемешивает данные, становится легче понять как она работает.</string>
    <string name="HashFunction41">Тот факт, что у хеш-функций вычисления идут в одном направлении, является большим отличием их от шифрования.</string>
    <string name="HashFunction43">И последней характеристикой является относительная простота вычислений, используемых при расчетах хеш-функций.</string>
    <string name="HashFunction46">Существует множество различных алгоритмов для хеш-функций, но в настоящее время наиболее часто используется SHA-2.</string>
    <string name="HashFunction47">Можно сказать что хеш-функции подытоживают входные данные и это используется во многих ситуациях.</string>
    <string name="HashFunction48">Примеры использования хеш-функций более детально объясняются в разделах \"Коды аутентификации сообщений\" и \"Хеш-таблицы\" в этом приложении.</string>
    <string name="HashFunction49">На этом моменте мы завершаем объяснение хеш-функций.</string>
    <string name="HashFunction5">Значение, которое получается на выходе хеш-функции, называется \"хеш значением\".</string>
    <string name="HashFunction6">Хеш значения - это числа, но очень часто они записываются в шестнадцатеричном виде.</string>
    <string name="HashFunction7">Компьютер оперирует любыми данными в бинарной форме, которая использует 0 и 1.</string>
    <string name="HashFunction8">Хеш значения, это также данные, и они тоже обрабатываются в двоичном виде.</string>
    <string name="HashFunction9">Хеш функция просто выполняет некоторые вычисления над входным значением.</string>
    <string name="Heap">Кучи</string>
    <string name="Heap0">\"Куча\" - это структура данных, основанная на структуре данных \"дерево\", которая используется для реализации \"очереди с приоритетами\".</string>
    <string name="Heap1">Очередь с приоритетами - одна из разновидностей структур данных.</string>
    <string name="Heap10">Так как родитель (6) больше чем потомок (5), они меняются местами.</string>
    <string name="Heap11">Данная операция повторяется до тех пор, пока больше не потребуется операции обмена.</string>
    <string name="Heap12">Значение узла родителя (1) меньше чем значение потомка (5), следовательно, обмен значениями больше не требуется.</string>
    <string name="Heap13">Добавление числа в кучу закончено.</string>
    <string name="Heap14">В процессе извлечения числа из кучи, удаляется число с вершины.</string>
    <string name="Heap15">В куче, наименьшее значение находится на верхней позиции.</string>
    <string name="Heap16">Так как было удалено верхнее значение, необходимо перестроить структуру кучи.</string>
    <string name="Heap17">Число с конца перемещается на вершину.</string>
    <string name="Heap18">Если значение одного из потомков меньше чем у родительского узла, выбирается самое меньшее значение и меняется местами со значением родителя.</string>
    <string name="Heap19">Значение родительского узла (6) больше чем у потомка справа (5), которое в свою очередь больше чем у потомка слева (3) значит, меняются местами значения левого потомка и родителя.</string>
    <string name="Heap2">В ней данные могут быть добавлены в любом порядке.</string>
    <string name="Heap20">Данная операция повторяется до тех пор, пока больше не потребуется операции обмена.</string>
    <string name="Heap22">Значение узла потомка справа (8) больше чем значение узла родителя (6) которое в свою очередь больше значения потомка слева (4) значит, меняем местами значения левого потомка и родительского узла.</string>
    <string name="Heap23">Теперь операция извлечения из кучи завершена.</string>
    <string name="Heap24">Таким образом, структура данных куча может быть использована для быстрого извлечения меньших значений.</string>
    <string name="Heap25">Однако, извлечение данных из середины дерева невозможно.</string>
    <string name="Heap26">Кучи используются в таких областях как очереди с приоритетами и алгоритм Дейкстры.</string>
    <string name="Heap27">На этом моменте мы завершаем объяснение структуры данных куча.</string>
    <string name="Heap3">Однако при извлечении данных, первыми будут выбраны самые маленькие значения.</string>
    <string name="Heap4">Способность свободного добавления данных и извлечения самых малых значений в первую очередь характеризует очередь с приоритетами.</string>
    <string name="Heap5">Далее, посмотрим на структуру данных куча.</string>
    <string name="Heap6">Для кучи, значение потомка всегда больше значения родительского узла.</string>
    <string name="Heap7">Давайте попробуем добавить число в кучу.</string>
    <string name="Heap8">Сначала число помещают в конец линии.</string>
    <string name="Heap9">Если значение родительского узла больше, значения меняются местами.</string>
    <string name="HeapDescription">\"Куча\" это структура данных, используемая для быстрого извлечения самых малых значений. Вы можете изучить эту тему после покупки всех алгоритмов.</string>
    <string name="HeapSort">Пирамидальная сортировка</string>
    <string name="HeapSort0">\"Пирамидальная сортировка\" или \"сортировка кучей\" еще один алгоритм, используемый для сортировки последовательности чисел. Особенностью данного алгоритма является использование структуры данных \"куча\".</string>
    <string name="HeapSort1">Все числа хранятся в структуре данных куча. Куча конструируется таким образом, чтобы числа располагались в порядке убывания. Для более детального объяснения структуры данных куча, можете обратиться к разделу \"Кучи\", в этом приложении.</string>
    <string name="HeapSort10">Для более конкретного примера, элементы кучи (узлов) и у массива...</string>
    <string name="HeapSort105">Несмотря на то, что есть более оптимизированные методы, мы выбираем метод легкий для понимания.</string>
    <string name="HeapSort11">имеются связи, показанные на диаграмме.</string>
    <string name="HeapSort15">Как Вы можете видеть, можно сказать, что куча просто упакована в массив.</string>
    <string name="HeapSort16">Теперь же, попробуем отсортировать массив, используя метод перестановки.</string>
    <string name="HeapSort17">Для лучшего понимания, мы оставим видимой структуру кучи.</string>
    <string name="HeapSort18">Как и ранее, мы начнем сохранять числа в куче.</string>
    <string name="HeapSort20">Как только числа в куче начнут меняться местами, будем делать тоже самое с соответствующими им числами в массиве.</string>
    <string name="HeapSort21">Все числа сохранены в куче. И к этому времени нам удалось упорядочить массив в порядке убывания в куче.</string>
    <string name="HeapSort22">Далее, числа, сохраненные в куче, извлекаются по порядку.</string>
    <string name="HeapSort23">Из куч, упорядоченных по убыванию, данные извлекаются в порядке, начиная от самого большого значения.</string>
    <string name="HeapSort24">Первое число в массиве это наибольшее число в куче.</string>
    <string name="HeapSort25">Первое число в массиве меняется местами с числом, которое соответствует последнему элементу в куче, завершая операцию.</string>
    <string name="HeapSort26">Куча перестраивается с сохранением её структуры.</string>
    <string name="HeapSort27">Данная операция повторяется до тех пор, пока все числа не будут полностью отсортированы.</string>
    <string name="HeapSort28">Сортировка выполнена.</string>
    <string name="HeapSort29">На этом моменте мы завершаем объяснение сортировки кучей или по-другому пирамидальной сортировки.</string>
    <string name="HeapSort3">Все числа сохранены в куче.</string>
    <string name="HeapSort4">Далее, по одному берутся числа, сохраненные в куче.</string>
    <string name="HeapSort5">Одно из свойств куч, упорядоченных по убыванию, является порядок извлечения чисел от больших к маленьким. Таким образом, если Вы выстроите извлеченные из кучи элементы в обратном порядке (справа налево), сортировка будет выполнена.</string>
    <string name="HeapSort7">Все числа извлечены из кучи и сортировка теперь выполнена.</string>
    <string name="HeapSort8">В то время как мы готовили дополнительную структуру не считая последовательности чисел...</string>
    <string name="HeapSort9">обычно, куча уже включена в массив содержащий последовательность чисел и сортировка осуществляется просто перестановкой чисел.</string>
    <string name="Huffman">Кодирование Хаффмана</string>
    <string name="Huffman0">\"Код Хаффмана\" - это алгоритм, используемый для кодирования данных.</string>
    <string name="Huffman1">Он используется например для сжатия картинок и файлов в форматах JPEG и ZIP.</string>
    <string name="Huffman10">В качестве простого примера, возьмем правило показанное на рисунке. Каждый символ выражен двумя битами.</string>
    <string name="Huffman100">Снова повторяется такая же операция, но \"C или D\" считается одним символом.</string>
    <string name="Huffman101">Из трёх оставшихся символов (\"A\", \"B\" и \"C или D\") находим два с наименьшей частотой.</string>
    <string name="Huffman102" formatted="false">В этот раз это \"A\" (35%) и \"B\" (25%).</string>
    <string name="Huffman103">Они соединяются линией, для создания древовидной структуры.</string>
    <string name="Huffman104">И объединяются в символ \"A или B\", а их частоты складываются.</string>
    <string name="Huffman105">\"A или B\" будет считаться одним символом.</string>
    <string name="Huffman106">Таким же образом, выбираются два символа с наименьшими частотами, у нас осталось только 2 символа: \"A или B\" и \"C или D\".</string>
    <string name="Huffman107">Они соединяются линией.</string>
    <string name="Huffman108">Все символы становятся одним целым: \"A или B или C или D\". Частота их появления разумеется 100%.</string>
    <string name="Huffman109">Теперь древовидная структура данных, которая упрощает кодирование методом Хаффмана, построена.</string>
    <string name="Huffman11">Мы попробуем закодировать \"ABAABACD\" следуя нашим правилам. В результате получилось 16 бит, что является значительным уменьшением размера.</string>
    <string name="Huffman110">Снова показаны частоты появления каждого символа.</string>
    <string name="Huffman111">Коды \"0\" и \"1\" присвоены ветвям дерева.</string>
    <string name="Huffman112">Далее, мы обходим дерево, начиная с его корня до каждого символа, соответствующий код будет установлен для каждого из них.</string>
    <string name="Huffman113">\"A\" присваивается код \"00\".</string>
    <string name="Huffman114">\"B\" присваивается код \"01\".</string>
    <string name="Huffman115">\"C\" присваивается код \"10\".</string>
    <string name="Huffman116">\"D\" присваивается код \"11\".</string>
    <string name="Huffman117">Мы завершили кодирование символов методом Хаффмана.</string>
    <string name="Huffman118">В данном случае структура отличается от последнего примера, из-за того что нет сильных различий в частотах символов, все символы выражены кодами длиной 2 бита.</string>
    <string name="Huffman119">Для примера, даже если мы попытаемся выразить \"C\" и \"D\" 3 битами, символ с высокой частотой \"A\" - одним битом...</string>
    <string name="Huffman12">Конечно, из-за того что данные правила были только что созданы, нам нужно объяснить их стороне которая принимает нашу строку символов.</string>
    <string name="Huffman120" formatted="false">из-за того, что частота \"C или D\" (40%) выше, чем частота \"A\" (35%), эффективность кодирования будет хуже.</string>
    <string name="Huffman121">Как можно видеть, кодирование Хаффмана является простым и эффективным, основываясь на частотах символов.</string>
    <string name="Huffman122">На этом моменте мы завершаем объяснение кодирования методом Хаффмана.</string>
    <string name="Huffman13">Для удобства, в данном разъяснении мы будем игнорировать количество трафика, необходимого для передачи правил кодирования.</string>
    <string name="Huffman14">Для того, чтобы получающая сторона могла расшифровать строку символов...</string>
    <string name="Huffman15">если они разделяют код на 2-значные сегменты...</string>
    <string name="Huffman16">и декодировать их, используя правила для каждого сегмента, получится исходная строка \"ABAABACD\".</string>
    <string name="Huffman17">Рассмотрим такое кодирование символьной строки \"ABAABACD\", которое сделает её ещё меньше.</string>
    <string name="Huffman18">С правилами принятыми ранее, мы выражали символ 2 битами...</string>
    <string name="Huffman19">но мы можем выразить A и B с помощью 1 бита, и так получится даже компактней.</string>
    <string name="Huffman2">Для примера, давайте представим, что мы хотим отправить строку символов \"ABAABACD\" по сети.</string>
    <string name="Huffman20">Кроме того, в символьной строке \"ABAABACD\" символы \"A\" и \"B\" используются чаще \"C\" и \"D\".</string>
    <string name="Huffman21">Поэтому, в любом случае, кажется что лучше выразить 1 битом \"A\" и \"B\" чем \"C\" и \"D\".</string>
    <string name="Huffman22">Мы попробуем закодировать \"ABAABACD\", следуя нашим правилам. В результате, размер данных будет равен 10 бит, что является еще более лучшим результатом.</string>
    <string name="Huffman23">Для того, чтобы сторона которая получает код, смогла декодировать его в строку символов...</string>
    <string name="Huffman24">каждый символ должен быть проверен на соответствие правилам преобразования и декодирован...</string>
    <string name="Huffman25">но, к примеру, символ \"10\" может соответствовать как \"BA\" так и \"C\".</string>
    <string name="Huffman26">Из-за этого, могут быть получены другие символы.</string>
    <string name="Huffman27">Также существуют и другие сочетания, которые могут быть трактованы по-разному, и поэтому исходная строка может быть неправильно определена.</string>
    <string name="Huffman28">Случаи, когда исходные символы не могут быть однозначно определены из кода, называются \"неоднозначно декодируемые\".</string>
    <string name="Huffman29">Рассмотрим другой пример. Для удобства, предположим что 2 символа \"A\" and \"B\" будут закодированы так, как показано на рисунке.</string>
    <string name="Huffman3">Данные будут закодированы в двоичной системе как символы 0 и 1.</string>
    <string name="Huffman30">Рассмотрим шаги для расшифровки кода \"000001\" следуя этим правилам.</string>
    <string name="Huffman31">В процессе расшифровки кода мы просматриваем числа с начала строки.</string>
    <string name="Huffman32">Первая цифра \"0\" но мы не можем определить, означает ли она символ \"A\" или часть символа \"B\".</string>
    <string name="Huffman33">Первые 2 цифры \"00\", но снова мы не можем определить это ли \"AA\" или часть символа \"B\".</string>
    <string name="Huffman34">Первые 3 цифры \"000\", но снова мы не можем определить, является ли это \"AAA\" или часть кода относящегося к символу \"B\".</string>
    <string name="Huffman35">И снова, мы не можем определить это с 4 цифрами...</string>
    <string name="Huffman36">и даже с 5 цифрами.</string>
    <string name="Huffman37">Наконец мы видим шестую цифру \"1\" и понимаем что первая \"0\" это \"A\" и что \"00001\" после неё, это код \"B\".</string>
    <string name="Huffman38">Мы можем однозначно декодировать последовательность цифр \"000001\" в строку символов \"AB\". С этого момента не остается вопросов.</string>
    <string name="Huffman39">Коды в таблице преобразования, чьи исходные символы могут быть определены, как только они появляются, называются \"моментальными кодами\" или \"префиксными кодами\"...</string>
    <string name="Huffman4">Для примера, в символьной кодировке ASCII символы \"A\", \"B\", \"C\" и \"D\" кодируются, как показано на диаграмме.</string>
    <string name="Huffman40">но, так как в данном примере исходные символы не могли быть определены без проверки символов следующих после них, то они не являются моментальными кодами.</string>
    <string name="Huffman41">Таким образом, расшифровка займет некоторое время.</string>
    <string name="Huffman42">В угоду эффективности шифрования/дешифрования, предпочтительней коды, которые декодируются однозначно, а также моментальные коды.</string>
    <string name="Huffman43">Рассмотрим проблемы, которые заключаются в двух правилах шифрования, которые показаны в качестве примеров на рисунке.</string>
    <string name="Huffman44">Если мы попытаемся визуализировать первый набор правил...</string>
    <string name="Huffman45">если первый символ в коде это \"0\", нам понятно что это \"A\".</string>
    <string name="Huffman46">Но если это \"1\", это может быть либо \"B\" или возможно частью \"C\" или \"D\".</string>
    <string name="Huffman47">Теперь попробуем визуализировать второй набор правил кодирования, таким же образом.</string>
    <string name="Huffman48">Согласно правилам, первый символ может быть только \"0\".</string>
    <string name="Huffman49">Однако \"0\" может быть \"A\" или частью \"B\".</string>
    <string name="Huffman5">В ASCII, один символ определяется 8 битами.</string>
    <string name="Huffman50">Для того, чтобы являться однозначно декодируемым и моментальным кодом, должно быть условие \"ни один код не должен быть началом другого кода\".</string>
    <string name="Huffman51">Предыдущие два примера не удовлетворяют данному условию.</string>
    <string name="Huffman52">Код Хаффмана это алгоритм, который с легкостью ведет нас к однозначно декодируемым и префиксным кодам.</string>
    <string name="Huffman53">Давайте посмотрим пример шифрования, с использованием кода Хаффмана.</string>
    <string name="Huffman54">Кодирование Хаффмана генерирует однозначно декодируемые и префиксные коды.</string>
    <string name="Huffman55">Сначала, для каждого символа вычисляется вероятность его появления (частота) в последовательности. Для последовательности \"ABAABACD\" на рисунке показаны частоты символов.</string>
    <string name="Huffman56">Далее, символы расставляются в порядке наибольшей частоты. В этом примере они случайно разместились в порядке \"ABCD\".</string>
    <string name="Huffman57">Далее ищутся два символа с наименьшей частотой.</string>
    <string name="Huffman58" formatted="false">В данном случае это \"C\" (12.5%) и \"D\" (12.5%).</string>
    <string name="Huffman59">Символы соединяются линией в целях создания структуры дерева.</string>
    <string name="Huffman6">Используя ASCII, мы закодировали строку символов \"ABAABACD\". В результате размер данных получился равным 64 битам.</string>
    <string name="Huffman60">Эти два символа объединяются в символ \"C или D\" и их частоты складываются.</string>
    <string name="Huffman61">Та же операция повторяется снова, но теперь \"C\" и \"D\" считаются одним символом \"C или D\".</string>
    <string name="Huffman62">Находятся два символа с наименьшими частотами из оставшихся трёх: \"A\", \"B\", и \"C или D\".</string>
    <string name="Huffman63" formatted="false">В этот раз ими являются \"B\" (25%) и \"C или D\" (25%).</string>
    <string name="Huffman64">Символы соединяются линией в целях создания структуры дерева.</string>
    <string name="Huffman65">Эти два символа объединяются в символ \"B или C или D\" и их частоты складываются.</string>
    <string name="Huffman66">Теперь будем считать \"B или C или D\" одним символом.</string>
    <string name="Huffman67">Таким же образом выбираются два символа с наименьшими частотами, у нас осталось только 2 символа: \"A\" и \"B или C или D\"</string>
    <string name="Huffman68">И снова символы соединяются линией.</string>
    <string name="Huffman69">Все символы становятся одним целым: \"A или B или C или D\". Частота их появления разумеется 100%.</string>
    <string name="Huffman7">В целях уменьшения сетевого трафика давайте рассмотрим кодирование 64-битной строки символов во что-то меньше размером.</string>
    <string name="Huffman70">Теперь древовидная структура данных, облегчающая кодирование методом Хаффмана, построена.</string>
    <string name="Huffman71">Снова показаны частоты каждого символа.</string>
    <string name="Huffman72">Далее, мы начнем кодирование, используя 0 и 1.</string>
    <string name="Huffman73">Коды \"0\" и \"1\" присваиваются ветвям дерева, направленным вверх и вниз.</string>
    <string name="Huffman74">Нет особой разницы, если мы поменяем 0 и 1 местами. Но если, например Вы захотите присвоить 1 верхним веткам дерева, Вы не можете это сделать в середине кодирования.</string>
    <string name="Huffman75">Итак, мы присвоили все коды.</string>
    <string name="Huffman76">Затем, мы обходим дерево, начиная с его корня до каждого символа, соответствующий код будет установлен для каждого из них.</string>
    <string name="Huffman77">В случае \"A\"...</string>
    <string name="Huffman78">код будет равен \"0\".</string>
    <string name="Huffman79">В случае \"B\"...</string>
    <string name="Huffman8">Для того, чтобы различать и обрабатывать большое количество символов, ASCII выражает каждый символ 8 битами.</string>
    <string name="Huffman80">присваивается код \"10\".</string>
    <string name="Huffman81">В случае \"C\"...</string>
    <string name="Huffman82">присваивается код \"110\".</string>
    <string name="Huffman83">Для \"D\"...</string>
    <string name="Huffman84">будет присвоен код \"111\".</string>
    <string name="Huffman85">Кодирование по Хаффману завершено.</string>
    <string name="Huffman86">Это означает, что строка символов \"ABAABACD\" должна быть закодирована, с помощью полученных правил.</string>
    <string name="Huffman87">Из полученной нами структуры очевидно, что правило \"ни один код не должен быть началом другого кода\" выполняется.</string>
    <string name="Huffman88">Таким образом, эти коды префиксные и однозначно декодируемые.</string>
    <string name="Huffman89">Также, из-за того что коды с небольшим количеством бит присвоены символам с большими частотами, можно видеть что кодирование - эффективно.</string>
    <string name="Huffman9">Впрочем, только 4 символа использованы в строке \"ABAABACD\". Кажется, что мы можем закодировать эти 4 символа по-другому.</string>
    <string name="Huffman90" formatted="false">Для большей конкретности, в нашем примере у \"C или D\" (25%) меньшая частота появления, чем у \"A\" (50%).</string>
    <string name="Huffman91">Таким образом, даже если \"C или D\" выражено 3 битами, выражая \"A\" одним битом, более эффективно, что и отражается на результатах.</string>
    <string name="Huffman92">Давайте попробуем закодировать \"ABAABACD\" используя полученные правила.</string>
    <string name="Huffman93">Результат - 14 бит, что даже меньше чем когда мы выражали каждый символ двумя битами.</string>
    <string name="Huffman94">Посмотрим на другой пример. На этот раз не будет большой разницы в частотах появления символов.</string>
    <string name="Huffman95">Для удобства, частоты появления уменьшаются в порядке следования символов. Поэтому нам не придется их переставлять.</string>
    <string name="Huffman96">Далее, находим 2 символа с наименьшими частотами.</string>
    <string name="Huffman97" formatted="false">В данном случае ими будут \"C\" (22%) и \"D\" (18%).</string>
    <string name="Huffman98">Два символа соединяются линией, для создания древовидной структуры.</string>
    <string name="Huffman99">И объединяются в символ \"C или D\", а их частоты складываются.</string>
    <string name="HuffmanDescription">\"Алгоритм Хаффмана\" это алгоритм используемый в форматах файлов таких как JPEG или ZIP. Вы можете изучить эту тему после покупки всех алгоритмов.</string>
    <string name="HybridEncoding">Гибридная криптосистема</string>
    <string name="HybridEncoding0">У криптосистемы с общим ключом есть проблема безопасной доставки ключа.</string>
    <string name="HybridEncoding1">С другой стороны, у криптосистемы с открытым ключом, была проблема медленной обработки данных во время шифрования и дешифрования.</string>
    <string name="HybridEncoding10">Если мы зашифруем этот ключ с помощью криптосистемы с открытым ключом, то мы сможем безопасно отправить стороне B.</string>
    <string name="HybridEncoding11">Сторона B, которая является получателем, создает открытый и секретный ключи.</string>
    <string name="HybridEncoding12">Открытый ключ отправлен стороне А.</string>
    <string name="HybridEncoding13">Сторона А использует открытый ключ, полученный от стороны B...</string>
    <string name="HybridEncoding14">и шифрует ключ, используемый криптосистемой с общим ключом</string>
    <string name="HybridEncoding15">зашифрованный ключ отправляется стороне B.</string>
    <string name="HybridEncoding16">сторона B использует их секретный ключ...</string>
    <string name="HybridEncoding17">и расшифровывает шифрограмму, содержащую ключ.</string>
    <string name="HybridEncoding18">там образом сторона А может безопасно передать ключ стороне B, используя криптосистему с открытым ключом.</string>
    <string name="HybridEncoding19">Остаётся только зашифровать данные с помощью данного ключа.</string>
    <string name="HybridEncoding2">\"Гибридная криптосистема\" это система, которая сочетает достоинства этих систем, но компенсирует недостатки каждой их них.</string>
    <string name="HybridEncoding20">при шифровании используется особенность криптосистемы с общим ключом быстро обрабатывать данные.</string>
    <string name="HybridEncoding21">Сторона B без проблем получает исходные данные.</string>
    <string name="HybridEncoding22">в данном случае гибридная криптосистема сочетает и безопасность и быструю обработку данных.</string>
    <string name="HybridEncoding23">Так как она используется в SSL, в системе, которая позволяет осуществлять безопасный обмен информацией через Интернет, то она жизненно необходима нам.</string>
    <string name="HybridEncoding24">На этом моменте мы завершаем объяснение гибридной криптосистемы.</string>
    <string name="HybridEncoding3">Она использует общий ключ, который позволяет быстро шифровать данные.</string>
    <string name="HybridEncoding4">Однако в процессе обмена ключами, используется криптосистема с открытым ключом, как более безопасная.</string>
    <string name="HybridEncoding5">Посмотрим более конкретно, как работает гибридная криптосистема.</string>
    <string name="HybridEncoding6">Допустим, сторона A желает отправить данные стороне B через Интернет.</string>
    <string name="HybridEncoding7">Данные шифруются, используя преимущество быстрой криптосистемы с общим ключом.</string>
    <string name="HybridEncoding8">Так как ключ, необходимый для шифрования, также используется и для расшифрования, то стороне A необходимо отправить ключ стороне B.</string>
    <string name="HybridEncoding9">Ключ представляет из себя одну из форм данных.</string>
    <string name="HybridEncodingDescription">\"Гибридная криптосистема\" это метод, который совмещает свойства криптосистем с симметричным и открытым ключом. Вы можете изучить эту тему после покупки всех алгоритмов.</string>
    <string name="IABSetUpFailed">Соединение с Google Play не выполнено. Пожалуйста, убедитесь, что Вы вошли в Ваш аккаунт Google</string>
    <string name="Inquiry">Обратная связь</string>
    <string name="InquiryConfirmation">Подтверждение</string>
    <string name="InquiryEmail">Адрес электронной почты</string>
    <string name="InquiryFailed">Произошла ошибка в процессе отправки сообщения. Пожалуйста, подождите немного и попробуйте еще раз.</string>
    <string name="InquiryIsSendOK">Оправить отзыв</string>
    <string name="InquiryName">Имя</string>
    <string name="InquiryOptional">(опционально)</string>
    <string name="InquiryPleaseInput">Пожалуйста, введите Ваше сообщение в окне обратной связи</string>
    <string name="InquiryPleaseSmall">Пожалуйста, введите Ваше сообщение размером 1000 символов или меньше</string>
    <string name="InquirySend">Отправить</string>
    <string name="InquirySuccess">Огромное спасибо за Ваш отзыв. Он будет принят во внимание в будущих улучшениях приложения.</string>
    <string name="InquirySuccessTitle">Отзыв отправлен</string>
    <string name="InsertionSort">Сортировка вставками</string>
    <string name="InsertionSort0">\"Сортировка вставками\" - это один из алгоритмов, используемых для сортировки последовательности чисел.</string>
    <string name="InsertionSort1">Вначале, крайнее слева число считается полностью отсортированным.</string>
    <string name="InsertionSort10">и оно сравнивается с уже отсортированным числом слева от него.</string>
    <string name="InsertionSort11">Так как 5 больше чем 4, это означает, что числа меняются местами.</string>
    <string name="InsertionSort12">Так как 3 меньше чем 4, это означает, что 4 больше не перемещается влево.</string>
    <string name="InsertionSort13">Теперь число 4 считается полностью отсортировано.</string>
    <string name="InsertionSort14">Такая же операция повторяется до тех пор, пока числа не будут полностью отсортированы.</string>
    <string name="InsertionSort18">Все числа полностью отсортированы - сортировка выполнена.</string>
    <string name="InsertionSort19">На этом завершается объяснение сортировки вставками.</string>
    <string name="InsertionSort2">Затем, из оставшихся чисел берется левое число...</string>
    <string name="InsertionSort3">и сравнивается с уже отсортированным</string>
    <string name="InsertionSort4">Если отсортированное число больше - числа меняются местами.</string>
    <string name="InsertionSort5">Эта операция повторяется до тех пор, пока не появится число меньше или оно не достигнет левого края.</string>
    <string name="InsertionSort6">В данном случае 5 больше чем 3, значит, числа меняются местами.</string>
    <string name="InsertionSort7">Так как число достигло левого края, значит, оно больше не двигается.</string>
    <string name="InsertionSort8">Число 3 считается полностью отсортированным.</string>
    <string name="InsertionSort9">Как и ранее, из оставшихся чисел берем число слева...</string>
    <string name="KmeansClustering">Алгоритм k-средних</string>
    <string name="KmeansClustering0">\"Алгоритм k-средних\" - один из алгоритмов, использующихся в кластеризации графов.</string>
    <string name="KmeansClustering1">Кластеризация это такая операция, которая для заданного множества данных...</string>
    <string name="KmeansClustering10">Три центральных точки кластеров находятся в случайных местах.</string>
    <string name="KmeansClustering100">Снова вычисляется кратчайшее расстояние к центральным точкам и точки данных перегруппировываются в кластера.</string>
    <string name="KmeansClustering101">В кластеризации, каждая группа называется \"кластер\".</string>
    <string name="KmeansClustering11">От каждой точки данных вычисляем расстояние к центру ближайшего кластера.</string>
    <string name="KmeansClustering12">Каждая точка данных группируется под одним из заранее определенных кластеров.</string>
    <string name="KmeansClustering13">Вычисляется среднее значение точек данных в каждом кластере и центральная точка кластера перемещается туда.</string>
    <string name="KmeansClustering14">Вследствие перемещения центральных точек, вполне возможно изменение центральной точки для некоторых точек данных.</string>
    <string name="KmeansClustering15">Процесс назначения для каждой точки данных своего кластера и изменения центральной точки повторяется до тех пор, пока не будет достигнута сходимость центральных точек.</string>
    <string name="KmeansClustering2">объединяет похожие данные в группы.</string>
    <string name="KmeansClustering26">Сходимость точек центра достигнута, таким образом действия заканчиваются.</string>
    <string name="KmeansClustering27">Математически доказано, поскольку операция повторяется, центральные точки сойдутся.</string>
    <string name="KmeansClustering28">Теперь, кластеризация завершена.</string>
    <string name="KmeansClustering29">Мы видим, что точки данных были соответствующим образом сгруппированы с другими подобными точками.</string>
    <string name="KmeansClustering3">Основа для \"похожести\" данных меняется от алгоритма к алгоритму, она зависит от таких вещей как расстояние между точками данных или их координатами.</string>
    <string name="KmeansClustering30">Теперь давайте попробуем запустить алгоритм k-средних на тех же данных, но только с двумя кластерами и посмотрим, что произойдет.</string>
    <string name="KmeansClustering31">Установим центральные точки случайным образом...</string>
    <string name="KmeansClustering32">и повторим процесс присвоения кластера для каждой точки данных, рассчитываем и передвигаем центральную точку к среднему значению до тех пор, пока не будет достигнута сходимость центральных точек.</string>
    <string name="KmeansClustering4">Алгоритм k-средних использует расстояние от центра каждого кластера для классификации данных.</string>
    <string name="KmeansClustering43">Сходимость точек центра была достигнута.</string>
    <string name="KmeansClustering44">В этом случае, 2 группы данных, левая и нижняя, были объединены в один кластер.</string>
    <string name="KmeansClustering45">Как Вы можете видеть, вследствие того, что количество кластеров должно быть установлено, перед тем как алгоритм начнет свою работу, в случае если их количество определено неправильно, бывают моменты когда не будет достигнуто значительных результатов.</string>
    <string name="KmeansClustering46">Существует ряд методов, используемых для того, чтобы угадать нужное число кластеров, таких как анализируя данные заранее, или просто запуская программу несколько раз, изменяя каждый раз количество кластеров.</string>
    <string name="KmeansClustering47">Давайте запустим алгоритм еще раз, с теми же данными, но с центральными точками расположенных в иных местах, чем ранее.</string>
    <string name="KmeansClustering48">Снова повторим процесс присвоения кластера для каждой точки данных, рассчитываем и передвигаем центральную точку к среднему значению до тех пор, пока не будет достигнута сходимость центральных точек.</string>
    <string name="KmeansClustering5">Итак, давайте взглянем на алгоритм в действии.</string>
    <string name="KmeansClustering58">Была достигнута сходимость центральных точек.</string>
    <string name="KmeansClustering59">В отличие от предыдущего запуска, две группы в верхнем и нижнем правом углах были объединены в один кластер.</string>
    <string name="KmeansClustering6">Для начала, приготовим данные для кластеризации.</string>
    <string name="KmeansClustering60">Как Вы можете видеть, результаты кластеризации могут отличаться в зависимости от начального расположения центральной точки. Это является одной из характеристик алгоритма k-средних.</string>
    <string name="KmeansClustering61">На этом моменте мы завершаем объяснение алгоритма K-средних.</string>
    <string name="KmeansClustering7">Далее, определим количество кластеров.</string>
    <string name="KmeansClustering8">Предварительное определение количества кластеров является характеристикой алгоритма k-средних.</string>
    <string name="KmeansClustering9">На этот раз мы будем использовать 3 кластера.</string>
    <string name="KmeansClusteringDescription">\"Алгоритм k-средних\" это простой, но широко используемый метод анализа данных. Вы можете изучить эту тему после покупки всех алгоритмов.</string>
    <string name="LangColon">Язык:</string>
    <string name="LetsUnlock">С Вашей покупкой Вам будут доступны все темы для изучения. Давайте осваивать алгоритмы вместе!</string>
    <string name="LinearSearch">Линейный поиск</string>
    <string name="LinearSearch0">\"Линейный поиск\" - это алгоритм поиска в элементах массива.</string>
    <string name="LinearSearch1">Давайте попробуем найти число 6.</string>
    <string name="LinearSearch2">Сначала, проверяем левое число в массиве.</string>
    <string name="LinearSearch3">Сравниваем его с 6 и если они равны, то поиск заканчивается. Если же число не равно 6, проверяем следующий элемент.</string>
    <string name="LinearSearch4">Повторяем сравнения, пока число 6 не будет найдено.</string>
    <string name="LinearSearch5">Мы нашли 6 - поиск завершен.</string>
    <string name="LinearSearch6">Как Вы можете видеть, линейный поиск это простой метод, использующий повторяющиеся сравнения элементов с начала массива.</string>
    <string name="LinearSearch7">Когда данных много, число сравнений увеличивается и занимает больше времени.</string>
    <string name="LinearSearch8">На этом завершается объяснение алгоритма линейного поиска.</string>
    <string name="List">Списки</string>
    <string name="List0">\"Списки\" это - тип структуры данных, который позволяет хранить разные значения.</string>
    <string name="List1">Уникальность списков в том, как они связывают данные с помощью указателей. Указатели указывают на следующую порцию данных.</string>
    <string name="List12">На этом моменте мы завершаем объяснение структуры данных \"список\".</string>
    <string name="List2">В списках, данные хранятся в различных, не связанных между собой областях памяти.</string>
    <string name="List4">Так как данные располагаются в различных местах, порции данных могут быть доступны только через указатели</string>
    <string name="List9">Добавление данных производится простым изменением указателей по обе стороны от добавляемой порции данных.</string>
    <string name="ListSearchSection">Поиск в списках</string>
    <string name="MAC">Код аутентификации сообщения</string>
    <string name="MAC0">\"Код аутентификации сообщения\" - это система, которая реализует 2 функции: проверку подлинности и обнаружение подделки сообщений.</string>
    <string name="MAC1">Для начала посмотрим на ситуации, в которых необходим код аутентификации сообщения.</string>
    <string name="MAC10">Шифрограмма отправлена стороне B...</string>
    <string name="MAC11">которая расшифровывает её и получает сообщение, содержащее код продукта.</string>
    <string name="MAC12">В данном случае нет никаких проблем, но может случиться следующее.</string>
    <string name="MAC13">Вернемся назад к той точке, когда сторона A отправляет шифрограмму стороне B.</string>
    <string name="MAC14">Пусть есть злонамеренная сторона X...</string>
    <string name="MAC15">которая подменила шифрограмму, отправляемую стороной A к стороне B, в процессе передачи.</string>
    <string name="MAC16">Сторона B получила шифрограмму, но не знает что она была подменена.</string>
    <string name="MAC17">Когда сторона B расшифровывает шифрограмму, получает код продукта \"xyz\".</string>
    <string name="MAC18">Полагая, что заказан именно \"xyz\", сторона B делает отгрузку неправильного товара стороне A.</string>
    <string name="MAC19">Так как шифрование это не более чем процесс расчета выражений, расшифрование может быть выполнено, даже если шифрограмма не настоящая.</string>
    <string name="MAC2">Для того чтобы купить какой-либо продукт у стороны B, сторона A отправляет сообщение показывающее код продукта \"abc\".</string>
    <string name="MAC20">Если исходное сообщение было длинным, а поддельное сообщение было бессмысленным, возможно кто-то заметит подделку.</string>
    <string name="MAC21">Однако, есть такие данные как коды товаров, в которых сложно найти подмену, после расшифрования.</string>
    <string name="MAC22">Для того, чтобы обнаружить подмену, необходимы дополнительные вычисления.</string>
    <string name="MAC23">Если же Вы используете коды аутентификации сообщений, Вы сможете находить поддельные сообщения. Давайте посмотрим, как они работают.</string>
    <string name="MAC24">Мы еще раз возвратимся к точке когда сторона A отправляет шифрограмму стороне B.</string>
    <string name="MAC25">Сторона A создаёт ключ, который будет использован для создания кода аутентификации сообщения...</string>
    <string name="MAC26">и отправляет ключ стороне B, используя безопасный способ передачи.</string>
    <string name="MAC27">Далее, сторона A создает значение, используя шифрограмму и ключ...</string>
    <string name="MAC28">и получает значение \"7f05\".</string>
    <string name="MAC29">Данное значение создано из комбинации ключа и шифрограммы и называется \"код аутентификации сообщения\".</string>
    <string name="MAC3">Сторона A шифрует сообщение.</string>
    <string name="MAC30">Часто оно обозначается аббревиатурой \"MAC\" и так оно будет обозначаться в оставшейся части данного пояснения.</string>
    <string name="MAC31">MAC может быть представлен как \"хеш значение\" символьной строки, состоящей их ключа и шифрограммы.</string>
    <string name="MAC32">Более детальное объяснение, что такое \"хеш значение\", Вы можете найти в другом разделе данного приложения.</string>
    <string name="MAC33">Существуют различные способы создания MAC, такие как \"HMAC\", \"OMAC\" и \"CMAC\". В наши дни наиболее используемым методом является \"HMAC\".</string>
    <string name="MAC34">Сторона A отправляет стороне B MAC, который они создали из шифрограммы.</string>
    <string name="MAC35">Сторона B получила шифрограмму и MAC.</string>
    <string name="MAC36">Сейчас сторона B должна убедиться в том, что шифрограмма не подделана.</string>
    <string name="MAC37">Точно также как делала сторона A, сторона B использует шифрограмму и ключ чтобы создать MAC.</string>
    <string name="MAC38">Сторона B подтвердила что MAC, который они создали сами, совпал с MAC полученным от стороны A.</string>
    <string name="MAC39">Таким образом, сторона B уверена в том, что полученная шифрограмма не была подделана.</string>
    <string name="MAC4">Допустим, они используют криптосистему с общим ключом для шифрования.</string>
    <string name="MAC40">Всё что остаётся, так это использовать ключ для расшифровки сообщения.</string>
    <string name="MAC41">Сообщение, содержащее код товара \"abc\", который заказала сторона A, было успешно получено.</string>
    <string name="MAC42">Вернемся назад к моменту, когда сторона A отправила шифрограмму стороне B.</string>
    <string name="MAC43">Посмотрим, что же произойдет, если сторона X захочет подменить сообщение в процессе передачи.</string>
    <string name="MAC44">Допустим, что из шифрограммы и MAC, отправленных стороной A к стороне B...</string>
    <string name="MAC45">сторона X заменила шифрограмму.</string>
    <string name="MAC46">Однако, сторона B вычисляет MAC на своей стороне и...</string>
    <string name="MAC47">понимает, что вычисленный MAC не совпадает с полученным ранее от стороны A.</string>
    <string name="MAC48">Исходя из этого, сторона B понимает что шифрограмма, или MAC, или они оба были подделаны.</string>
    <string name="MAC49">В данном случае лучше отказаться от шифрограммы и MAC и попросить сторону A отправить их снова.</string>
    <string name="MAC5">Сторона A отправляет ключ стороне B, используя безопасный метод.</string>
    <string name="MAC50">Возможно ли, чтобы сторона X подделала MAC таким образом, чтобы он подходил к подделанной шифрограмме?</string>
    <string name="MAC51">Так как у стороны X нет ключа, используемого для создания MAC...</string>
    <string name="MAC52">даже если у нее получиться подделать его, не получиться согласовать его с поддельной шифрограммой.</string>
    <string name="MAC53">Как и ожидалось, когда сторона B рассчитает MAC и он не совпадет с подделанной шифрограммой, будет понятно, что в процессе передачи произошла какая-то фальсификация.</string>
    <string name="MAC55">Как можно видеть, используя коды аутентификации сообщений, или по-другому MAC, можно предотвращать фальсификации во время передачи.</string>
    <string name="MAC56">Однако недостатки есть даже у кодов аутентификации сообщений.</string>
    <string name="MAC57">Давайте попробуем упростить процесс.</string>
    <string name="MAC58">Сначала, сторона A и сторона B делят между собой ключ, используемый для шифрования сообщений, и вычисляют MAC.</string>
    <string name="MAC59">Следовательно...</string>
    <string name="MAC6">Метод обмена ключами использует такие протоколы как криптосистема с открытым ключом или протокол обмена ключами Диффи-Хеллмана.</string>
    <string name="MAC60">как только сторона A шифрует сообщение и вычисляет MAC...</string>
    <string name="MAC63">тоже самое может сделать и сторона B.</string>
    <string name="MAC66">Другими словами Вы не сможете проверить кто из них (сторона A или B) создал оригинальное сообщение.</string>
    <string name="MAC67">Поэтому, если бы у стороны A были недобрые намерения...</string>
    <string name="MAC68">как только сообщение было отправлено, она могла бы утверждать что сообщение было подделано стороной B, это позволит ей \"отрицать\" тот факт, что сообщение отправила сторона A.</string>
    <string name="MAC7">Эти протоколы обмена более детально рассматриваются в другом месте данного приложения.</string>
    <string name="MAC71">Для того, чтобы предотвратить данное отрицание, необходимо использовать \"цифровую подпись\", о которой рассказывается далее в этом приложении.</string>
    <string name="MAC72">На этом моменте мы завершаем объяснение кодов аутентификации сообщений.</string>
    <string name="MAC8">Сторона A используя общий ключ, шифрует сообщение.</string>
    <string name="MarkAllAsRead">Отметить всё как прочитанное</string>
    <string name="MarkAllAsUnread">Отметить всё как непрочитанное</string>
    <string name="MathSection">Математика</string>
    <string name="MergeSort">Сортировка слиянием</string>
    <string name="MergeSort0">\"Сортировка слиянием\" - это один из алгоритмов, используемых для сортировки последовательности чисел.</string>
    <string name="MergeSort1">Сначала, последовательность делится на части.</string>
    <string name="MergeSort10">В процессе объединения частей сравниваются первые цифры.</string>
    <string name="MergeSort11">На рисунке первыми будут сравниваться числа 4 и 3.</string>
    <string name="MergeSort12">4 больше чем 3, значит берем 3.</string>
    <string name="MergeSort13">Тем же самым способом сравниваются оставшиеся числа.</string>
    <string name="MergeSort14">4 меньше 7, значит берем 4.</string>
    <string name="MergeSort15">6 меньше чем 7 - берем 6.</string>
    <string name="MergeSort16">Берем 7.</string>
    <string name="MergeSort17">Слияние частей повторяется рекурсивно до тех пор, пока все числа не окажутся в одной группе.</string>
    <string name="MergeSort22">Слияние выполнено и последовательность отсортирована.</string>
    <string name="MergeSort23">На этом моменте мы завершаем объяснение сортировки слиянием.</string>
    <string name="MergeSort5">Разделение выполнено.</string>
    <string name="MergeSort6">Далее разделенные части объединяются.</string>
    <string name="MergeSort7">В процессе объединения, числа в каждой части упорядочиваются так, чтобы после объединения чисел, порядок был от меньшего к большему.</string>
    <string name="MergeSortDescription">\"Сортировка слиянием\" уникальна тем, что она делит последовательность чисел в меньшие группы и затем упорядочивает их. Вы можете изучить эту тему после покупки всех алгоритмов.</string>
    <string name="NowBuying">Обработка...</string>
    <string name="OK">OK</string>
    <string name="OthersSection">Другое</string>
    <string name="PKC">Криптосистема с открытым ключом</string>
    <string name="PKC0">\"Криптосистема с открытым ключом\" - это система шифрования, которая использует разные ключи для шифрования и для расшифрования данных.</string>
    <string name="PKC1">Ключ, используемый для шифрования, называется \"публичный ключ\", а ключ, используемый для расшифрования, называется \"секретный ключ\".</string>
    <string name="PKC10">Шифрограмма передается стороне B.</string>
    <string name="PKC11">Сторона B использует секретный ключ и расшифровывает шифрограмму, полученную от стороны А.</string>
    <string name="PKC12">И получает исходные данные.</string>
    <string name="PKC13">Так как публичный ключ и шифрограмма передаются через Интернет...</string>
    <string name="PKC14">существует шанс, что их перехватит некая злонамеренная сторона X.</string>
    <string name="PKC15">Однако из-за того, что шифрограмма не может быть расшифрована с помощью публичного ключа, сторона X не сможет получить исходные данные.</string>
    <string name="PKC16">Таким образом, в отличие от криптосистемы с общим ключом, проблема доставки ключа не актуальная для криптосистем с открытым ключом.</string>
    <string name="PKC17">У криптосистем с открытым ключом, имеется дополнительное преимущество, которое позволяет легко обмениваться информацией с неопределенным числом сторон. Посмотрим на более конкретный пример.</string>
    <string name="PKC18">Предположим, что сторона B заранее подготовила публичные и секретные ключи.</string>
    <string name="PKC19">Нет никакой проблемы в том, чтобы другим сторонам передать публичные ключи.</string>
    <string name="PKC2">Если сравнивать данную систему с системой с общим ключом, то криптосистема с открытым ключом, как правило, затратит больше времени на шифрование и расшифрование данных.</string>
    <string name="PKC20">Сторона B может просто разместить публичный ключ в сети Интернет.</string>
    <string name="PKC21">Но с другой стороны, нельзя допустить, чтобы секретный ключ получили другие, его необходимо оберегать.</string>
    <string name="PKC22">К примеру, есть множество людей, которые хотят отправить данные стороне B.</string>
    <string name="PKC23">Люди отправляют зашифрованные данные стороне B...</string>
    <string name="PKC24">используя открытый ключ, размещенный в Интернете стороной B.</string>
    <string name="PKC25">Они отправляют их шифрограммы стороне B.</string>
    <string name="PKC26">Сторона B, используя секретный ключ, расшифровывает полученные шифрограммы.</string>
    <string name="PKC27">И получает исходные данные.</string>
    <string name="PKC28">Как можно видеть - нет необходимости подготавливать ключ отдельно для каждого, кто отправляет данные.</string>
    <string name="PKC29">Так как получатель данных только один и только ему необходимо хранить в секрете ключ, то соблюдается высокий уровень безопасности.</string>
    <string name="PKC3">Несколько примеров вычислений для шифрования с помощью публичного ключа показаны на рисунке.</string>
    <string name="PKC30">Однако, существуют 2 проблемы, связанных с криптосистемой с открытым ключом.</string>
    <string name="PKC31">Первой проблемой является то, что требуется время для шифрования и расшифрования данных.</string>
    <string name="PKC32">Из-за этого она не подходит для частого обмена небольшими порциями данных.</string>
    <string name="PKC33">Для решения данной проблемы можно использовать \"гибридную криптосистему\", которая более детально описывается в другом разделе данного приложения.</string>
    <string name="PKC34">Вторая проблема связана с надежностью открытых ключей.</string>
    <string name="PKC35">Давайте вернемся к моменту, когда сторона B создала открытый и секретный ключи.</string>
    <string name="PKC36">Для удобства, мы обозначим открытый ключ созданный стороной B, как \"PB\", а секретный ключ как \"SB\".</string>
    <string name="PKC37">Сторона X, которая хочет перехватить данные, передаваемые стороной A, создаёт открытый ключ \"PX\" и секретный ключ \"SX\".</string>
    <string name="PKC38">Когда сторона B отправляет открытый ключ PB стороне A...</string>
    <string name="PKC39">сторона X тайно подменяет ключ PB открытым ключом PX, который был создан ею...</string>
    <string name="PKC4">На сегодняшний день, шифрование RSA используется достаточно широко и объяснено более детально в другом разделе данного приложения.</string>
    <string name="PKC40">и сторона A получает открытый ключ PX.</string>
    <string name="PKC41">Нет никакого способа, чтобы узнать, кем был создан открытый ключ.</string>
    <string name="PKC42">Таким образом, сторона A не знает, что получила открытый ключ, который был тайно изменен.</string>
    <string name="PKC43">Сторона A шифрует данные открытым ключом PX.</string>
    <string name="PKC44">В процессе передачи шифрограммы от стороны A к стороне B...</string>
    <string name="PKC45">сторона X получает шифрограмму.</string>
    <string name="PKC46">Так как шифрограмма была подготовлена открытым ключом PX, который создала сторона X...</string>
    <string name="PKC47">то она может расшифровать её с помощью секретного ключа SX.</string>
    <string name="PKC48">Сейчас, сторона X успешно перехватила данные, которые были отправлены стороне B.</string>
    <string name="PKC49">Далее, сторона X шифрует данные открытым ключом PB.</string>
    <string name="PKC5">Взглянем более детально на то, как происходит обмен данными с помощью криптосистемы с открытым ключом.</string>
    <string name="PKC50">Полученная шифрограмма отправляется стороне B.</string>
    <string name="PKC51">Так как шифрограмма создана с открытым ключом PB, который был создан стороной B, то получившая сообщение сторона расшифровывает её с помощью секретного ключа SB.</string>
    <string name="PKC52">Поскольку сторона B смогла расшифровать шифрограмму, у неё не возникает подозрений, что данные были перехвачены кем-то ещё.</string>
    <string name="PKC53">Данный метод атаки, с помощью тайной замены открытых ключей \"на лету\", называется \"человек посередине\".</string>
    <string name="PKC54">Корень данной проблемы основывается на том факте, что сторона A не может проверить, что открытый ключ действительно был создан стороной B.</string>
    <string name="PKC55">Для решения данной проблемы используется система \"цифровых сертификатов\". Более детально \"цифровые сертификаты\" рассматриваются в другом разделе данного приложения.</string>
    <string name="PKC56">На этом моменте мы завершаем объяснение криптосистемы с открытым ключом.</string>
    <string name="PKC6">Допустим, сторона А желает отправить данные стороне B, через Интернет.</string>
    <string name="PKC7">Сначала получатель (сторона B), создает публичный и секретный ключи.</string>
    <string name="PKC8">Публичный ключ передается стороне А.</string>
    <string name="PKC9">Сторона А, используя публичный ключ, полученный от стороны B, шифрует данные.</string>
    <string name="PageRank">Рейтинг веб-станицы (PageRank)</string>
    <string name="PageRank0">\"PageRank\" - это алгоритм, используемый для определения порядка выдачи результатов поиска на поисковом сайте.</string>
    <string name="PageRank1">История становления Google великой корпорацией, которая использовала этот алгоритм в своем поисковом движке, довольно известна.</string>
    <string name="PageRank10">Присвоим страницам, не имеющим ссылок, вес равный 1.</string>
    <string name="PageRank100">Если мы посмотрим на данную активность из пространства Интернет, это будет выглядеть как если бы веб-серфер...</string>
    <string name="PageRank101">постоянно перескакивал на абсолютно не связанные между собой веб-страницы, после перехода по ссылкам на некотором количестве связанных между собой страниц.</string>
    <string name="PageRank11">Если на страницу указывают ссылки с других страниц, то её вес комбинируется с весами указывающих на нее страниц.</string>
    <string name="PageRank12">Однако, когда есть ссылки на несколько страниц...</string>
    <string name="PageRank13">веса распределяются равномерно между ними.</string>
    <string name="PageRank14">В алгоритме PageRank, связь, исходящая из веб-страницы, у которой много связей, имеет большой вес.</string>
    <string name="PageRank15">У веб-страницы в центре диаграммы есть связи, указывающие на нее с трех, независимых страниц, значит у нее вес равен 3.</string>
    <string name="PageRank16">У верхней страницы большой вес, потому что на нее ссылается страница с весом 3.</string>
    <string name="PageRank17">Из шести страниц на данной диаграмме, самой \"важной\" определена верхняя страница.</string>
    <string name="PageRank18">Это основные рассуждения в алгоритме PageRank.</string>
    <string name="PageRank19">С данным методом возникает проблема, если ссылки образуют цикл.</string>
    <string name="PageRank2">До этого момента, порядок выдачи результатов поиска определялся ключевыми словами и их связями в предложениях внутри веб-страницы.</string>
    <string name="PageRank20">Если Вы будете вычислять вес каждой страницы по порядку...</string>
    <string name="PageRank24">как Вы можете видеть, этот цикл бесконечен, и веса страниц бесконечно увеличиваются.</string>
    <string name="PageRank25">Проблема циклов решается с помощью метода вычисления, который называется \"модель случайного серфера\".</string>
    <string name="PageRank26">Давайте подумаем о том, как люди переходят по веб-страницам в процессе веб-серфинга.</string>
    <string name="PageRank27">К примеру, в одном случае они посещают страницу которую увидели в журнале. Например, начнем с нижней левой страницы...</string>
    <string name="PageRank28">они нажимают на ссылку и оказываются на другой странице...</string>
    <string name="PageRank29">После просмотра нескольких страниц они теряют интерес...</string>
    <string name="PageRank3">С помощью данного метода не принимается во внимание, содержится ли полезная информация на веб-странице. Таким образом, нельзя утверждать, что результаты поиска обеспечивают высокую точность.</string>
    <string name="PageRank30">и останавливают серфинг на некоторое время.</string>
    <string name="PageRank31">Затем, в другой день, они начинают серфинг на совершенно другой странице, которую им порекомендовал друг.</string>
    <string name="PageRank32">Следуя ссылке, он переходит на следующую страницу...</string>
    <string name="PageRank33">и снова останавливается, теряя интерес.</string>
    <string name="PageRank34">И данное действие повторяется, начинаясь с некоторой веб-страницы переходя к нескольким другим, перед тем как остановиться.</string>
    <string name="PageRank35">Если мы определим действия веб-серферов, мы получим что-то вроде этого.</string>
    <string name="PageRank36">Вероятность 1-α это вероятность что среди всех ссылок на веб-странице будет выбрана 1 ссылка.</string>
    <string name="PageRank37">Вероятность α это вероятность что серфер откроет совершенно новую (не связанную) страницу. Назовем это \"телепорт\". \"Телепорт\" на веб-страницу это переход непосредственно по веб адресу страницы, а не по ссылке.</string>
    <string name="PageRank38">Для примера мы возьмем α, как вероятность телепортации, равным 15%.</string>
    <string name="PageRank39">Попробуем смоделировать переход между страницами следуя этим утверждениям.</string>
    <string name="PageRank4">PageRank это алгоритм, который вычисляет вес веб-станицы, из структуры связей между страницами. Давайте посмотрим, как это работает.</string>
    <string name="PageRank40">Как и раньше мы предположим, что ссылки образуют цикл.</string>
    <string name="PageRank41">Цифры на каждой странице представляют собой сколько раз веб-серфер посетил каждую вею-страницу.</string>
    <string name="PageRank42">Пока мы еще не начали моделирование, эти числа равны 0.</string>
    <string name="PageRank43">В процессе моделирования, увеличивается разница в количестве посещений каждой страницы.</string>
    <string name="PageRank49">Давайте ускорим время.</string>
    <string name="PageRank5">Предположим, что эти квадраты являются веб-страницами, а стрелки представляют связи между ними.</string>
    <string name="PageRank50">Мы будем продолжать моделирование, пока общее число посещенных страниц не достигнет 1000.</string>
    <string name="PageRank51">Конвертируя полученные результаты в проценты, получаем цифры показанные на диаграмме.</string>
    <string name="PageRank52">Можно сказать что эти значения являются вероятностью, что кто-то просматривает эту страницу в заданный момент времени.</string>
    <string name="PageRank53">Использование этих значений для формирования рейтинга веб-страниц и является методом модели случайного сёрфера.</string>
    <string name="PageRank54">Как Вы можете видеть, используя данный метод, мы можем вычислить рейтинг веб-страницы даже если ссылки образуют цикл.</string>
    <string name="PageRank55">В действительности, используются более практические методы вычислений в отличие от моделирования. Сейчас мы их рассмотрим.</string>
    <string name="PageRank56">Попробуем вычислить рейтинг каждой страницы в сложной сети ссылок, как показано на этой диаграмме.</string>
    <string name="PageRank57">Для начала, присвоим каждой странице начальный рейтинг (вес).</string>
    <string name="PageRank58">Веса распределяются равномерно таким образом, что в сумме они дают единицу.</string>
    <string name="PageRank59">Далее, мы найдем вероятность того, что веб-сёрфер после перехода на страницу, перейдет на следующую.</string>
    <string name="PageRank6">На диаграмме показано, что 3 страницы снизу ссылаются на верхнюю страницу.</string>
    <string name="PageRank60">Мы вычислим вероятность нахождения на A после n переходов. Обозначим их как PAn. Точно так же, вероятность оказаться на странице B после n переходов, обозначим их как PBn.</string>
    <string name="PageRank61">Для примера, найдем вероятность сёрфера оказаться на странице A после одного перехода (PA1).</string>
    <string name="PageRank62">Одним из сценариев оказаться на А это если бы персона на странице С выберет переход, а не \"телепорт\" на страницу...</string>
    <string name="PageRank63">и выбирает A, а не B как место назначения.</string>
    <string name="PageRank64">Вероятность того, что кто-то находится на С в самом начале (пока еще не сделано ни одного перехода) это PC0 (равно 0.25).</string>
    <string name="PageRank65">Более того, вероятность что персона на С выберет переход равна 1-α, и вероятность выбора А из А и B равна 0.5.</string>
    <string name="PageRank66">Следовательно, возможность перехода из C к A равна PC0 x (1-α) x 0.5</string>
    <string name="PageRank67">Другим же сценарием для нахождения на A является такой: персона находясь на любой из страниц A-D выбирает \"телепорт\"...</string>
    <string name="PageRank68">и выбирает А, как место назначения.</string>
    <string name="PageRank69">Вероятность того, что субъект, находясь на какой-либо из страниц A-D сделает \"телепорт\" равно α.</string>
    <string name="PageRank7">В алгоритме PageRank чем больше связей указывают на страницу, тем больший вес она имеет.</string>
    <string name="PageRank70">Кроме того, вероятность того, что A будет выбрано местом назначения равна 0.25.</string>
    <string name="PageRank71">Следовательно, вероятность \"телепортации\" к A равна α x 0.25.</string>
    <string name="PageRank72">Из вышеуказанных вероятностей мы нашли, что вероятность нахождения на A после 1 перехода (PA1) равна PC0 x (1-α) x 0.5 + α x 0.25.</string>
    <string name="PageRank73">Подставляя вместо PC0 = 0.25 и α = 0.15, получаем PA1 = 0.14375.</string>
    <string name="PageRank74">Таким же образом мы вычисляем вероятности нахождения на B, C и D и обновляем их значения.</string>
    <string name="PageRank75">Результаты показаны на диаграмме.</string>
    <string name="PageRank76">Далее, найдем вероятности нахождения веб-сёрфера на каждой странице после двух переходов.</string>
    <string name="PageRank77">Результаты показаны на диаграмме.</string>
    <string name="PageRank78">Повторяем те же вычисления и вероятность нахождения на каждой веб-странице начинает приближаться к фиксированному значению.</string>
    <string name="PageRank79">После того, как значения устоялись, вычисления заканчиваются.</string>
    <string name="PageRank8">Из данного примера понятно, что верхняя страница наиболее значимая.</string>
    <string name="PageRank80">Значения, рассчитанные таким способом, являются оценкой для каждой страницы.</string>
    <string name="PageRank81">В заключение, мы проверим, соответствуют ли значения PageRank вычисления описанным ранее.</string>
    <string name="PageRank82">Используя те же методы, что и раньше, мы попробуем вычислить веса для структуры ссылок на диаграмме.</string>
    <string name="PageRank83">Поскольку значения округлены, они в сумме не дают 1, однако Вы можете видеть, что их соотношение близко к предыдущим результатам.</string>
    <string name="PageRank84">Давайте вычислим рейтинги для этой структуры ссылок.</string>
    <string name="PageRank85">Они также близки к тем отношениям, которые мы получили ранее.</string>
    <string name="PageRank86">В этом случае система PageRank в процессе вычислений отказывается от взвешенных ссылок в пользу вероятностей веб-страниц быть посещенными.</string>
    <string name="PageRank87">В действительности, порядок выдачи результатов поиска у Google формируется не только с помощью PageRank.</string>
    <string name="PageRank88">Но это не меняет того факта, что алгоритм PageRank был революционным в его двух концепциях...</string>
    <string name="PageRank89">таких как вычисление рейтинга из структуры ссылок веб-страниц и в способности выполнить расчет, несмотря на наличие циклических ссылок.</string>
    <string name="PageRank9">В действительности, \"важность\" каждой веб-станицы пересчитывается в числовое значение. Давайте объясним основную идею метода расчета.</string>
    <string name="PageRank90">На этом завершается объяснение алгоритма PageRank.</string>
    <string name="PageRankDescription">\"PageRank\" это индекс, используемый для определения порядка отображения результатов поискового движка. Вы можете изучить эту тему после покупки всех алгоритмов.</string>
    <string name="PrimalityTest">Тест простоты</string>
    <string name="PrimalityTest0">\"Тест простоты\" это метод для определения является ли натуральное число - простым числом или нет.</string>
    <string name="PrimalityTest1">Простое число -это натуральное число (n > 1) которое не имеет делителей кроме себя и 1.</string>
    <string name="PrimalityTest100">Перед тем, как мы приступим к объяснению теста простоты, давайте рассмотрим операцию mod (деления по модулю).</string>
    <string name="PrimalityTest101">Операция деление по модулю (mod) - это операция, которая находит остаток от деления.</string>
    <string name="PrimalityTest102">Для A mod B мы получаем С, которое является остатком от деления А на B.</string>
    <string name="PrimalityTest103">Давайте рассмотрим пример данной операции на конкретных числах.</string>
    <string name="PrimalityTest17">Другими словами это означает, что 3599 не является простым числом.</string>
    <string name="PrimalityTest18">Однако, данный метод плохо применим в реальности, так как чем больше число, тем больше времени необходимо для его проверки на простоту.</string>
    <string name="PrimalityTest19">\"Тест простоты Ферма\" метод решения этой проблемы.</string>
    <string name="PrimalityTest2">Шифрование RSA, часто используемая современная технология шифрования, оперирует очень большими простыми числами.</string>
    <string name="PrimalityTest20">Тестом простоты Ферма называется метод определения возможных простых чисел и определения высокой вероятности простоты числа.</string>
    <string name="PrimalityTest21">Давайте взглянем на природу простых чисел.</string>
    <string name="PrimalityTest22">Для примера возьмем простое число 5.</string>
    <string name="PrimalityTest23">На рисунке показаны результаты возведения каждого числа меньше 5 в степень 5.</string>
    <string name="PrimalityTest28">Далее, выполним операцию mod на каждом числе, чтобы найти их остаток после деления на 5...</string>
    <string name="PrimalityTest29">Результаты вычисления показаны на рисунке.</string>
    <string name="PrimalityTest3">Тесты на простоту числа играют ключевую роль в шифровании RSA.</string>
    <string name="PrimalityTest30">Когда мы проверяем исходные числа и их остатки, мы видим, что они совпадают.</string>
    <string name="PrimalityTest31">Исходя из этого, мы видим, что для простого числа 5 (как минимум) формула, показанная на диаграмме работает.</string>
    <string name="PrimalityTest32">Сейчас, рассмотрим составное число 6.</string>
    <string name="PrimalityTest33">Под \"составным числом\" мы понимаем натуральное число не являющимся простым числом.</string>
    <string name="PrimalityTest34">Теперь выполним такие же вычисления...</string>
    <string name="PrimalityTest4">Для примера, давайте определим, является ли 3599 простым числом или нет.</string>
    <string name="PrimalityTest41">мы видим, что в случаях 2 и 5 исходные числа не совпадают с их остатками от деления.</string>
    <string name="PrimalityTest42">Это доказывает, что как и предполагалось ранее, формула на рисунке работает не только для 5, но и для всех простых p.</string>
    <string name="PrimalityTest43">Это называется \"Малой теоремой Ферма\"</string>
    <string name="PrimalityTest44">Назовем метод определения простых чисел, основанный на утверждении, что они удовлетворяют Малой теореме Ферма - тестом простоты Ферма.</string>
    <string name="PrimalityTest45">Попробуем определить, является ли 113 простым числом, используя тест Ферма.</string>
    <string name="PrimalityTest46">Выбираем случайным образом 3 числа, которые меньше 113.</string>
    <string name="PrimalityTest47">После возведения этих чисел в степень 113 поделим их на 113 и получим их остатки от деления.</string>
    <string name="PrimalityTest48">В каждом случае, начальное число совпадает с остатком от деления.</string>
    <string name="PrimalityTest49">Чем больше совпадений, тем выше вероятность что число - простое.</string>
    <string name="PrimalityTest5">Как один из вариантов мы можем делить 3599 по порядку на числа большие 2 и смотреть, делится оно без остатка или нет.</string>
    <string name="PrimalityTest50">Но проверка каждого числа меньшего, чем p, займет слишком много времени.</string>
    <string name="PrimalityTest51">На практике, после проверки определенного количества чисел, когда вероятность простоты числа достаточна, число называется возможно простым числом.</string>
    <string name="PrimalityTest52">К примеру, улучшенная версия теста Ферма называется тест Миллера-Рабина, он используется для определения простых чисел, а шифровании RSA...</string>
    <string name="PrimalityTest53">но, если после повторения теста, вероятность того, что число не является простым, меньше чем 0.5 в 80 степени, то это число считается простым числом.</string>
    <string name="PrimalityTest54">Кроме того, даже если число полностью удовлетворяет тесту Ферма, это не значит, что оно является простым числом.</string>
    <string name="PrimalityTest55">Если число, которое прошло тест, является простым, то оно полностью удовлетворяет тесту Ферма.</string>
    <string name="PrimalityTest56">С другой стороны, в то время как составные числа обычно будут пойманы тестом Ферма в процессе тестирования...</string>
    <string name="PrimalityTest57">существуют составные числа, очень редкие, которые полностью проходят тест Ферма также как и простые числа.</string>
    <string name="PrimalityTest58">Для примера, рассмотрим число 561.</string>
    <string name="PrimalityTest59">Число 561 составное, оно может быть выражено как 3 x 187 или 11 x 51 и так далее, оно не является простым числом.</string>
    <string name="PrimalityTest6">\"Делимость\" в данном случае означает, что операция mod возвращает остаток равный 0.</string>
    <string name="PrimalityTest60">Однако оно удовлетворяет тесту простоты Ферма.</string>
    <string name="PrimalityTest63">Этот вид составных чисел называется \"Числа Кармайкла\" или \"абсолютные псевдопростые числа Ферма\".</string>
    <string name="PrimalityTest64">На рисунке показаны некоторые числа Кармайкла в порядке возрастания.</string>
    <string name="PrimalityTest65">Будет корректно сказать, что простые числа полностью удовлетворяют тесту простоты Ферма, но мы не можем сказать что число является простым только потому что оно полностью удовлетворяет тесту простоты Ферма.</string>
    <string name="PrimalityTest66">В лучшем случае, тест Ферма это метод, определения возможных простых чисел.</string>
    <string name="PrimalityTest67">Однако он используется в большинстве случаев, потому что нет никаких других эффективных методов определения простых чисел.</string>
    <string name="PrimalityTest68">На этом моменте мы завершаем объяснение теста простоты чисел.</string>
    <string name="PrimalityTest7">Квадратный корень из 3599 равен 59.99, значит достаточно проверить числа от 2 до 59, используя операцию mod.</string>
    <string name="PrimalityTest8">В результате, выполнив операции, мы видим, что 3599 делится нацело на 59.</string>
    <string name="PrimalityTestDescription">В разделе \"Тест простоты\" мы объясняем тест простоты Ферма, метод определения возможных простых чисел. Вы можете изучить эту тему после покупки всех алгоритмов.</string>
    <string name="Queue">Очереди</string>
    <string name="Queue0">\"Очереди\" - это одна из разновидностей структур данных.</string>
    <string name="Queue1">Очереди также известны как \"линии ожидания\", и как следует из этого названия, их легко можно представить как группу людей, ожидающих в очереди.</string>
    <string name="Queue10">На этом моменте мы завершаем объяснение структуры данных \"очереди\".</string>
    <string name="Queue2">В очередях, наибольший приоритет имеет тот, кто стоит дольше всех.</string>
    <string name="Queue3">Когда мы добавляем данные в очередь, данные добавляются в её конец.</string>
    <string name="Queue5">Мы используем термин \"enqueue\" для обозначения действия добавления данных в очередь.</string>
    <string name="Queue6">Когда данные извлекаются из очереди, первыми извлекаются данные, которые находились в ней дольше остальных.</string>
    <string name="Queue8">Мы используем термин \"dequeue\" для обозначения действия удаления данных из очереди.</string>
    <string name="Queue9">Данный метод извлечения данных, которые были добавлены в первую очередь, называется \"First In First Out\" что означает \"первый пришёл — первый вышел\" или сокращенно FIFO.</string>
    <string name="QuickSort">Быстрая сортировка</string>
    <string name="QuickSort0">\"Быстрая сортировка\" - это один из алгоритмов, используемых для сортировки последовательности чисел.</string>
    <string name="QuickSort1">Одна из особенностей алгоритма быстрой сортировки состоит в том, что он использует меньшее количество сравнений и перестановок элементов, чем другие алгоритмы. Таким образом, он способен сортировать быстро во многих случаях.</string>
    <string name="QuickSort100">Давайте посмотрим на работу алгоритма в действии.</string>
    <string name="QuickSort101">Для наглядности маркер будет указывать на опорный элемент.</string>
    <string name="QuickSort102">Затем левый маркер будет указывать на крайнее слева число, а правый маркер на крайнее справа число.</string>
    <string name="QuickSort103">Алгоритм быстрой сортировки использует эти маркеры для рекурсивного выполнения операций.</string>
    <string name="QuickSort105">Далее, левый маркер ищет числа большие или равные опорному элементу, а правый маркер находит числа меньшие, чем опорный элемент.</string>
    <string name="QuickSort106">Меняя числа местами, мы собираем числа, которые меньше опорного элемента на левой стороне последовательности, а с правой стороны числа, которые больше или равны ему.</string>
    <string name="QuickSort107">Это завершает первый цикл вычислений.</string>
    <string name="QuickSort11">4 меньше чем 6 - маркер останавливается.</string>
    <string name="QuickSort12">Когда оба маркера остановились, числа, на которые они указывали, меняются местами.</string>
    <string name="QuickSort13">После обмена левый маркер продолжает двигаться направо.</string>
    <string name="QuickSort14">Как и раньше, левый маркер двигается до тех пор, пока он не достигнет число большее или равное опорному элементу.</string>
    <string name="QuickSort18">9 больше чем 6, маркер останавливается.</string>
    <string name="QuickSort19">Теперь правый маркер снова движется влево.</string>
    <string name="QuickSort2">Первая операция принимает во внимание всю последовательность чисел.</string>
    <string name="QuickSort21">Движение маркера также останавливается, если правый маркер достигнет позиции левого маркера.</string>
    <string name="QuickSort22">Когда оба маркера, левый и правый, останавливаются и одновременно находятся в одной позиции, то число, на которое они указывают, меняется местами с опорным элементом.</string>
    <string name="QuickSort23">Число, на которое указывают оба маркера, считает полностью отсортированным.</string>
    <string name="QuickSort24">В этом цикле вычислений...</string>
    <string name="QuickSort25">мы смогли переместить числа меньшие, чем опорный элемент, в сторону левее от него,</string>
    <string name="QuickSort26">а числа, которые больше опорного элемента - правее от него.</string>
    <string name="QuickSort27">Следующий цикл будет выполнен рекурсивно на частях последовательности, созданным опорным элементом.</string>
    <string name="QuickSort28">Сначала вычисления будут выполняться на части последовательности, слева от опорного элемента.</string>
    <string name="QuickSort29">Устанавливаем 3 маркера.</string>
    <string name="QuickSort3">Выбирается число в качестве эталона для сортировки. Это число называется \"опорный элемент\".</string>
    <string name="QuickSort30">Делаем такие же вычисления, как и ранее.</string>
    <string name="QuickSort4">Левый маркер будет сдвигаться вправо.</string>
    <string name="QuickSort40">Цикл вычислений выполнен...</string>
    <string name="QuickSort41">и мы разделили последовательность чисел на меньшие опорного элемента - слева от него...</string>
    <string name="QuickSort42">и числа, которые больше - справа от него.</string>
    <string name="QuickSort43">Следующий цикл будет выполнен рекурсивно.</string>
    <string name="QuickSort44">Левая часть будет подвергаться изменениям.</string>
    <string name="QuickSort45">Когда целевая последовательность состоит из одного числа - она считается полностью отсортированной.</string>
    <string name="QuickSort47">Сейчас операции будут выполнятся на правой стороне, которая была создана во втором цикле.</string>
    <string name="QuickSort48">Устанавливаем 3 маркера.</string>
    <string name="QuickSort49">Левый маркер начинает движение направо.</string>
    <string name="QuickSort50">Даже если левый маркер достигает позиции правого маркера - он не останавливается. В этом отношении он отличается от правого маркера.</string>
    <string name="QuickSort51">Когда левый маркер достигает крайней правой позиции последовательности, он останавливается.</string>
    <string name="QuickSort52">Это означает, что опорное число является самым большим в последовательности.</string>
    <string name="QuickSort53">Далее, передвигаться будет правый маркер, однако если его догнал левый маркер, то правый не двигается.</string>
    <string name="QuickSort54">Когда левый маркер достиг крайней правой позиции последовательности, опорное число считается отсортированным полностью и цикл операций заканчивается.</string>
    <string name="QuickSort55">Далее, те же самые операции повторяются до тех пор, пока сортировка чисел полностью не завершится.</string>
    <string name="QuickSort6">Когда левый маркер достигнет числа, которое больше или равно опорному элементу, он останавливает движение.</string>
    <string name="QuickSort7">В данном случае 8 больше чем 6, маркер останавливается.</string>
    <string name="QuickSort8">Затем правый маркер начинает движение влево.</string>
    <string name="QuickSort83">Все числа были полностью отсортированы.</string>
    <string name="QuickSort84">На этом моменте мы заканчиваем объяснение алгоритма быстрой сортировки.</string>
    <string name="QuickSort9">Когда правый маркер достигает числа меньшего, чем опорное число, он останавливается.</string>
    <string name="QuickSort99">Опорный элемент обычно выбирается случайным образом. Сейчас, для удобства, крайнее правое число выбрано в качестве опорного элемента.</string>
    <string name="QuickSortDescription">\"Быстрая сортировка\" уникальна из-за низкого числа сравнений и перестановок. Вы можете изучить эту тему после покупки всех алгоритмов.</string>
    <string name="Random">Случайно</string>
    <string name="RateThisApp">Оценить это приложение</string>
    <string name="RecursionSection">Рекурсия</string>
    <string name="Restore">Восстановить покупки</string>
    <string name="RestoreAlert">Покупки подтверждены и будут восстановлены. Вы не понесете никаких расходов.</string>
    <string name="RestoreBuyingLog">Восстановить данные о покупке</string>
    <string name="RestoreSuccessed">Данные покупки восстановлены</string>
    <string name="Reversed">В обратном порядке</string>
    <string name="ReviewConfirmation">Открыть App Store</string>
    <string name="ReviewConfirmationAndroid">Открыть магазин Google Play</string>
    <string name="RunLength">Кодирование длин серий (RLE)</string>
    <string name="RunLength0">Давайте попробуем закодировать данное изображение, используя три цвета на сетке 5x5.</string>
    <string name="RunLength1">Для начала, мы будем использовать простой метод.</string>
    <string name="RunLength10">Эти операции называются \"компрессия\" и \"декомпрессия\".</string>
    <string name="RunLength11">Кодирование длин серий хорошо подходит для некоторых типов данных, но не так хорошо подходит к другим.</string>
    <string name="RunLength12">Если мы посмотрим повнимательней на закодированную линию, мы увидим что в целом количество символов уменьшилось...</string>
    <string name="RunLength13">но те части которые не имеют повторяющихся символов, после кодирования длин серий увеличивают общее количество символов.</string>
    <string name="RunLength14">Для примера, если мы применим кодирование длин серий к данным как эти, у которых мало повторяющихся символов...</string>
    <string name="RunLength15">размер удвоится до 50 символов.</string>
    <string name="RunLength16">Наоборот, когда мы применяет кодирование длин серий к данным с повторениями как в этом случае...</string>
    <string name="RunLength17">размер закодированной строки будет 10 символов. По сравнению с оригиналом 25, оно значительно сжато.</string>
    <string name="RunLength18">Как Вы можете видеть, в зависимости от целевых данных, в одних случаях компрессия эффективна, в других нет.</string>
    <string name="RunLength19">Поэтому необходимы множества стратегий, таких как использование кодирования длин серий только для данных, содержащих большое количество последовательных повторений символов (серий).</string>
    <string name="RunLength2">Мы присвоим букву каждому цвету: Y для желтого, G для зеленого и B для голубого.</string>
    <string name="RunLength20">Для примера давайте рассмотрим применение кодирование длин серий на монохромной картинке факса.</string>
    <string name="RunLength21">Если мы просто присвоим символ W для белого цвета и B для черного чтобы сопоставить каждый квадрат изображения при пересылке, мы получим 25 символов.</string>
    <string name="RunLength22">Чтобы уменьшить количество трафика давайте попробуем сжать данные с помощью алгоритма кодирования длин серий.</string>
    <string name="RunLength23">В результате мы получим 26 символов, то есть количество символов увеличилось на 1 символ. Таким образом, использование здесь кодирования длин серий здесь бессмысленно.</string>
    <string name="RunLength24">Однако, монохромное изображение использует только два цвета, черный и белый.</string>
    <string name="RunLength25">Следовательно, если мы достигнем конца серии белых квадратов, следующий квадрат всегда будет черным.</string>
    <string name="RunLength26">По-видимому, мы можем восстановить изображение из кода даже без символов W и B.</string>
    <string name="RunLength27">Если убрать символы W и B в результате мы получим 13 символов. Сжатие будет составлять примерно половину от первоначального размера.</string>
    <string name="RunLength28">Однако, мы должны установить правила, так как мы знаем что первое число в коде означает количество последовательных белых квадратов.</string>
    <string name="RunLength29">С данным правилом, мы сможем корректно восстановить изображение из кода.</string>
    <string name="RunLength3">Сопоставляя буквы каждому цвету развернем построчно данную картинку в одну линию, начиная с верхнего левого угла. Таким образом, мы закодировали изображение в 25 символов.</string>
    <string name="RunLength30">А как же нам закодировать изображение подобное этому?</string>
    <string name="RunLength31">В отличие от предыдущего изображения, у первого квадрата черный цвет, а не белый.</string>
    <string name="RunLength32">Пока попробуем закодировать изображение, используя тот же метод что и раньше.</string>
    <string name="RunLength33">Первая цифра в коде, 6, означает число последовательных квадратов черного цвета...</string>
    <string name="RunLength34">но это не соответствует нашему правилу: \"первое число в коде означает количество последовательных белых квадратов\".</string>
    <string name="RunLength35">Если мы восстановим изображение из этого кода, используя это правило, то мы в результате получим инвертированное изображение.</string>
    <string name="RunLength36">Для того, чтобы полностью следовать нашему правилу \"первое число в коде означает количество последовательных белых квадратов\", был добавлен 0 в начало кода.</string>
    <string name="RunLength37">Он говорит нам, что вначале 0 белых квадратов, другими словами белых квадратов в начале изображения нет.</string>
    <string name="RunLength38">Добавляя 0 в начале кода мы увеличиваем количество символов на 1, но в то же время это нам позволяет сжимать данные, следуя нашему определенному правилу.</string>
    <string name="RunLength39">В общем можно сказать, что алгоритм кодирования длин серий ориентирован на сжатие изображений в большей степени, чем текста, в котором отсутствуют последовательно повторяющиеся данные.</string>
    <string name="RunLength4">Далее, используя кодирование длин серий на изображении попытаемся выразить его в количестве символов меньших, чем 25.</string>
    <string name="RunLength40">Желательна стратегия, которая будет демонстрировать хорошие результаты в любом случае.</string>
    <string name="RunLength41">На этом моменте мы завершаем объяснение алгоритма кодирования длин серий.</string>
    <string name="RunLength5">\"Кодирование длин серий\" это метод кодирования, который заменяет повторяющиеся символы на данный символ и число его повторов.</string>
    <string name="RunLength6">Для примера мы можем выразить \"YYYY\" как \"Y4\", что является на 2 символа короче.</string>
    <string name="RunLength7">Такая же операция повторяется, завершая кодирование длин серий.</string>
    <string name="RunLength8">В результате наш код получился на 5 символов короче, сжатым до 20 символов.</string>
    <string name="RunLength9">Если известно, что у изображения 5 элементов в каждом ряду, оригинальное изображение может быть извлечено из кода.</string>
    <string name="SecurityBase">Основы шифрования</string>
    <string name="SecurityBase0">Почему же нам необходимы технологии шифрования в современном, полном Интернета, мире?</string>
    <string name="SecurityBase1">Допустим, сторона А отправляет некоторые данные стороне В через Интернет.</string>
    <string name="SecurityBase10">Если Вы зашифруете данные, нет повода для беспокойства, если третья сторона перехватит их.</string>
    <string name="SecurityBase11">Поэтому технология шифрования стала очень важна в современном информационном мире.</string>
    <string name="SecurityBase12">Далее, давайте лучше узнаем, какие виды операций используются в шифровании.</string>
    <string name="SecurityBase13">Прежде всего, компьютер обрабатывает 0 и 1, независимо от типов данных.</string>
    <string name="SecurityBase14">Существует множество форматов данных, таких как текст, музыка или видео...</string>
    <string name="SecurityBase15">но внутри компьютера данные обрабатываются в двоичном виде.</string>
    <string name="SecurityBase150">Итак мы объяснили необходимость технологии шифрования, идею того что данные представляются как последовательность чисел и то, что шифрование является числовыми расчетами.</string>
    <string name="SecurityBase16">Давайте порассуждаем о шифровании, помня об этом.</string>
    <string name="SecurityBase17">Для компьютера данные это осмысленная последовательность чисел.</string>
    <string name="SecurityBase18">Шифрограмма также обрабатывается как последовательность чисел.</string>
    <string name="SecurityBase19">Шифрование означает выполнение некоторых вычислений над данными и преобразование их в числа, которые компьютер не может расшифровать.</string>
    <string name="SecurityBase2">Данные в процессе передачи проходят множество устройств и сетей.</string>
    <string name="SecurityBase20">Для числовых расчётов в шифровании используется \"ключ\".</string>
    <string name="SecurityBase21">Ключ также состоит из числовых значений.</string>
    <string name="SecurityBase22">Другими словами, используя ключ для вычислений, шифрование преобразовывает их в то, что не может быть прочитано.</string>
    <string name="SecurityBase23">И наоборот, используя ключ, операция дешифрования преобразовывает шифрограмму в исходные данные.</string>
    <string name="SecurityBase24">Для примера, посмотрим что произойдет, когда мы применим метод \"XOR\" к данным и ключу, показанным на рисунке.</string>
    <string name="SecurityBase25">Операция XOR (исключающее \"ИЛИ\") это операция, которая выполняет вычисления, основываясь на этой \"таблице истинности\".</string>
    <string name="SecurityBase26">Одной из характеристик операции XOR является истинность данных выражений.</string>
    <string name="SecurityBase27">Это означает что если C это результат вычисления XOR на значениях А и B,</string>
    <string name="SecurityBase28">Вы можете выполнить операцию XOR еще раз, используя два значения, чтобы получить третье.</string>
    <string name="SecurityBase29">Используя ключ и операцию XOR на данных...</string>
    <string name="SecurityBase3">Таким образом, даже если данные ушли в неизменном виде...</string>
    <string name="SecurityBase30">нам удалось получить шифрограмму.</string>
    <string name="SecurityBase31">Теперь, давайте попробуем расшифровать её.</string>
    <string name="SecurityBase32">Используя ключ, еще раз выполним операцию XOR на шифрограмме...</string>
    <string name="SecurityBase33">мы получили исходные данные.</string>
    <string name="SecurityBase34">Как Вы можете видеть, один и тот же ключ использован для шифрования и дешифрования когда мы используем метод XOR для кодирования данных.</string>
    <string name="SecurityBase35">На этом моменте мы завершаем объяснение основ шифрования.</string>
    <string name="SecurityBase4">существует шанс их перехвата злонамеренной третьей стороной.</string>
    <string name="SecurityBase5">По этой причине необходимо зашифровать данные перед отправкой, если Вы хотите чтобы они остались конфиденциальными.</string>
    <string name="SecurityBase6">Данные, которые были зашифрованы, называются \"шифрограммой\".</string>
    <string name="SecurityBase7">Шифрограмма отправляется стороне B.</string>
    <string name="SecurityBase8">Сторона B расшифровывает шифрограмму, полученную от стороны А и получает исходные данные.</string>
    <string name="SecurityBase9">Процесс преобразования зашифрованных данных в исходные, называется \"дешифрование\".</string>
    <string name="SecurityBasic">Основы безопасности</string>
    <string name="SecurityBasic0">В процессе обмена данными через Интернет, данные проходят через множество устройств и сетей.</string>
    <string name="SecurityBasic1">Из-за этого технологии безопасности становятся очень существенными для безопасного использования Интернета.</string>
    <string name="SecurityBasic10">Эта проблема называется \"подмена\".</string>
    <string name="SecurityBasic11">№3: Даже если передача сообщения от стороны A к стороне B была выполнена...</string>
    <string name="SecurityBasic12">существует вероятность того, что сторона X успела перезаписать сообщение в процессе передачи.</string>
    <string name="SecurityBasic13">Эта проблема называется \"фальсификация\".</string>
    <string name="SecurityBasic14">В дополнение к намеренной фальсификации сообщения третьими сторонами, существует шанс что сообщение будет повреждено в процессе передачи из-за сбоя.</string>
    <string name="SecurityBasic15">№4: В то время как сторона B верит, что получила сообщение от стороны A...</string>
    <string name="SecurityBasic16">Если у отправителя сообщения (стороны А), был злой умысел...</string>
    <string name="SecurityBasic17">есть шанс что сторона A позже будет утверждать: \"Это не то сообщение, которое я отправлял!\".</string>
    <string name="SecurityBasic18">Когда происходит такое, Интернет перестает быть жизнеспособной средой для бизнес операций или контрактов.</string>
    <string name="SecurityBasic19">Эта проблема называется \"отрицание\".</string>
    <string name="SecurityBasic2">Для начала, давайте взглянем на 4 известных проблемы, которые могут возникнуть при передаче данных через Интернет.</string>
    <string name="SecurityBasic20">Мы осветили четыре важных проблемы.</string>
    <string name="SecurityBasic21">Более того, эти проблемы могут возникнуть не только в процессе передачи данными между людьми, но и в процессе просмотра веб-сайтов.</string>
    <string name="SecurityBasic22">Теперь давайте сделаем краткий обзор типов технологий безопасности предназначенных для решения этих проблем.</string>
    <string name="SecurityBasic23">Чтобы предотвратить первую проблему перехвата используем технологию \"шифрования\".</string>
    <string name="SecurityBasic24">Чтобы предотвратить вторую проблему подмены, мы используем \"коды аутентификации сообщений\"...</string>
    <string name="SecurityBasic25">или технологию \"электронной подписи сообщений\".</string>
    <string name="SecurityBasic26">Аналогично, используем для предотвращения третьей проблемы фальсификации, технологию кодов аутентификации сообщений...</string>
    <string name="SecurityBasic27">или электронной подписи.</string>
    <string name="SecurityBasic28">Технология электронной подписи также полезна при предотвращении четвертой проблемы, отрицания.</string>
    <string name="SecurityBasic29">Объединение всего этого даёт нам этот рисунок.</string>
    <string name="SecurityBasic3">№ 1: Когда сторона A пытается отправить сообщение стороне B...</string>
    <string name="SecurityBasic30">Кроме того, технология \"цифрового сертификата\" также служит для решения проблемы свойственной технологии цифровой подписи, которая не в состоянии проверить владельца открытого ключа.</string>
    <string name="SecurityBasic31">Все эти технологии безопасности объясняются более детально далее этом приложении.</string>
    <string name="SecurityBasic32">На этом моменте мы завершаем объяснение основ безопасности.</string>
    <string name="SecurityBasic4">существует возможность, что содержимое сообщения будет перехвачено стороной X в процессе передачи.</string>
    <string name="SecurityBasic5">Эта проблема называется \"перехват\".</string>
    <string name="SecurityBasic6">№2: Даже когда сторона A отправляет сообщение, предназначенное для стороны B...</string>
    <string name="SecurityBasic7">Есть шанс, что сторона X будет выступать в роли стороны B.</string>
    <string name="SecurityBasic8">И наоборот, когда сторона B верит что получает сообщение от А...</string>
    <string name="SecurityBasic9">Есть шанс, что сторона X выступала в роли стороны A.</string>
    <string name="SecuritySection">Безопасность</string>
    <string name="SelectionSort">Сортировка выбором</string>
    <string name="SelectionSort0">\"Сортировка выбором\" - это один из алгоритмов, используемых для сортировки последовательности чисел.</string>
    <string name="SelectionSort1">Используя линейный поиск, находим минимальное значение в последовательности. Более детальное объяснения термина \"линейный поиск\" можно найти в другом разделе данного приложения.</string>
    <string name="SelectionSort2">Найденный элемент меняется положением с крайним левым элементом и после этого считается отсортированным.</string>
    <string name="SelectionSort3">Если минимальное значение уже находится в крайней левой позиции, то обмен не требуется.</string>
    <string name="SelectionSort4">Операции повторяются до тех пор, пока все числа не будут полностью отсортированы.</string>
    <string name="SelectionSort6">Сортировка выполнена.</string>
    <string name="SelectionSort7">На этом моменте мы заканчиваем объяснение сортировки выбором.</string>
    <string name="Setting">Настройки</string>
    <string name="SettingNotShowUnreadButtons">Скрыть индикаторы</string>
    <string name="Share">Поделиться и оценить приложение</string>
    <string name="ShareOnFacebook">Поделиться на Facebook</string>
    <string name="ShareOnTwitter">Поделиться на Twitter</string>
    <string name="Shuffle">Тасовать</string>
    <string name="SortSection">Сортировка</string>
    <string name="Stack">Стеки</string>
    <string name="Stack0">\"Стеки\" - это еще одна структура данных.</string>
    <string name="Stack1">Структура стека может быть представлена как куча объектов сложенных вертикально.</string>
    <string name="Stack10">На этом моменте завершается объяснение структуры данных \"стек\".</string>
    <string name="Stack2">Когда мы убираем эти объекты, они убираются в порядке от верхнего к нижнему.</string>
    <string name="Stack3">При добавлении данных в стек, они добавляются в самую нижнюю доступную позицию.</string>
    <string name="Stack5">Мы используем термин \"вставить\" для обозначения добавления данных в стек.</string>
    <string name="Stack6">Если необходимо извлечь данные из стека, сначала извлекаются самые последние добавленные данные.</string>
    <string name="Stack8">Мы используем термин \"вытолкнуть\" для обозначения извлечения данных из стека.</string>
    <string name="Stack9">Данный способ извлечения данных, которые были добавлены последними, называется \"Last In First Out\" что в переводе означает \"последним пришёл — первым ушёл\" или сокращенно \"LIFO\".</string>
    <string name="ThankYouForUnlocking">Огромное спасибо за покупку приложения \"Алгоритмы: Понятные и анимированные\". Мы надеемся, что Вам понравится использовать его!</string>
    <string name="ToSendUs">Для отправки нам отзыва или отчета об ошибке используйте раздел \"Обратная связь\".</string>
    <string name="Unlock">Купить все алгоритмы</string>
    <string name="UnlockSuccessed">Покупка выполнена</string>
    <string name="WEB">Сеть</string>
    <string name="YouCanLearnAfter">\"%@\" может быть изучено после покупки всех алгоритмов.</string>
    <string name="YouCanLearnAfterAndroid">\"%s\" может быть изучено после покупки всех алгоритмов.</string>
    <string name="YouCanRestore">Если Вы уже купили все алгоритмы, для просмотра всех тем восстановите данные покупки.</string>
    <string name="abc_action_bar_home_description">Перейти на главный экран</string>
    <string name="abc_action_bar_up_description">Перейти вверх</string>
    <string name="abc_action_menu_overflow_description">Другие параметры</string>
    <string name="abc_action_mode_done">Готово</string>
    <string name="abc_activity_chooser_view_see_all">Показать все</string>
    <string name="abc_activitychooserview_choose_application">Выбрать приложение</string>
    <string name="abc_capital_off">ОТКЛ.</string>
    <string name="abc_capital_on">ВКЛ.</string>
    <string name="abc_search_hint">Поиск</string>
    <string name="abc_searchview_description_clear">Удалить запрос</string>
    <string name="abc_searchview_description_query">Поисковый запрос</string>
    <string name="abc_searchview_description_search">Поиск</string>
    <string name="abc_searchview_description_submit">Отправить запрос</string>
    <string name="abc_searchview_description_voice">Голосовой поиск</string>
    <string name="abc_shareactionprovider_share_with">Открыть доступ</string>
    <string name="abc_shareactionprovider_share_with_application">Открыть доступ приложению \"%s\"</string>
    <string name="abc_toolbar_collapse_description">Свернуть</string>
    <string name="app_name">Алгоритмы</string>
    <string name="en">Английский</string>
    <string name="es">Испанский</string>
    <string name="goal">ФИНИШ</string>
    <string name="ja">Японский</string>
    <string name="ko">Коре́йский</string>
    <string name="min">наи</string>
    <string name="pt">Португальский</string>
    <string name="ru">Русский</string>
    <string name="search">поиск</string>
    <string name="search_menu_title">Поиск</string>
    <string name="status_bar_notification_info_overflow">>999</string>
    <string name="zh">Китайский (упрощенный)</string>
</resources>
