<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="AStarSearch">A*搜索算法</string>
    <string name="AStarSearch0">A*搜索算法（发音为A star）是戴克斯特拉算法的发展。我们首先用戴克斯特拉算法来解决这个迷宫的最短路径。</string>
    <string name="AStarSearch1">迷宫可以被解释为每个点之间的成本为1的图表。</string>
    <string name="AStarSearch10">如果我们将我们刚刚设定的估计成本数字当作每个点的高度，可能会更容易理解。</string>
    <string name="AStarSearch100">通过从以前已知的信息中设置适当的估计成本并将其作为提示，可以更有效地进行搜索。</string>
    <string name="AStarSearch101">通过相加从开始到当前点的实际成本和从当前点到目标的估计成本来获得从开始到目标的成本。</string>
    <string name="AStarSearch11">在右下方的目标点是最低的，左上角的成本8的点是最高的。下坡比上坡要容易。</string>
    <string name="AStarSearch12">当探索迷宫的时候，如果向低成本的方向前进，就像要走下坡路一样，我们应该能够很快的到达目标。</string>
    <string name="AStarSearch13">现在让我们试着用A*搜索算法来解迷宫。</string>
    <string name="AStarSearch14">首先，我们考虑已经探索完起点。</string>
    <string name="AStarSearch15">计算可以从起始点遍历的点的成本。</string>
    <string name="AStarSearch16">成本被计算为\"移动到该点的成本\"和\"到目标的估计成本\"的总和。</string>
    <string name="AStarSearch17">选择一个成本最低的点。</string>
    <string name="AStarSearch18">选择的点标记为已探索。</string>
    <string name="AStarSearch19">计算从已探索的点可以遍历的点的成本。</string>
    <string name="AStarSearch2">在这个前提下，我们用戴克斯特拉算法来求最短路径。</string>
    <string name="AStarSearch20">选择一个成本最低的点。</string>
    <string name="AStarSearch21">选择的点标记为已探索。</string>
    <string name="AStarSearch22">此后，重复相同操作，直到到达目标。</string>
    <string name="AStarSearch24">与戴克斯特拉算法相比，我们可以相当有效地探索迷宫。</string>
    <string name="AStarSearch25">我们怎样才能更有效地解决迷宫？</string>
    <string name="AStarSearch26">让我们尝试用最短路径的实际成本而不是线性距离。</string>
    <string name="AStarSearch28">这次我们走最短路径到达了目标而没有走任何不必要的路。</string>
    <string name="AStarSearch29">实际上我们并不知道最短路径的实际成本。如果知道的话，就没有必要探索了。</string>
    <string name="AStarSearch30">因此，如何设定估算成本是调整A*搜索算法的关键因素。</string>
    <string name="AStarSearch31">估算成本越接近最短路径的实际成本，则可以更有效地解决迷宫问题。</string>
    <string name="AStarSearch32">相反，如果估算成本调整失败，我们来看看会发生什么。</string>
    <string name="AStarSearch33">在这里，作为一个极端的例子，只留估算成本在最短路径上，而其他的则设为0。</string>
    <string name="AStarSearch35">它比戴克斯特拉算法的效率更差。但正确的找到了最短路径。</string>
    <string name="AStarSearch36">在A*搜索算法中，只要估算成本低于\"从本地到目标的最低成本\"，即使效率不同，也能保证找到迷宫的最短路径。</string>
    <string name="AStarSearch37">作为一个不好的例子，我们设置估算成本大于\"从本地点到目标的最低成本\"。</string>
    <string name="AStarSearch38">在这里，我们将留在最短路径上的估算成本设置为原来的2倍。这大大超过了\"从本地点到目标的最低成本\"。</string>
    <string name="AStarSearch4">找到了最短路径，但实际上遍历了大部分的路径。</string>
    <string name="AStarSearch40">该算法判断探索已完成，但找到的路线不同于最短路径。</string>
    <string name="AStarSearch41">事实证明，A*搜索算法是否是一个优秀的搜索算法会根据如何调整而改变。</string>
    <string name="AStarSearch42">在游戏编程中，它经常被用于跟随玩家的敌人AI等。</string>
    <string name="AStarSearch43">但是，由于计算量大，会对整个游戏的进行速度造成不好的影响。您需要考虑如何使用它，例如结合其他算法或限制使用场景。</string>
    <string name="AStarSearch44">这就结束了对\"A*搜索算法\"的解释。</string>
    <string name="AStarSearch5">戴克斯特拉算法是从开始点只考虑成本来决定下一个遍历的点。</string>
    <string name="AStarSearch6">出于这个原因，当我们在箭一样的路线上查找时也无意识的远离了目标。</string>
    <string name="AStarSearch7">A*搜索算法不仅考虑从起点开始的成本，还考虑从当前点到目标的估计成本。</string>
    <string name="AStarSearch8">估计成本可以自由设定。在这里，我们使用从右下角目标的直线距离四舍五入的值。</string>
    <string name="AStarSearch9">这种预先手动设置的估计成本被称为\"估算成本\"。</string>
    <string name="AStarSearchDescription">\"A*搜寻算法\"是戴克斯特拉算法的更高级版本。您可以在购买所有算法后学习这个主题。</string>
    <string name="AboutDev">关于这个程序</string>
    <string name="AlgorithmText1">RSA加密算法</string>
    <string name="AlgorithmText2">椭圆曲线密码学</string>
    <string name="AlreadyBought">已购买</string>
    <string name="AlreadyBoughtRestore">如果您重新安装了应用程序或将其安装在另一台ios终端上，请使用\"恢复购买记录\"。</string>
    <string name="AlreadyBoughtRestoreAndroid">如果您重新安装了应用程序或将其安装在其他Android设备上，请使用\"恢复购买记录\"。</string>
    <string name="AppTitle">算法动画图解</string>
    <string name="Array">数组</string>
    <string name="Array0">\"数组\"是一种数据结构，可以存储多个值。</string>
    <string name="Array1">每个元素可以通过索引（数字表示数据的数量）进行访问。</string>
    <string name="Array10">首先我们在数组的末尾确保额外的空间。</string>
    <string name="Array11">为了腾出空间来添加，逐个移动数据。</string>
    <string name="Array13">\"绿色\"被添加到空白处，完成添加。</string>
    <string name="Array14">相反，当删除第二个元素时，</string>
    <string name="Array15">我们首先删除元素，</string>
    <string name="Array16">通过逐个移动数据填充空白空间。</string>
    <string name="Array18">最后，通过删除额外的空间来完成删除操作。</string>
    <string name="Array19">这就结束了对\"数组\"的解释。</string>
    <string name="Array2">数据按顺序存储在连续位置的存储器中。</string>
    <string name="Array3">由于它们存储在连续的位置，因此可以使用它们的索引来计算内存地址，以便随机访问数据。</string>
    <string name="Array8">数组的另一个特点是与列表相比，在特定位置添加或删除数据的成本很高。</string>
    <string name="Array9">让我们想象添加\"绿色\"到第二个位置。</string>
    <string name="BellmanFord">贝尔曼-福特算法</string>
    <string name="BellmanFord0">贝尔曼-福特算法是查找图的最短路径的算法。</string>
    <string name="BellmanFord1">设置每个点的初始成本。将起点设置为0，其他点设置为无穷大。</string>
    <string name="BellmanFord10">接下来，计算从相反方向点B追踪点A的情况。</string>
    <string name="BellmanFord11">点B的成本是9，所以从点B跟踪点A的成本是9＋9，为18。</string>
    <string name="BellmanFord12">与点A的现值相比，当前值较小，所以我们不更新成本。</string>
    <string name="BellmanFord13">在成本从大到小的情况下，除非边缘成本为负，否则不会更新。</string>
    <string name="BellmanFord14">对所有的边执行相同的操作。边的顺序是任意的，但为了方便，这次我们将从左边的边开始计算。</string>
    <string name="BellmanFord15">我们选择一个边...</string>
    <string name="BellmanFord150">例如，找到到C点（移动一次）和D点（移动两次）的最短路径。</string>
    <string name="BellmanFord16">我们更新了成本。</string>
    <string name="BellmanFord17">类似的，选择一条边...</string>
    <string name="BellmanFord18">我们更新了成本。</string>
    <string name="BellmanFord19">此时，如果从点A到点B，则可以看出，通过点C而不是直接从点A追踪，成本较低。</string>
    <string name="BellmanFord2">从所有的边里面选择一个边。为了方便，我们选择了连接AB的边缘。</string>
    <string name="BellmanFord20">我们将在所有边上执行更新操作。</string>
    <string name="BellmanFord21">一轮已更新。</string>
    <string name="BellmanFord22">对所有的边重复更新操作，直到成本不再更新。</string>
    <string name="BellmanFord24">点的成本不再更新，所以停止操作。</string>
    <string name="BellmanFord25">此时，算法搜索完成。已经找到从起点到其他所有的点的最短路径。</string>
    <string name="BellmanFord26">让我们来思考为什么可以通过这些操作获得最短路径。</string>
    <string name="BellmanFord27">场景回到了初始状态。</string>
    <string name="BellmanFord28">让我们尝试以相反顺序更新所有的边，即从更靠右的一侧更新所有边，以便从起点A点开始的边更新将是最后一个。</string>
    <string name="BellmanFord3">分别计算从一个点追踪到选定的另一个点的成本。计算方法是\"原点成本＋移动成本\"。</string>
    <string name="BellmanFord30">完成第一轮更新。</string>
    <string name="BellmanFord31">我们可以看到在第一轮更新之后，从起点A只用一步可以到达的点的成本被更新。</string>
    <string name="BellmanFord32">我们来尝试第二轮更新。</string>
    <string name="BellmanFord34">第二轮更新已经完成。</string>
    <string name="BellmanFord35">我们可以看到在第二轮更新之后，从起点A只用一步可以到达的点的成本被更新。</string>
    <string name="BellmanFord36">实际上，当进行N次更新操作时，保证最短路径是从起点A到各个点的移动少于N次的情况。</string>
    <string name="BellmanFord37">在图中，由于更新操作已经执行了两次，所以至少确定了从起点到各个点的移动少于2次的最短路径。</string>
    <string name="BellmanFord38">最短路径只能移动2次或更少，所以即便通过A-C-D-F到F点的路径成本较低，也需要3次移动，因此不予考虑。</string>
    <string name="BellmanFord39">另外，尽管到B点的最短路径已经被发现需要3次移动，但由于边缘更新的顺序，这恰好被发现。</string>
    <string name="BellmanFord4">计算从单方向依次进行，但从任何一边开始计算都没有问题。为了便于说明，我们先计算从低成本到高成本的方向。</string>
    <string name="BellmanFord40">换句话说，根据更新边缘的顺序，可能有最短路径需要被移动超过更新的次数。</string>
    <string name="BellmanFord41">所以，当进行n次更新操作时，获得移动n次或者更少移动的最短路径，我们应该做多少次更新操作？</string>
    <string name="BellmanFord42">假设有n个点，如果你不遵循同一个点，你总是可以通过移动n-1次来追踪所有的点。</string>
    <string name="BellmanFord43">换句话说，如果你最多执行n-1次更新操作，则获得所有点的最短路径。</string>
    <string name="BellmanFord44">而且，在途中没有更新的情况， 也可以判断已经确定最短路径，所以操作在这里结束。</string>
    <string name="BellmanFord45">让我们从图中所示的状态重新开始更新操作，直到找到所有点 的最短路径。</string>
    <string name="BellmanFord47">由于没有更新，停止操作。</string>
    <string name="BellmanFord48">我们得到了和以前一样到所有点的最短路径。</string>
    <string name="BellmanFord49">而且，即使如图中A和B之间来回路径的成本不一样，而且像别的边缘一样只能单向行驶...</string>
    <string name="BellmanFord5">由于A点的当前成本较低，因此我们先计算从点A追踪到点B的情况。</string>
    <string name="BellmanFord50">贝尔曼-福特算法也可以正确的求最短路径。</string>
    <string name="BellmanFord51">注意，如图所示，在边缘上设置有方向的图称为\"有向图\"，并没有被设置方向的图被称为\"无向图\"。</string>
    <string name="BellmanFord52">那么，如果包含一个\"负成本\"呢？</string>
    <string name="BellmanFord53">\"负成本\"是指图中C到B的\"-3\"。</string>
    <string name="BellmanFord54">很难想象成本是一个负值...</string>
    <string name="BellmanFord55">例如，我们考虑一下您从汽车起点A到终点G的情况。可以认为，每个成本代表了燃料的消耗。</string>
    <string name="BellmanFord56">在这种情况下，有一个加油站在负成本的地方，你可以认为在这里可以加油，这样就容易理解一些了吧。</string>
    <string name="BellmanFord57">贝尔曼-福特算法在这种包含\"负成本\"的情况下，也可以正确的求最短路径。</string>
    <string name="BellmanFord58">那么，如图所示如果C到B的\"负成本\"从\"-3\"变为\"-6\"时会发生什么呢？</string>
    <string name="BellmanFord59">乍一看，毫无问题地可以找到最短路径...</string>
    <string name="BellmanFord6">由于点A的成本是0，点A追踪到点B的成本是0＋9，为9。</string>
    <string name="BellmanFord60">当我们围绕A-C-B一圈的总成本是\"-1\"。</string>
    <string name="BellmanFord61">这样的路线被称为\"负闭环\"。</string>
    <string name="BellmanFord62">当存在负闭环时，可以通过在其周围继续循环来使成本降低。</string>
    <string name="BellmanFord63">因此，不能以任何方法求最短路径。</string>
    <string name="BellmanFord64">如果尝试使用贝尔曼-福特算法查找此图的最短路径，更新任意次数时点的值将改变，则不会完成。</string>
    <string name="BellmanFord65">相反，贝尔曼-福特算法应该在最大点数-1次的操作时完成更新...</string>
    <string name="BellmanFord66">如果更新次数达到或超过N次，则图中的某个地方会出现负闭环。</string>
    <string name="BellmanFord67">如上所述，贝尔曼-福特算法是一种计算量多的算法，即使存在负成本也可以找到最短路径...</string>
    <string name="BellmanFord68">也可以检测到负闭环的存在。</string>
    <string name="BellmanFord69">这就结束了对\"贝尔曼-福特算法\"的解释。</string>
    <string name="BellmanFord7">如果计算结果小于当前值，我们将用新值更新成本。</string>
    <string name="BellmanFord8">由于点A的当前值是无限大的，所以成本更新为9。</string>
    <string name="BellmanFord9">当值更新时，我们记录路径来自哪个点。在图中，路径由橙色线表示。</string>
    <string name="BinarySearch">二分搜索</string>
    <string name="BinarySearch0">二分搜索是一种从有序数组中搜索元素的算法。</string>
    <string name="BinarySearch1">我们来搜索一下数字6。</string>
    <string name="BinarySearch10">检查剩余数组中心的数字。这时是6。</string>
    <string name="BinarySearch11">6＝6，找到了这个数字。</string>
    <string name="BinarySearch12">我们可以看到，二分搜索利用已排序的数组，通过将搜索数字减半而有效的搜索数字。</string>
    <string name="BinarySearch13">这就结束了二分搜索的解释。</string>
    <string name="BinarySearch2">首先，检查数组中心的数字。这时是5。</string>
    <string name="BinarySearch3">5和将要搜索的6进行比较，由于5小于6，我们可以看到6在5的右边。</string>
    <string name="BinarySearch4">从候选中，删除不再需要的数字。</string>
    <string name="BinarySearch6">检查剩余数组中心的数字。这时是7。</string>
    <string name="BinarySearch7">比较7和6。由于6小于7，我们可以看到6在7的左边。</string>
    <string name="BinarySearch8">从候选中，删除不再需要的数字。</string>
    <string name="BinaryTree">二叉查找树</string>
    <string name="BinaryTree0">\"二叉查找树\"是一种数据结构。</string>
    <string name="BinaryTree1">有编号的点称为\"节点\"。</string>
    <string name="BinaryTree10">相反，二叉查找树的最大节点位于最顶端节点的最右边的子树行的末尾。</string>
    <string name="BinaryTree11">我们来看看向二叉查找树添加节点的过程。</string>
    <string name="BinaryTree12">作为一个例子，我们将尝试添加1。</string>
    <string name="BinaryTree13">我们从二叉查找树的最顶端节点开始，以便找到附加节点的正确位置。</string>
    <string name="BinaryTree14">由于1 &lt;15，向左走。</string>
    <string name="BinaryTree16">由于1 &lt;9，继续向左走。</string>
    <string name="BinaryTree18">由于1 &lt;3，继续向左走，但因为没有节点在前方，所以我们将它添加为一个新节点。</string>
    <string name="BinaryTree2">二叉查找树有两个属性。</string>
    <string name="BinaryTree20">完成添加1。</string>
    <string name="BinaryTree21">接下来，我们尝试添加一个4。</string>
    <string name="BinaryTree22">和前面一样，我们从二叉查找树的最顶端节点开始，以便找到附加节点的正确位置。</string>
    <string name="BinaryTree23">由于4 &lt;15，向左走。</string>
    <string name="BinaryTree25">由于4 &lt; 9，继续向左走。</string>
    <string name="BinaryTree27">由于４＞３ ，向右走。</string>
    <string name="BinaryTree29">由于4 &lt;8，继续向左走，但因为没有节点前进，所以我们将其添加为新节点。</string>
    <string name="BinaryTree3">他们的第一个属性是所有节点都比左子树中的节点大。</string>
    <string name="BinaryTree31">这就完成了添加4。</string>
    <string name="BinaryTree32">让我们来看看从二叉查找树中删除节点的过程。</string>
    <string name="BinaryTree33">作为一个例子，让我们尝试删除28。</string>
    <string name="BinaryTree34">当节点没有子类时...</string>
    <string name="BinaryTree35">只需删除目标节点即可完成。</string>
    <string name="BinaryTree36">接下来，让我们尝试删除8。</string>
    <string name="BinaryTree37">删除有1个子类的节点时...</string>
    <string name="BinaryTree38">目标节点被删除...</string>
    <string name="BinaryTree39">将子节点移动到已删除节点的位置即完成。</string>
    <string name="BinaryTree4">例如，节点9大于其左子树中的任何数字。</string>
    <string name="BinaryTree40">最后，让我们尝试删除9。</string>
    <string name="BinaryTree41">删除有两个子类的节点时...</string>
    <string name="BinaryTree42">首先删除目标节点...</string>
    <string name="BinaryTree43">并从删除节点的左子树中找到最大的节点...</string>
    <string name="BinaryTree44">并将其移动到删除的节点的位置。</string>
    <string name="BinaryTree45">通过这样做，我们能够在保留二叉查找树完整性的同时删除节点。</string>
    <string name="BinaryTree46">如果节点被移动了也有它自己的子节点，那么递归地重复相同的过程。</string>
    <string name="BinaryTree47">而且，尽管我们使用了左侧最大的节点，但使用右侧子树中的最小节点也是如此。</string>
    <string name="BinaryTree48">这一次，让我们来看看在二叉查找树内搜索节点的过程。</string>
    <string name="BinaryTree49">作为一个例子，让我们尝试搜索12。</string>
    <string name="BinaryTree5">同样，节点15比其左子树中的其他数字更大。</string>
    <string name="BinaryTree50">我们从二叉查找树的最顶端节点开始搜索。</string>
    <string name="BinaryTree51">由于12＜15，向左走。</string>
    <string name="BinaryTree53">由于12＞４，向右走。</string>
    <string name="BinaryTree55">我们找到了12。</string>
    <string name="BinaryTree56">正如你所看到的，使用二叉查找树可以实现高效搜索。</string>
    <string name="BinaryTree57">但是，如果树接近形成直线，其搜索效率将非常差，如线性搜索。</string>
    <string name="BinaryTree58">另一方面，一直保持良好平衡的二叉查找树称为\"自平衡二叉查找树\"，能够保持搜索效率。</string>
    <string name="BinaryTree59">这就结束了对\"二叉查找树\"的解释。</string>
    <string name="BinaryTree6">相反，它们的第二个属性是所有节点都小于其右子树中的节点。</string>
    <string name="BinaryTree7">例如，节点15比右子树中的其他数字小。</string>
    <string name="BinaryTree8">由于这两个属性，下列情况成立。</string>
    <string name="BinaryTree9">首先，二叉查找树最小节点位于最顶端节点的最左边的子树行的末尾。</string>
    <string name="BinaryTreeDescription">\"二叉查找树\"是最基本的搜索树。您可以在购买所有算法后学习这个主题。</string>
    <string name="BreadthFirstSearch">广度优先搜索</string>
    <string name="BreadthFirstSearch0">广度优先搜索是搜索图的算法。</string>
    <string name="BreadthFirstSearch1">我们将以A作为始点，G作为目标开始搜索。</string>
    <string name="BreadthFirstSearch11">在候选中，C和D是最早添加的。我们选择左边的C。</string>
    <string name="BreadthFirstSearch12">移动到选定的点。</string>
    <string name="BreadthFirstSearch13">从当前点C可以到达的点H被添加为新的候选。</string>
    <string name="BreadthFirstSearch14">下面，重复相同的操作，直到到达目标或者搜索完所有的点。</string>
    <string name="BreadthFirstSearch2">从A可到达的点B，C和D将被视为下一个移动点的候选点。</string>
    <string name="BreadthFirstSearch3">从候选中选择一个点。对于选择标准，选择最早被添加到候选中的候选点。</string>
    <string name="BreadthFirstSearch38">到达目标，结束搜索。</string>
    <string name="BreadthFirstSearch39">这样，广度优先搜索具有从起点开始依次广泛搜索的特征。</string>
    <string name="BreadthFirstSearch4">同时选为候选点时，可以选择其中任何一个。为了方便，这次将从左侧的点选择。</string>
    <string name="BreadthFirstSearch40">这就结束了广度优先搜索的解释。</string>
    <string name="BreadthFirstSearch5">这次由于所有的点都在同时成为候选，我们选择B。</string>
    <string name="BreadthFirstSearch6">移动到选定的点。</string>
    <string name="BreadthFirstSearch7">从当前点B可以到达的点E和F被添加为新的候选。</string>
    <string name="BreadthFirstSearch8">候选点在\"先进先出\"（FIFO) 的方法下管理，因此我们可以使用\"队列\"的数据结构。</string>
    <string name="BreadthFirstSearch9">\"队列\"在这个应用程序的其他地方更详细地解释。</string>
    <string name="BubbleSort">冒泡排序</string>
    <string name="BubbleSort0">\"冒泡排序\"是数列排序的算法之一。</string>
    <string name="BubbleSort1">将天平放在序列的右端，并比较天平左右的数字。</string>
    <string name="BubbleSort16">天平到达左端。</string>
    <string name="BubbleSort2">在这种情况下，我们将比较7和6。</string>
    <string name="BubbleSort20">在一系列操作中，数列中最小的数字已经移动到左端。</string>
    <string name="BubbleSort21">使左端的数字排序...</string>
    <string name="BubbleSort22">将天平返回右端。</string>
    <string name="BubbleSort23">重复相同的操作，直到所有数字都被排序。</string>
    <string name="BubbleSort25">排序完成。</string>
    <string name="BubbleSort26">这就结束了对冒泡排序的解释。</string>
    <string name="BubbleSort3">比较后如果右边的数字较小，则被交换。</string>
    <string name="BubbleSort4">因为6小于7，所以左右的数字相互交换。</string>
    <string name="BubbleSort5">比较完成后，逐一移动天平。</string>
    <string name="BubbleSort6">同样比较数字。</string>
    <string name="BubbleSort7">这次是6大于4，所以数字不用交换。</string>
    <string name="BubbleSort8">将天平向左移动一个位置。</string>
    <string name="BubbleSort9">重复同样的操作，直到天平移动到左端。</string>
    <string name="BuyAllAlgorithms">购买所有的算法:%@</string>
    <string name="BuyAllAlgorithmsAndroid">购买所有的算法:</string>
    <string name="CKC">共有密钥加密</string>
    <string name="CKC0">\"共有密钥加密\"是一种使用相同密钥进行加密和解密的加密方法。</string>
    <string name="CKC1">让我们看看使用共有密钥加密技术进行数据交换的整个画面。</string>
    <string name="CKC10">B方使用密钥解密从A方收到的密文。</string>
    <string name="CKC11">由此，B方获得原始数据。</string>
    <string name="CKC12">如果您加密数据，即使它被恶意的第三方破坏也是安全的。</string>
    <string name="CKC13">使用相同的密钥进行加密和解密是公用密钥加密的一个特点。</string>
    <string name="CKC14">图中显示的是在共有密钥加密中使用的一些计算方法。</string>
    <string name="CKC15">目前，经常使用\"AES\"方法。</string>
    <string name="CKC16">接下来，让我们来考虑共用密钥加密的一些问题。</string>
    <string name="CKC17">我们将简要回到先前的情况，现在，B方刚刚收到了A方发送的密文。</string>
    <string name="CKC18">X方有可能窃取密文。</string>
    <string name="CKC19">现在，因为A方和B方不直接相识...</string>
    <string name="CKC2">假设A方正在通过互联网向B方发送数据。</string>
    <string name="CKC20">我们来考虑一个B方不知道用于加密的密钥的情况。</string>
    <string name="CKC21">A方需要通过某种方式将钥匙交给B方。</string>
    <string name="CKC22">就像他们用密文一样，A方通过互联网将密钥发送给B方。</string>
    <string name="CKC23">B方使用从A方接到的密钥...</string>
    <string name="CKC24">能够解密密文。</string>
    <string name="CKC25">但是，X方也有可能看到这个钥匙。</string>
    <string name="CKC26">因此，X方也可以使用密钥来解密密文。</string>
    <string name="CKC27">我们可以发现传送此密钥的方式存在问题。</string>
    <string name="CKC28">所以A先生将加密密钥，以便X方盗窃。</string>
    <string name="CKC29">在计算机里，密钥也只是其中一个数据。</string>
    <string name="CKC3">数据将通过互联网上的各种网络和设备传送给B方。</string>
    <string name="CKC30">因此…</string>
    <string name="CKC31">您可以使用新密钥对其进行加密。</string>
    <string name="CKC32">密钥的密文...</string>
    <string name="CKC33">发送给B方.</string>
    <string name="CKC34">现在B方拥有加密数据以及用于解密数据的加密密钥。</string>
    <string name="CKC35">X方仍然有可能窃取加密的密钥。</string>
    <string name="CKC36">现在剩下的就是将用于加密密钥的新密钥传输给B方...</string>
    <string name="CKC37">A方应该如何让这个新密钥发送给B方？</string>
    <string name="CKC38">如果不加密，X方可以窃取\"新密钥\"并可以使用它。</string>
    <string name="CKC39">如果我们加密它，会有新的密钥，问题会重演。</string>
    <string name="CKC4">因此，如果您尝试按原样发送数据...</string>
    <string name="CKC40">总之，\"共有密钥加密\"需要一种方法来安全地传送密钥。</string>
    <string name="CKC41">这被称为\"钥匙交付问题\"。</string>
    <string name="CKC42">这个问题有两种解决方案，1）使用密钥交换协议的方法和 2）使用公开密钥加密的方法，每种方法在本应用的其他地方都有更详细的解释。</string>
    <string name="CKC43">这就结束了对\"共有密钥加密\"的解释。</string>
    <string name="CKC5">数据可能会被有恶意的第三者看到。</string>
    <string name="CKC6">因此，保密的数据需要加密发送。</string>
    <string name="CKC7">用钥匙…</string>
    <string name="CKC8">将数据加密，并使其成为密文。</string>
    <string name="CKC9">把密文发给B方。</string>
    <string name="Cancel">取消</string>
    <string name="CannotPayAlert">购买受到限制。请更改您的设备设置。</string>
    <string name="CannotRestoreAlert">购买记录无法确认。请检查您是否使用购买的iTunes账户登录。</string>
    <string name="CannotRestoreAlertAndroid">购买记录无法确认。请检测您是否已连接到互联网或者在购买时用Google Play登录。</string>
    <string name="ChangeConfirmation">你确定要做这些改变吗？</string>
    <string name="ClusteringSection">聚类</string>
    <string name="CompressionSection">数据压缩</string>
    <string name="Config">设置</string>
    <string name="DataStructureSection">数据结构</string>
    <string name="DepthFirstSearch">深度优先搜索</string>
    <string name="DepthFirstSearch0">深度优先探索是搜索图的算法。</string>
    <string name="DepthFirstSearch1">A作为起点，G作为目标开始搜索。</string>
    <string name="DepthFirstSearch11">在候选中，E和F是最近添加的。我们选择左边的E。</string>
    <string name="DepthFirstSearch12">移动到选定的点。</string>
    <string name="DepthFirstSearch13">从当前点E可以到达的点K被添加为新的候选。</string>
    <string name="DepthFirstSearch14">下面，重复相同的操作，直到到达目标或者搜索完所有的点。</string>
    <string name="DepthFirstSearch2">从A可以到达的点B，C和D，他们将作为下一个目标的候选点。</string>
    <string name="DepthFirstSearch28">达到目标，解释搜索。</string>
    <string name="DepthFirstSearch29">这样，深度优先探索具有深入挖掘待定路径来进行搜索的特征。</string>
    <string name="DepthFirstSearch3">从候选中选择一个点。对于选择标准，选择最新被添加到候选中的候选点。</string>
    <string name="DepthFirstSearch30">这就结束了对\"深度优先探索\"的解释。</string>
    <string name="DepthFirstSearch4">同时选为候选点时，可以选择其中任何一个。为了方便，这次将从左侧的点选择。</string>
    <string name="DepthFirstSearch5">这次由于所有的点都在同时成为候选，我们选择B。</string>
    <string name="DepthFirstSearch6">移动到选定的点。</string>
    <string name="DepthFirstSearch7">从当前点B可以到达的点E和F被添加为新的候选。</string>
    <string name="DepthFirstSearch8">选择点在\"先进先出\"（LIFO)的方法下管理，因此我们可以使用\"堆栈\"的数据结构。</string>
    <string name="DepthFirstSearch9">\"栈\"在这个应用程序的其他地方更详细地解释。</string>
    <string name="DiffieHellman">迪菲-赫尔曼密钥交换</string>
    <string name="DiffieHellman0">\"迪菲-赫尔曼密钥交换\"是一种在两方之间安全交换密钥的方法。</string>
    <string name="DiffieHellman1">在使用数学公式来解释它之前，我们使用图从概念开始理解。</string>
    <string name="DiffieHellman10">可以被用作合成新密钥的元素。</string>
    <string name="DiffieHellman11">在图中的示例中，通过使用密钥P和P-S，合成了新密钥PP-S。</string>
    <string name="DiffieHellman12">换句话说，任何合成的密钥可以进一步组合。</string>
    <string name="DiffieHellman13">让我们尝试使用这种组合方法安全地交换A方和B方之间的密钥。</string>
    <string name="DiffieHellman14">首先，A方准备密钥P，这个密钥可以被任何人知道。</string>
    <string name="DiffieHellman15">A方将密钥P发送给B方。</string>
    <string name="DiffieHellman16">接下来，A方和B方各自准备秘密密钥SA和SB。</string>
    <string name="DiffieHellman17">密钥SA和SB需要进行管理，以便不会被其他人知道它们。</string>
    <string name="DiffieHellman18">A方从密钥P和秘密密钥SA合成新的密钥P-SA。</string>
    <string name="DiffieHellman19">同样，B方从密钥P和秘密密钥SB合成新密钥P-SB。</string>
    <string name="DiffieHellman2">假设有一种特殊的方法来组合两个密钥。</string>
    <string name="DiffieHellman20">A方向B方发送密钥P-SA。</string>
    <string name="DiffieHellman21">同样，B方将密钥P-SB发送给A方。</string>
    <string name="DiffieHellman22">A方将秘密密钥SA与从B方收到的密钥P-SB组合，以获得新的密钥P-SA-SB。</string>
    <string name="DiffieHellman23">同样，B方将秘密密钥SB与从A方收到的密钥P-SA组合，并获得新的密钥P-SA-SB。</string>
    <string name="DiffieHellman24">因此，A方和B方都能够获得密钥P-SA-SB。</string>
    <string name="DiffieHellman25">该密钥将被用作加密/解密密钥。</string>
    <string name="DiffieHellman26">我们来验证这个密钥交换方法的安全性。</string>
    <string name="DiffieHellman27">由于密钥P，P-SA和P-SB全部通过互联网发送......</string>
    <string name="DiffieHellman28">他们有可能被恶意的第三方X窃取。</string>
    <string name="DiffieHellman29">但是，第X方不能从他们获得的密钥中合成密钥P-SA-SB。</string>
    <string name="DiffieHellman3">用这种方法，当密钥P和密钥S被组合时...</string>
    <string name="DiffieHellman30">由于密钥不能被解构，不能获得秘密密钥SA和SB。</string>
    <string name="DiffieHellman31">因此，由于第X方不能创建密钥P-SA-SB，所以发现这种密钥交换方法是安全的。</string>
    <string name="DiffieHellman32">接下来，让我们尝试用数学表达式来表示这种密钥交换方法。</string>
    <string name="DiffieHellman33">首先，我们来解释一下\"mod运算\"。</string>
    <string name="DiffieHellman34">mod运算是查找除法余数的操作。</string>
    <string name="DiffieHellman35">对于A模B，我们得到A除以B的余数C。</string>
    <string name="DiffieHellman36">让我们使用具体数字来展示一些运算实例。</string>
    <string name="DiffieHellman37">现在，让我们尝试用数学表达式来思考密钥交换方法。</string>
    <string name="DiffieHellman38">在开始时制作并且可以公开的密钥P将被表示为公式中的2个数字P和G.</string>
    <string name="DiffieHellman39">P是一个非常大的素数，G将从素数P中被称为起源（或原始根）的数字中选择。</string>
    <string name="DiffieHellman4">一个新的密钥PS由密钥P和密钥S的成分构成。</string>
    <string name="DiffieHellman40">素数P的原始根，对于所有的素数P存在一定数量。</string>
    <string name="DiffieHellman41">首先，A方将准备素数P和原始根G。这些数字可以被任何人知道。</string>
    <string name="DiffieHellman42">A方将素数P和原始根G发送给B方。</string>
    <string name="DiffieHellman43">接下来，A方和B方分别准备秘密数字X和Y.</string>
    <string name="DiffieHellman44">秘密数字X和Y需要小于素数P - 2。</string>
    <string name="DiffieHellman45">A先生和B先生分别计算mod素数P（原始根G的秘密平方数）。</string>
    <string name="DiffieHellman46">这个计算在概念上就是一个合成。</string>
    <string name="DiffieHellman47">A方和B方将计算结果互相发送给对方。</string>
    <string name="DiffieHellman48">然后，A方和B方将（他们收到的数字秘密平方）并计算mod（素数P）。</string>
    <string name="DiffieHellman49">这些计算结果具有相同的值。</string>
    <string name="DiffieHellman5">这种组合方法有两个特点。</string>
    <string name="DiffieHellman50">因此，A方和B方能够共享可用作加密的数字。</string>
    <string name="DiffieHellman51">让我们试着验证这个密钥交换方法的安全性。</string>
    <string name="DiffieHellman52">因为这些数字是通过互联网发送的......</string>
    <string name="DiffieHellman53">他们有机会被X方窃取。</string>
    <string name="DiffieHellman54">但是，A方和B方之间共享的数字不能由X方获得的数字来计算。</string>
    <string name="DiffieHellman55">此外，无法获得秘密数字X和Y.</string>
    <string name="DiffieHellman56">通常，从素数P，原始根G的X平方mod P中求X的方法被称为\"离散对数问题\"，并且还没有被发现。</string>
    <string name="DiffieHellman57">迪菲-赫尔曼密钥交换可以是利用离散对数问题的密钥交换方法。</string>
    <string name="DiffieHellman58">这就结束了对\"迪菲-赫尔曼密钥交换\"的解释。</string>
    <string name="DiffieHellman6">第一个特点是，即使有密钥P和由它创建的组合密钥P-S ...</string>
    <string name="DiffieHellman7">不可能提取密钥S.</string>
    <string name="DiffieHellman8">换句话说，即使你能够合成一个密钥，你也不能解构它。</string>
    <string name="DiffieHellman9">第二个特点是，从其他密钥组合的任何密钥...</string>
    <string name="DiffieHellmanDescription">\"迪菲-赫尔曼密钥交换\"是双方之间安全交换密钥的一种方法。您可以在购买所有的算法后学习这个主题。</string>
    <string name="DigitalCertification">数字证书</string>
    <string name="DigitalCertification0">公开密钥加密和数字签名系统存在不能保证公开密钥属于谁的问题。</string>
    <string name="DigitalCertification1">因此，当A方试图将公开密钥发送给B方时......</string>
    <string name="DigitalCertification10">认证机构有自己准备的公开密钥（PC）和秘密密钥（SC）。</string>
    <string name="DigitalCertification11">A方准备他们自己的个人信息，包括他们的公开密钥（PA）和电子邮件地址......</string>
    <string name="DigitalCertification12">并将其发送给认证机构。</string>
    <string name="DigitalCertification13">一旦确认完成，认证机构使用其秘密密钥（SC）并从A方的数据创建数字签名。</string>
    <string name="DigitalCertification14">\"数字签名\"在本应用程序中有更详细的解释。</string>
    <string name="DigitalCertification15">接下来，创建的数字签名和数据制作成单个文件...</string>
    <string name="DigitalCertification16">并发送给A方。</string>
    <string name="DigitalCertification17">该文件成为A方的数字证书。</string>
    <string name="DigitalCertification18">代替公开密钥，A方将收到的数字证书发送给B方。</string>
    <string name="DigitalCertification19">B方确认他们收到的数字证书中的电子邮件地址属于A方。</string>
    <string name="DigitalCertification2">有恶意的第三方可能会在收件人不知道的情况下交出了被替换的公开密钥。</string>
    <string name="DigitalCertification20">之后，B方获得认证机构的公开密钥......</string>
    <string name="DigitalCertification21">并验证数字证书中的数字签名来自认证机构。</string>
    <string name="DigitalCertification22">数字证书中的数字签名只能使用认证机构的公开密钥（PC）进行验证。</string>
    <string name="DigitalCertification23">换句话说，如果验证结果没有问题，那么数字证书无疑是由认证机构签发的。</string>
    <string name="DigitalCertification24">由于已经确认数字签名属于A方并且由认证机构颁发，所以从数字签名中提取方A的公开密钥（PA）。</string>
    <string name="DigitalCertification25">由此，从A方到B方的公开密钥的交付完成。</string>
    <string name="DigitalCertification26">让我们看看公开密钥的传递方式是否有问题。</string>
    <string name="DigitalCertification27">假设一个冒充A方的有恶意的X，试图传递自己的公开密钥。</string>
    <string name="DigitalCertification28">但是，B方没有必要相信没有作为数字证书发送的公开密钥。</string>
    <string name="DigitalCertification29">那么当X方冒充A方并试图向认证机构注册他们自己的公开密钥时会发生什么？</string>
    <string name="DigitalCertification3">通过使用\"数字证书\"系统，我们可以保证谁是公开密钥的创建者。</string>
    <string name="DigitalCertification30">在这种情况下，由于X方没有A方的邮件地址，所以不能签发证书。</string>
    <string name="DigitalCertification31">第X方只能使用第X方电子邮件地址创建的证书。 因此，他们无法获得A方的证书</string>
    <string name="DigitalCertification32">如您所见，通过使用数字证书系统，可以验证公开密钥的所有者。</string>
    <string name="DigitalCertification33">那么，之前我们说，B方拿到了认证机构的公开密钥......</string>
    <string name="DigitalCertification34">这里出现了一个问题。</string>
    <string name="DigitalCertification35">B方收到的公开密钥（PC）是否真的由认证机构创建？</string>
    <string name="DigitalCertification36">由于无法确认谁创建公开密钥的，所以它可能是由X方冒充认证机构创建的。</string>
    <string name="DigitalCertification37">换句话说，我们在这里也看到了与公开密钥相同的问题。</string>
    <string name="DigitalCertification38">事实上，认证机构的这个公开密钥（PC）......</string>
    <string name="DigitalCertification39">也作为数字证书被交付。</string>
    <string name="DigitalCertification4">我们来具体看一下数字证书的机制。</string>
    <string name="DigitalCertification40">然后，给这个认证机构签名的......</string>
    <string name="DigitalCertification41">是排名较高的认证机构。</string>
    <string name="DigitalCertification42">认证机构形成了一个树结构，高级别权威机构为较低级别的机构创建证书。</string>
    <string name="DigitalCertification43">如何创建认证机构的树结构？</string>
    <string name="DigitalCertification44">例如，假设有一个社会广泛信任的认证机构Y。</string>
    <string name="DigitalCertification45">即使新公司G希望开始认证机构的服务，它在社会上也没有信誉。</string>
    <string name="DigitalCertification46">因此，G公司有Y公司颁发的证书。 当然，Y公司会检查G公司是否能够正确执行认证机构的业务。</string>
    <string name="DigitalCertification48">因此，G公司可以宣传自己是一家赢得Y公司信任的公司。</string>
    <string name="DigitalCertification49">通过这样做，大型组织获得了小型组织的信任，形成了一个有组织的树结构。</string>
    <string name="DigitalCertification5">A方有一对公开密钥PA和秘密密钥SA ......</string>
    <string name="DigitalCertification50">那么，什么是认证机构树结构的顶层呢......</string>
    <string name="DigitalCertification51">拥有最高职位的认证机构称为\"根认证机构（root CA）\"，并自己证明其自身的有效性。</string>
    <string name="DigitalCertification52">此外，根认证机构证明自己的证书称为\"根证书\"。</string>
    <string name="DigitalCertification53">如果一个根认证机构本身不是一个可信任的组织，它将不会被使用。</string>
    <string name="DigitalCertification54">因此，其中相当一部分是已经具有社会公信力的组织，例如大公司和政府机构。</string>
    <string name="DigitalCertification55">直到现在，我已经看到了个人之间的公开密钥交换......</string>
    <string name="DigitalCertification56">但在与网站进行通信时也会使用数字证书。</string>
    <string name="DigitalCertification57">通过从网站接受带有公开密钥的证书，您可以确认该网站未被第三方欺骗。</string>
    <string name="DigitalCertification58">该证书称为\"服务器证书\"，也由认证机构颁发。</string>
    <string name="DigitalCertification59">对于个人，证书绑定到一个电子邮件地址...</string>
    <string name="DigitalCertification6">准备好将公开密钥（PA）发送给B方。</string>
    <string name="DigitalCertification60">但在服务器证书的情况下，它绑定到一个域。</string>
    <string name="DigitalCertification61">服务器证书确保公开密钥由管理该证书绑定到域的组织颁发的。</string>
    <string name="DigitalCertification62">换句话说，可以确认管理域的网站的组织和管理存储网站内容的服务器的组织是相同的。</string>
    <string name="DigitalCertification63">通过这种方式，数字证书是通过认证机构保证公开密钥创建者的社会性机制。</string>
    <string name="DigitalCertification64">这就结束了对\"数字证书\"的解释。</string>
    <string name="DigitalCertification7">首先，A方需要要求认证机构颁发证书，证明他们是公开密钥（PA）的所有者。</string>
    <string name="DigitalCertification8">认证机构是管理数字证书的组织。基本上，任何人都可以成为这样一个组织，而且他们存在的数量很多。</string>
    <string name="DigitalCertification9">因此，利用像政府或大公司那样的值得信赖的组织进行审计是最安全的。</string>
    <string name="DigitalCertificationDescription">\"数字证书\"是保证公钥创建者的系统。您可以在购买所有算法后学习这个主题。</string>
    <string name="DigitalSignature">数字签名</string>
    <string name="DigitalSignature0">\"数字签名\"由\"讯息鉴别码\"实现的验证和伪造检测这两个功能之外...</string>
    <string name="DigitalSignature1">也保证了\"防止否认\"。</string>
    <string name="DigitalSignature10">例如，在A方向B方发送信息之后，我可以断言该信息是B方未经许可而创建的。</string>
    <string name="DigitalSignature100">严格地说，签名的创建可能是与\"加密\"不同的计算方法。</string>
    <string name="DigitalSignature101">但是，使用秘密密钥来创建签名并使用公开密钥来进行签名验证这一点是共通的，为方便起见，在这里我们这样解释。</string>
    <string name="DigitalSignature11">另外，因为我们使用一个公有密钥，当A方向B方以外的其他人发送消息时，我们需要准备不同的密钥。</string>
    <string name="DigitalSignature12">另一方面，数字签名系统不是使用MAC，而是使用只有发件人可以创建的数据作为特定的根据。 这些数据被称为\"数字签名\"。</string>
    <string name="DigitalSignature13">让我们看看这个机制的大纲。</string>
    <string name="DigitalSignature14">\"签名\"在图像中是数字签名，只能由A方创建。</string>
    <string name="DigitalSignature15">因此，当接收到具有A方数字签名的信息时，确保发送方确实是A方。</string>
    <string name="DigitalSignature16">信息的接收方B方能够确认数字签名是A方的，但他们不能自己创建相同的数字签名。</string>
    <string name="DigitalSignature17">与讯息鉴别码不同，由于不使用公有密钥，因此，A方可以使用相同的数字签名将其消息发送给多个人。</string>
    <string name="DigitalSignature2">我们来回顾一下\"讯息鉴别码\"。</string>
    <string name="DigitalSignature20">让我们具体看看如何创建数字签名。</string>
    <string name="DigitalSignature21">在讯息鉴别码中，用于创建MAC的密钥是公有的...</string>
    <string name="DigitalSignature22">当创建数字签名时，我们应用\"公开密钥加密\"的过程。</string>
    <string name="DigitalSignature23">本应用程序中详细描述了\"公开密钥加密\"。 我们来回顾一下这里的一般流程。</string>
    <string name="DigitalSignature24">A方已经对数据进行了加密，并准备将其发送给B方。</string>
    <string name="DigitalSignature25">首先，数据的接收者B准备公开密钥（P）和秘密密钥（S）。</string>
    <string name="DigitalSignature26">B方将公开密钥传给A方。</string>
    <string name="DigitalSignature27">A方使用公开密钥来加密数据。</string>
    <string name="DigitalSignature28">然后他们将密文发送给B方。</string>
    <string name="DigitalSignature29">B方使用秘密密钥将收到的密文解密为原始数据，完成交换。</string>
    <string name="DigitalSignature3">讯息鉴别码是通过将MAC分配给信息，以便将信息的发送者特定为加密密钥的所有者的一种机制。</string>
    <string name="DigitalSignature30">因此，在公开密钥加密中，公共密钥用于加密，秘密密钥用于解密。</string>
    <string name="DigitalSignature31">因此，任何人都可以使用公开密钥加密数据...</string>
    <string name="DigitalSignature32">由于只有B方拥有秘密密钥，所以保证只有B方才能解密。</string>
    <string name="DigitalSignature33">那么，如果我们逆向这个流程，使用秘密密钥对其进行加密并使用公开密钥进行解密，会发生什么？</string>
    <string name="DigitalSignature34">在这种情况下，由于A方拥有秘密密钥，只有他们可以对数据进行加密，但创建的密文可以由拥有公开密钥的任何人解密。</string>
    <string name="DigitalSignature35">作为一种加密形式，这绝对没有意义，但从另一种角度来看，你可以看到密文的创建者保证是拥有秘密密钥的A方。</string>
    <string name="DigitalSignature36">在\"数字签名\"中，只有A方可以做的密文可以用作\"签名\"。</string>
    <string name="DigitalSignature37">让我们看看使用\"数字签名\"的信息交换流程。</string>
    <string name="DigitalSignature38">首先，准备A方想要发送的信息和一个秘密密钥/公开密钥。</string>
    <string name="DigitalSignature39">信息的发送者准备秘密密钥和公开密钥，这一点与公开密钥加密不同。</string>
    <string name="DigitalSignature4">这里，为了方便起见，我们发送消息而不加密它。</string>
    <string name="DigitalSignature40">A方把公开密钥交给B方。</string>
    <string name="DigitalSignature41">用秘密密钥加密信息。</string>
    <string name="DigitalSignature42">将信息加密的作为签名，并在这以后在图上标记为\"Sig\"。</string>
    <string name="DigitalSignature43">将信息和签名发送给B方。</string>
    <string name="DigitalSignature44">B方使用公开密钥对密文进行解密。</string>
    <string name="DigitalSignature45">确认解密的信息与接收到的信息一致。 交换完成。</string>
    <string name="DigitalSignature46">可以用A方的公开密钥解密的密文只能由A方自己创建。</string>
    <string name="DigitalSignature47">因此，我们可以确认，A方是发送该邮件的人，并且该邮件没有被伪造。</string>
    <string name="DigitalSignature48">另外，由于A方的签名不能由B方创造，B方只有公开密钥，因此也起了防止否认的作用。</string>
    <string name="DigitalSignature49">但是，公开密钥加密往往需要时间进行加密和解密。</string>
    <string name="DigitalSignature5">A方将信息和MAC以及用于创建MAC的密钥发送给B方。</string>
    <string name="DigitalSignature50">因此，实际上并不直接加密信息...</string>
    <string name="DigitalSignature51">为了缩短计算时间，首先找到信息的哈希值...</string>
    <string name="DigitalSignature52">然后加密哈希值并将其用于签名。</string>
    <string name="DigitalSignature53">有关哈希的更详细的解释可以在这个应用程序的\"哈希函数\"条目中找到。</string>
    <string name="DigitalSignature54">信息和签名发送给B方。</string>
    <string name="DigitalSignature55">以相同的方式，B方计算接收到的信息的哈希值。</string>
    <string name="DigitalSignature56">接下来，使用公开密钥对接收到的签名进行解密，并从中计算哈希值。</string>
    <string name="DigitalSignature57">如果可以确认两个获得的哈希值相同，则使用数字签名的交换已完成。</string>
    <string name="DigitalSignature58">数字签名提供验证，伪造检测和防止否认的功能，但存在一个问题。</string>
    <string name="DigitalSignature59">B方通过使用数字签名交换信息，认为A方是发件人......</string>
    <string name="DigitalSignature6">B方使用收到的信息和密钥重新创建MAC，并确认其与接收到的MAC相匹配。</string>
    <string name="DigitalSignature60">事实上，与冒充A方的有恶意的X方进行互动的可能性不能说是零。</string>
    <string name="DigitalSignature61">这个问题的根本原因在于，在公开密钥加密中，我们不知道公开密钥属于谁。</string>
    <string name="DigitalSignature62">公开密钥中没有任何信息表示创建者是谁。</string>
    <string name="DigitalSignature63">因此，公开密钥有可能是由某个冒充A方的人创建的......</string>
    <string name="DigitalSignature64">也有可能它确实是A方创建的公开密钥，并不是很清楚。</string>
    <string name="DigitalSignature66">这个问题可以通过\"数字证书\"系统来解决。</string>
    <string name="DigitalSignature67">在\"数字证书\"中，我们将有创建者信息的公开密钥视为一个证书。</string>
    <string name="DigitalSignature68">\"数字证书\"在本应用程序中有更详细的解释。</string>
    <string name="DigitalSignature69">这就结束了对\"数字签名\"的解释。</string>
    <string name="DigitalSignature8">由此可以证实A方是发件人，而且信息没有被伪造。</string>
    <string name="DigitalSignature9">但是，由于讯息鉴别码是使用公有密钥的，所以具有密钥的人都有可能成为信息的发送者。</string>
    <string name="DigitalSignatureDescription">\"数字签名\"是解决欺骗，伪造和非声誉问题的系统。您可以在购买所有算法后学习这个主题。</string>
    <string name="Dijkstra">戴克斯特拉算法</string>
    <string name="Dijkstra0">戴克斯特拉算法是查找图的最短路径的算法。这是比贝尔曼-福特算法更有效的方法。</string>
    <string name="Dijkstra1">首先，设置每个点的初始成本。设置起点为0，其他的点为无限大。</string>
    <string name="Dijkstra10">移动到被确定为最短路径的点B。</string>
    <string name="Dijkstra100">这是因为每当使用其他路线时都需要经过点C，导致比当前路线成本更高。</string>
    <string name="Dijkstra101">路线A-B-D是在候选点中选择成本最低路线的结果。因此，通过其他点去D时成本总是大于现在。</string>
    <string name="Dijkstra102">这次，点B和点C作为候选。</string>
    <string name="Dijkstra11">可以从当前点追踪的点新添加为候选。在这种情况下，它是点C，D，E。</string>
    <string name="Dijkstra12">用和之前同样的计算方法，计算每个候选点的成本。</string>
    <string name="Dijkstra13">从点B追踪到点C的成本为2＋6，为8， 但由于当前值5较小，所以不被更新。</string>
    <string name="Dijkstra14">更新了剩余点D和E的成本。</string>
    <string name="Dijkstra15">从候选点中选择成本最低的点。在这种情况下，它是点D。</string>
    <string name="Dijkstra16">此时，到选定点D的路线A-B-D被确定为从起点到点D的最短路径。</string>
    <string name="Dijkstra17">这样，戴克斯特拉算法是一个一个确定到每个点的最短路径来搜索图的算法。</string>
    <string name="Dijkstra18">重复相同的操作，直到到达终点G。</string>
    <string name="Dijkstra2">从起点开始。</string>
    <string name="Dijkstra3">从当前点追踪还未查找的点。找到的点作为下一个追踪的候选。</string>
    <string name="Dijkstra35">到达终点G，搜索完成。</string>
    <string name="Dijkstra36">最后制成的橘黄色的树被称为最短路线树，它代表了到每个点的最短路径。</string>
    <string name="Dijkstra37">重点强调的是到终点G的最短路径。</string>
    <string name="Dijkstra38">这样，对所有的边重复计算和更新成本的贝尔曼-福特算法相比，戴克斯特拉算法通过设计接下来选择哪个点来有效的搜索最短路径。</string>
    <string name="Dijkstra39">与贝尔曼-福特算法一样，即使存在单行道或者来回路径成本不一样的边...</string>
    <string name="Dijkstra4">计算每个候选点的成本。计算方法是，\"当前点的成本＋移动到候选点的成本\"。</string>
    <string name="Dijkstra40">戴克斯特拉算法也可以正确的找到最短路径。</string>
    <string name="Dijkstra41">另外，如图所示，对边缘有设置方向的图称为\"有向图\"，没有设置方向的图称为\"无向图\"。</string>
    <string name="Dijkstra42">当克斯特拉算法包含\"负成本\"时，可能无法正确获得最短路径。这一点与贝尔曼-福特算法有所不同。</string>
    <string name="Dijkstra43">在上图中，经过有负成本的C-B的A-C-B-G（成本2）是正确的最短路径。</string>
    <string name="Dijkstra44">我们试着用戴克斯特拉算法来解决它。</string>
    <string name="Dijkstra45">从起始点A追踪的未探索的点是B和C，每个点的成本是2和4。</string>
    <string name="Dijkstra46">此时，戴克斯特拉算法将路线A-B确定为从起点A到B的最短路径。</string>
    <string name="Dijkstra47">原因是\"使用其他路线时，必须经过点C，但A-C的成本大于A-B的成本\"。</string>
    <string name="Dijkstra48">正如您所看到的，这是基于所有的边都大于0的假设，换句话说是在图中没有负成本。</string>
    <string name="Dijkstra49">算法得出从起点A到终点G的最短路径为A-B-C，其成本是3。如上所述，这个结果是不正确的。</string>
    <string name="Dijkstra5">例如，在点B的情况下，由于起点的成本是0，所以0＋2为2。同样，C的成本是5，所以0＋5为5。</string>
    <string name="Dijkstra52">如上图所示...</string>
    <string name="Dijkstra53">包含循环特定路线的成本变为负值的\"负闭环\"的图形的情况下...</string>
    <string name="Dijkstra54">在戴克斯特拉算法中，尽管不存在最短路径，我们推导出错误的最短路径作为解决方案。</string>
    <string name="Dijkstra55">因此，戴克斯特拉算法不能够使用于包含负的成本的图中。</string>
    <string name="Dijkstra56">相反，戴克斯特拉算法可以在不存在负成本时，比贝尔曼-福特算法用较少的计算量来查找最短路径。</string>
    <string name="Dijkstra57">这就结束了对\"戴克斯特拉算法\"的解释。</string>
    <string name="Dijkstra6">如果计算结果小于当前值，则用新值更新成本。</string>
    <string name="Dijkstra7">点B，C的当前成本是无限大的，计算结果较小，所以我们用新的值更新。</string>
    <string name="Dijkstra8">从候选点中选择成本最低的点。在这种情况下，它将是B。</string>
    <string name="Dijkstra9">此时，到选定点B的路线A-B被确定为从起点到点B的最短路线。</string>
    <string name="DijkstraDescription">\"戴克斯特拉算法\"是用于确定最短路径的算法。您可以在购买所有算法后学习这个主题。</string>
    <string name="Euclidean">辗转相除法</string>
    <string name="Euclidean0">辗转相除法是，找到两个数字的最大公约数的算法。</string>
    <string name="Euclidean1">它在公元前300年由欧几里得发现，被称为世界上最古老的算法。</string>
    <string name="Euclidean10">A mod B表示，A被B除后的余数C。</string>
    <string name="Euclidean11">让我们使用具体的数字来展示一些实例操作。</string>
    <string name="Euclidean12">让我们来看看辗转相除法的实际应用。</string>
    <string name="Euclidean13">首先，找到用较小的数字除去较大的数字的余数。</string>
    <string name="Euclidean14">换句话说，我们用较大的数字和较小的数字进行mod操作。</string>
    <string name="Euclidean15">除法的结果，得到余数417。</string>
    <string name="Euclidean16">这次，我们用除数695和余数417进行mod操作。</string>
    <string name="Euclidean17">我们得到278。</string>
    <string name="Euclidean18">重复相同操作。用417和278进行操作。</string>
    <string name="Euclidean19">我们得到139。</string>
    <string name="Euclidean2">举一个例子，我们来考虑一下1112和695的最大公约数。</string>
    <string name="Euclidean20">我们用278和139进行mod操作。</string>
    <string name="Euclidean21">我们得到0。</string>
    <string name="Euclidean22">也就是说，278可以被139整除。</string>
    <string name="Euclidean23">当余数变为0时，最后一个操作的除数139是1112和695的最大公约数。</string>
    <string name="Euclidean24">为什么用辗转相除法可以找到最大公约数呢？让我们用图表来考虑这个问题。</string>
    <string name="Euclidean25">我们分别用棒的长度来表示1112和695。</string>
    <string name="Euclidean26">我们将最大公约数为n，分段尺度。</string>
    <string name="Euclidean27">因为最大公约数为139，为方便起见，1112有8个尺度，695有5个尺度。</string>
    <string name="Euclidean28">实际上，并不知道每个棒上有多少个尺度。</string>
    <string name="Euclidean29">但是，我们知道1112和695是最大公约数n的倍数。</string>
    <string name="Euclidean3">用通常的方法，我们把2个数字分解成素数...</string>
    <string name="Euclidean30">在这里，和前面的操作一样，从较大的数字除去较小的数字后找到余数。</string>
    <string name="Euclidean31">我们得到417。从图中可以看出，417也是一个可以用n的刻度严密雕刻的数字。</string>
    <string name="Euclidean32">和之前一样重复mod操作。</string>
    <string name="Euclidean35">用417除以695可以得到余数278。</string>
    <string name="Euclidean36">这里的余数278是n的整数倍的数字，换句话说，它们有相同的最大公约数。</string>
    <string name="Euclidean37">重复除法。</string>
    <string name="Euclidean38">由于278可以用139整除，所以余数为0。</string>
    <string name="Euclidean39">在这个时候我们知道最大公约数的n是139。</string>
    <string name="Euclidean4">找出共同素数的最大公约数(GCD)。</string>
    <string name="Euclidean40">这样，辗转相除法可以通过重复除法来找到最大公约数。</string>
    <string name="Euclidean41">即便2个目标数字是庞大的数字，您也可以通过固定的顺序找到最大公约数，这是一个很大的优势。</string>
    <string name="Euclidean42">这就结束了辗转相除法的解释。</string>
    <string name="Euclidean5">我们找到1112和695的最大公约数是139。</string>
    <string name="Euclidean6">然而，用这种方法，两个数字变得越大，素数分解就越困难。</string>
    <string name="Euclidean7">用辗转相除法，可以更有效地获得最大公约数。</string>
    <string name="Euclidean8">在进入辗转相除法的解释之前，我们解释一下mod操作。</string>
    <string name="Euclidean9">mod操作是获得除法余数的操作。</string>
    <string name="ExperimentalModeTitle">测试</string>
    <string name="FewUnique">很少有独特的</string>
    <string name="GetItemInfoFailed">无法获取物品信息。请确保您已连接到互联网。</string>
    <string name="GraphSearchSection">图表搜索</string>
    <string name="Hanoi">汉诺塔</string>
    <string name="Hanoi0">\"汉诺塔\"是一个移动磁盘的难题。</string>
    <string name="Hanoi1">图中显示有三根桩ABC和两个磁盘卡在桩A中。</string>
    <string name="Hanoi101">让我们看一个基于上述条件移动磁盘的例子。</string>
    <string name="Hanoi102">然后，使用与之前相同的原理，我们将桩B上的磁盘移动到桩C上。</string>
    <string name="Hanoi15">由于小磁盘位于顶部，因此可以移动到B.</string>
    <string name="Hanoi16">我们将更大的磁盘移动到桩C.</string>
    <string name="Hanoi17">将较小的磁盘移动到桩C，完成移动。我们可以确认在有2个磁盘时可以达到目标。</string>
    <string name="Hanoi18">如果有三个磁盘会发生什么？</string>
    <string name="Hanoi19">让我们忽略最大的磁盘，并考虑如何将剩余的磁盘移动到桩B.</string>
    <string name="Hanoi2">目标是将磁盘移动到桩C上，同时使磁盘保持与桩A相同的顺序。</string>
    <string name="Hanoi20">如果我们移动剩余磁盘的方式与之前移动2个磁盘时一样，我们可以将它们移动到桩B.</string>
    <string name="Hanoi21">我们将最大的磁盘移动到桩C上。</string>
    <string name="Hanoi22">移动完成。已确认有3个磁盘时也可以达到目标。</string>
    <string name="Hanoi23">实际上，无论有多少个磁盘，所有磁盘都可以在这个游戏中达到目标。</string>
    <string name="Hanoi24">我们用数学归纳证明这一点。</string>
    <string name="Hanoi25">当有1个磁盘时，我们能够达到目标。</string>
    <string name="Hanoi27">假设有n个磁盘时我们可以达到目标。</string>
    <string name="Hanoi29">让我们考虑移动n + 1个磁盘。</string>
    <string name="Hanoi30">我们将忽略最大的磁盘。</string>
    <string name="Hanoi31">假设我们能够移动n个磁盘，我们将n个磁盘移动到桩B上。</string>
    <string name="Hanoi32">我们将最大的磁盘移动到桩C上。</string>
    <string name="Hanoi33">我们将桩B上的n个磁盘移动到桩C上。移动完成。</string>
    <string name="Hanoi34">使用数学归纳法，我们证明了可以通过任意数量的磁盘达到目标。</string>
    <string name="Hanoi35">我们来考虑一下汉诺塔的解决方案。</string>
    <string name="Hanoi36">要解决n个磁盘的汉诺塔时，需要使用n-1汉诺塔解决方案。</string>
    <string name="Hanoi37">为了解决n-1个汉诺塔，我们将使用n - 2个汉诺塔来解决它，直到最后只有1个磁盘的状态，递归地解决。</string>
    <string name="Hanoi38">这种递归模式被用在许多算法中，这种算法被称为\"递归算法\"。</string>
    <string name="Hanoi39">这就结束了对\"汉诺塔\"的解释。</string>
    <string name="Hanoi4">移动磁盘有两个条件：第一个条件是一次只能移动一个磁盘。</string>
    <string name="Hanoi5">像这样移动1个磁盘是没有问题的...</string>
    <string name="Hanoi6">但不能像图中那样同时移动2个磁盘。</string>
    <string name="Hanoi9">第二种情况是，不能在较小的磁盘上放置较大的磁盘。</string>
    <string name="Hash">哈希表</string>
    <string name="Hash0">\"哈希表\"是一种数据结构。</string>
    <string name="Hash1">擅长以\"keys\"和\"values\"组成的集合存储数据。</string>
    <string name="Hash10">盒子2也不是Ally。</string>
    <string name="Hash11">盒子3也不是Ally。</string>
    <string name="Hash12">存储在第4个盒子中的数据的Key与Ally匹配。</string>
    <string name="Hash13">通过取出相应的Value，我们发现Ally的性别是女性（F）。</string>
    <string name="Hash14">这样，线性搜索操作的成本与数据大小成正比。</string>
    <string name="Hash15">将数据存储在数组中时，需要花费一些时间来搜索数据，使其成为不合适的选择。</string>
    <string name="Hash16">哈希表解决了这个问题。</string>
    <string name="Hash17">我们将准备一个数组来存储一些数据。 为了方便，在数组中有5个盒子。</string>
    <string name="Hash18">现在我们来存储一些数据。</string>
    <string name="Hash19">存储\"Joe \"的数据时...</string>
    <string name="Hash2">在这种情况下，名字是key，而性别是value。</string>
    <string name="Hash20">我们使用哈希函数计算密钥的哈希值。 在这种情况下得到的结果是4928。</string>
    <string name="Hash21">\"哈希函数\"在本应用程序中有更详细的解释，它是一个将数据转换为固定长度值的函数。</string>
    <string name="Hash22">查找的哈希值除以数组中的盒子数5，以找出余数。</string>
    <string name="Hash23">查找除法余下部分的操作称为\"mod \"操作。</string>
    <string name="Hash24">mod操作的结果值为3。</string>
    <string name="Hash25">Joe的数据存储在数组的第3个盒子中，与找到的数字相同。</string>
    <string name="Hash26">该操作将被重复以存储其他数据。</string>
    <string name="Hash27">存储\"Sue\"的数据时...</string>
    <string name="Hash28">我们找到密钥的哈希值，并使用数组中的盒子数5对其执行mod运算。结果为1。</string>
    <string name="Hash29">\"Sue\"的数据存储在数组的盒子1中。</string>
    <string name="Hash3">作为一个例子，让我们将图中的数据想象为一个数组。</string>
    <string name="Hash30">存储\"Dan\"的数据时...</string>
    <string name="Hash31">我们找到密钥的哈希值，并使用数组中的盒子数5对它执行mod运算。结果为4。</string>
    <string name="Hash32">\"Dan\"的数据存储在数组的盒子4中。</string>
    <string name="Hash33">存储\"Nell \"的数据时...</string>
    <string name="Hash34">我们找到密钥的哈希值，并使用数组中的盒子数5对其执行mod运算。结果为1。</string>
    <string name="Hash35">当我们试图在数组的盒子1中存储\"Nell \"的数据时...</string>
    <string name="Hash36">\"Sue\"的数据已经存储在这里。当这样的事情发生时......</string>
    <string name="Hash37">它以列表形式连接到现有数据。</string>
    <string name="Hash38">有几种类型的哈希表结构，但使用列表的方法称为\"链式方法\"。</string>
    <string name="Hash39">存储\"Ally\"的数据时...</string>
    <string name="Hash4">我们为数组准备了6个盒子，并在其中存储了数据。</string>
    <string name="Hash40">我们找到密钥的哈希值，并使用数组中的盒子数5对其执行mod运算。结果为3。</string>
    <string name="Hash41">由于\"Joe \"的数据位于数组的第3个盒子中，\"Ally \"的数据以列表的形式连接。</string>
    <string name="Hash42">存储\"Bob \"的数据时...</string>
    <string name="Hash43">我们找到密钥的哈希值，并使用数组中的盒子数5对其执行mod运算。结果为3。</string>
    <string name="Hash44">由于\"Joe \"和\"Ally \"数据位于数组的第3个盒子中，\"Bob \"的数据将作为列表进行连接。</string>
    <string name="Hash45">所有数据完成存储，哈希表完成。</string>
    <string name="Hash46">让我们考虑一下查找Dan的性别的情况。</string>
    <string name="Hash47">为了知道Dan储存在第几个盒子的数组中...</string>
    <string name="Hash48">我们找到密钥的哈希值，并使用数组中的盒子数5对它执行mod运算。结果为4。</string>
    <string name="Hash49">存储在数组的第4个盒子中的数据的密钥匹配\"Dan\"。</string>
    <string name="Hash5">现在让我们想象一下查找Ally的性别的情况。</string>
    <string name="Hash50">通过取出相应的Value，我们得知Dan的性别是男性（M）。</string>
    <string name="Hash51">那么当我们查看Ally的性别时会发生什么？</string>
    <string name="Hash52">为了找出Ally在数组的第几个盒子中...</string>
    <string name="Hash53">我们找到密钥的哈希值，并使用数组中的盒子数5对其执行mod运算。结果为3。</string>
    <string name="Hash54">存储在数组的第3个盒子中的数据的密钥是Joe，而不是Ally。</string>
    <string name="Hash55">因此，以数据\"Joe \"开始的列表上执行线性搜索。</string>
    <string name="Hash56">找到密钥为\"Ally\"的数据。</string>
    <string name="Hash57">通过取出相应的Value，我们知道Ally的性别是女性（F）。</string>
    <string name="Hash58">正如你所看到的，通过使用哈希函数，哈希表能够快速访问数组中的数据。</string>
    <string name="Hash59">当哈希值重叠时，将使用列表，从而可以灵活处理不确定数量的数据。</string>
    <string name="Hash6">我们不知道Ally储存在数组的第几个盒子里。</string>
    <string name="Hash60">如果用于哈希表的数组的大小太小，则重复会增加并且线性搜索将更可能发生。</string>
    <string name="Hash61">相反，如果数组的大小太大，会有很多数据盒子没有存储数据，浪费内存，因此需要谨慎。</string>
    <string name="Hash62">能够灵活储存数据和快速查找的哈希表被用在编程语言的关联数组中。</string>
    <string name="Hash63">这就结束了对\"哈希表\"的解释。</string>
    <string name="Hash7">因此，我们需要从头开始搜索。 这个操作被称为\"线性搜索\"。</string>
    <string name="Hash8">存储在第0个盒子中的数据的Key是Joe，而不是Ally。</string>
    <string name="Hash9">盒子1也不是Ally。</string>
    <string name="HashFunction">哈希函数</string>
    <string name="HashFunction0">\"哈希函数\"是将给定数据转化为固定长度的不规则值的函数。</string>
    <string name="HashFunction1">想象一下搅拌器，您可能更容易理解哈希函数。</string>
    <string name="HashFunction10">在这个前提下，我们来看看哈希函数的特征。</string>
    <string name="HashFunction11">第一个特征是，输出值的数据长度不变。</string>
    <string name="HashFunction12">输出数据的长度取决于哈希函数，但例如在SHA-1的情况下，它固定为20个字节。</string>
    <string name="HashFunction13">即使输入非常大的数据，输出的哈希值的数据长度也不会改变。</string>
    <string name="HashFunction16">同样，不管输入的数据有多小，哈希值的数据长是相同的。</string>
    <string name="HashFunction19">作为第二个特征，相同的输入的输出也必定相同。</string>
    <string name="HashFunction2">将数据输入到哈希函数中…</string>
    <string name="HashFunction25">第三个特征是，即使输入了相似的数据，如果它们相差1比特，输出也会有很大的不同。</string>
    <string name="HashFunction3">输出不规则的值。</string>
    <string name="HashFunction31">如果输入相似的数据，并不一定哈希值也相似。</string>
    <string name="HashFunction32">作为第四个特征，即使输入完全不同的数据，输出相同的哈希值会以低概率出现。</string>
    <string name="HashFunction38">这被称为\"哈希值的冲突\"。</string>
    <string name="HashFunction39">作为第五个特征，实际上不可能通过哈希值返回来算数据。</string>
    <string name="HashFunction4">如果您想象哈希函数是将数据搅拌的机器，这样可能更容易理解…</string>
    <string name="HashFunction41">输入和输出流程是单项的，与\"加密\"有很大区别。</string>
    <string name="HashFunction43">最后一个特征是计算相对简单。</string>
    <string name="HashFunction46">有几种哈希函数算法，但现在通常使用\"SHA-2\"。</string>
    <string name="HashFunction47">哈希函数可以说是，将输入的数据的摘要输出，在各种情况下被使用。</string>
    <string name="HashFunction48">在应用程序中，作为哈希函数的使用实例，详细解释了\"讯息鉴别码\"和\"哈希表\"。</string>
    <string name="HashFunction49">这就结束了对\"哈希函数\"的解释。</string>
    <string name="HashFunction5">输出的不规则的值称为哈希值。</string>
    <string name="HashFunction6">哈希值是一个数字，但它通常以16进制表示…</string>
    <string name="HashFunction7">计算机使用数字0和1的二进制来管理任何数据。</string>
    <string name="HashFunction8">哈希值也是数据，并以二进制来管理。</string>
    <string name="HashFunction9">实际上，哈希函数在计算机内部进行一些数值计算。</string>
    <string name="Heap">堆</string>
    <string name="Heap0">\"堆\"是一种树形结构，并在实现\"优先队列\"时使用。</string>
    <string name="Heap1">优先队列是一种数据结构。</string>
    <string name="Heap10">因为父类6>子类5，则替换数字。</string>
    <string name="Heap11">重复此操作，直到不发生替换。</string>
    <string name="Heap12">父类1 &lt;子类5，由于父类的数字较小，所以不会发生替换。</string>
    <string name="Heap13">在堆中添加数字现在已完成。</string>
    <string name="Heap14">从堆中取出数字时，从最上面的数字取出。</string>
    <string name="Heap15">在堆中，最小值保存在顶部位置。</string>
    <string name="Heap16">由于在顶部的数字被取出，我们需要组织堆的结构。</string>
    <string name="Heap17">将结尾的数字移动到顶部。</string>
    <string name="Heap18">当子类数字小于父类数字时，相邻子类数字中较小的数字与父类数字交换。</string>
    <string name="Heap19">由于父类6>右侧子类5>左侧子类3，则左侧子类与父类交换。</string>
    <string name="Heap2">在优先队列中，数据可以按任意顺序添加。</string>
    <string name="Heap20">重复此操作，直到不发生替换。</string>
    <string name="Heap22">由于右侧子类8>父类6>左侧子类4，则左侧子类与父类交换。</string>
    <string name="Heap23">从堆中取出数字现在已完成。</string>
    <string name="Heap24">像这样使用堆可以快速取出最小的数据。</string>
    <string name="Heap25">但是，无法执行在树中间取出数据的操作。</string>
    <string name="Heap26">堆用于如优先队列和戴克斯特拉算法等。</string>
    <string name="Heap27">这就结束了对\"堆\"的解释。</string>
    <string name="Heap3">相反，在取出数据时，首先选择最小值。</string>
    <string name="Heap4">能够自由地添加数据并从最小值开始取出，这被定义为优先队列。</string>
    <string name="Heap5">继续，让我们看看堆的结构。</string>
    <string name="Heap6">作为堆的一个规则，子类数字总是大于其父类数字。</string>
    <string name="Heap7">让我们尝试添加一个数字到堆中。</string>
    <string name="Heap8">添加的数字将首先放在末尾。</string>
    <string name="Heap9">如果父类数字较大，则子类与父类互换。</string>
    <string name="HeapDescription">\"堆\"是用于快速提取最小值的数据结构。您可以在购买所有算法后学习这个主题。</string>
    <string name="HeapSort">堆排序</string>
    <string name="HeapSort0">堆排序是数列排序的算法之一，其特点是利用堆的数据结构。</string>
    <string name="HeapSort1">首先，将所有的数字存储在堆中。按降序构建堆。堆在本应用程序的\"堆\"中有详细描述。</string>
    <string name="HeapSort10">具体来说，堆上的每个元素（节点）和排列...</string>
    <string name="HeapSort105">还有更有效的方法来建立堆，但这次我们选择了一个简单的方法。</string>
    <string name="HeapSort11">如图所示的对应关系。</string>
    <string name="HeapSort15">正如你看到，可以说是堆被强行填满在排列中。</string>
    <string name="HeapSort16">现在，让我们尝试使用交换方法对数组进行排序。</string>
    <string name="HeapSort17">为了更容易理解，我们将保持显示树结构的堆。</string>
    <string name="HeapSort18">和之前的操作一样，从在堆中储存数字的操作开始。</string>
    <string name="HeapSort20">根据树结构堆中数字的替换，在数组内也进行数字的替换。</string>
    <string name="HeapSort21">将所有的数字储存在堆中。同时，按降序将数组排列成了堆结构。</string>
    <string name="HeapSort22">然后，将在堆中存储的数字一个一个取出。</string>
    <string name="HeapSort23">降序堆是从大到小取出数据。</string>
    <string name="HeapSort24">在数组中，第一个数字在堆中是最大的一个数字。</string>
    <string name="HeapSort25">将数组开头的数字替换为堆的最后一个元素对应的数组，并让操作完成。</string>
    <string name="HeapSort26">重新组织堆，以保持其结构。</string>
    <string name="HeapSort27">重复此操作，直到所有的数字完成排序。</string>
    <string name="HeapSort28">排序完成。</string>
    <string name="HeapSort29">这就结束了堆排序的解释。</string>
    <string name="HeapSort3">所有的数字已储存在堆中。</string>
    <string name="HeapSort4">接下来，逐个取出储存在堆中的数字。</string>
    <string name="HeapSort5">降堆的一个特性是数据将被从大到小取出，将取出来的数字按相反的顺序排列，数字将完成排序。</string>
    <string name="HeapSort7">所有的数字都从堆中取出，排序完成。</string>
    <string name="HeapSort8">除了数列之外，这次我们准备了一个称为堆的数据结构...</string>
    <string name="HeapSort9">通常情况下，堆被嵌入到储存数列的排列中，并且只通过交换数字来完成排序。</string>
    <string name="Huffman">霍夫曼编码</string>
    <string name="Huffman0">\"霍夫曼编码\"是编码数据的算法之一。</string>
    <string name="Huffman1">它用于JPEG和ZIP等压缩图像和文件。</string>
    <string name="Huffman10">作为一个简单的例子，如图所示，我们设置了编码规则。用2比特表示一个字符。</string>
    <string name="Huffman100">考虑\"C或D\"作为一个字符并重复相同的操作。</string>
    <string name="Huffman101">从\"A\"\"B\"\"C或D\"三个中，按出现率低的顺序查找2个字母。</string>
    <string name="Huffman102" formatted="false">在这种情况下，它是\"A\"35%和\"B\"25%。</string>
    <string name="Huffman103">用一条线连接两个字母并构成一个树状结构。</string>
    <string name="Huffman104">将两个字符组合为\"A或B\"并合计出现比率。</string>
    <string name="Huffman105">考虑\"A或B\"作为一个字符。</string>
    <string name="Huffman106">同样，我们选择两个出现比率小的字母，它们是最后剩下的两个字母\"A或B\"和\"C或D\"。</string>
    <string name="Huffman107">用一条线连接两个字符来创建一个树结构。</string>
    <string name="Huffman108">所有的字母都变成了\"A或B或C或D\"。出现比率当然变成了100%。</string>
    <string name="Huffman109">这就完成了推导霍夫曼编码的树结构。</string>
    <string name="Huffman11">根据规则，ABAABACD被编码。结果，数据的大小减少到了16比特，大大减少了。</string>
    <string name="Huffman110">每个字符的出现比率再次显示。</string>
    <string name="Huffman111">代码0和1被分配给上下延伸的分支。</string>
    <string name="Huffman112">接下来，我们从树的根部遍历每个字符并确定相应的代码。</string>
    <string name="Huffman113">对于\"A\"，被分配的代码是\"00\"。</string>
    <string name="Huffman114">对于\"B\"，被分配的代码是\"01\"。</string>
    <string name="Huffman115">对于\"C\"，被分配的代码是\"10\"。</string>
    <string name="Huffman116">对于\"D\"，被分配的代码是\"11\"。</string>
    <string name="Huffman117">这就结束了用霍夫曼编码的编码。</string>
    <string name="Huffman118">由于树结构与上面的例子不同，字符的出现率没有很大的差别，所以所有字符都由2比特表示。</string>
    <string name="Huffman119">例如，为了表示出现率最高的\"A\"为1比特，将\"C\"和\"D\"表示为3比特…</string>
    <string name="Huffman12">当然，由于我们是任意决定的规则，所以我们需要把编码规则告诉接受这个字符示例的一边。</string>
    <string name="Huffman120" formatted="false">由于\"C或D\"的出现率（40%）高于\"A\"的出现率（35%），所以编码效果更差。</string>
    <string name="Huffman121">如您所见，霍夫曼编码能够根据字符的出现率进行简单而有效的编码。</string>
    <string name="Huffman122">这就结束了对\"霍夫曼编码\"的解释。</string>
    <string name="Huffman13">为了方便，在这个解释中，我们不考虑传输编码规则所需的通讯费用。</string>
    <string name="Huffman14">为了接受字符示例的一方还原代码...</string>
    <string name="Huffman15">每两个字符分开一次...</string>
    <string name="Huffman16">通过根据规则还原代码来取出原始字符示例\"ABAABACD\"。</string>
    <string name="Huffman17">让我们来考虑一下将编码的字符示例ABAABACD变得更小。</string>
    <string name="Huffman18">在上面的规则中，我们用2位表示一个字符示例...</string>
    <string name="Huffman19">如果\"A\"和\"B\"由1比特表示，似乎它们可以被编码得更小。</string>
    <string name="Huffman2">我们来考虑一个例子，在网络上传输字母示例\"ABAABACD\"情况。</string>
    <string name="Huffman20">在字符示例\"ABAABACD\"中，字母\"A\"和\"B\"比\"C\"和\"D\"使用得更多。</string>
    <string name="Huffman21">由此不是用\"C\"和\"D\"，而是用1比特来表示\"A\"和\"B\"更好。</string>
    <string name="Huffman22">根据规则，ABAABACD被编码。结果，数据的大小变成了10比特，并且进一步减小了。</string>
    <string name="Huffman23">为了接受编码的一方将代码还原为字符示例...</string>
    <string name="Huffman24">根据转换规则还原每一个字符示例...</string>
    <string name="Huffman25">例如，\"10\"的代码可以代表\"BA\"和\"C\"。</string>
    <string name="Huffman26">因此，取出了不同的字符示例。</string>
    <string name="Huffman27">还有其他各种可以取出的字符串，并且原始字符串不能被明确地确定。</string>
    <string name="Huffman28">当原始字符不能从代码中明确确定时，被称为\"不可唯一解码\"。</string>
    <string name="Huffman29">我们再来看另外一个例子。为了方便起见，假设两个字母A和B在如图所示中进行编码。</string>
    <string name="Huffman3">数据以0和1的二进制数字编码。</string>
    <string name="Huffman30">我们来考虑在编码规则中给出代码\"000001\"时的复原过程。</string>
    <string name="Huffman31">为了解码，我们将按顺序查看第一个数字。</string>
    <string name="Huffman32">第一个数字是\"0\"， 但即使只看到这一个字符，也不能判断它是代表\"A\"还是\"B\"。</string>
    <string name="Huffman33">直到第二个字母的数字是\"00\"，但我们不能判断它是代表\"AA\"还是代表\"B\"的一部分。</string>
    <string name="Huffman34">此外，虽然直到第三个字符的数字都是\"000\"，但我们不能判断它们是代表\"AAA\"还是\"B\"。</string>
    <string name="Huffman35">同样，甚至到第四个字符的数字都不能被判断...</string>
    <string name="Huffman36">甚至到第五个字母的数字都不能被判断...</string>
    <string name="Huffman37">最后，通过查看第六个数字\"1\"，我们可以判断开头的\"0\"是\"A\"，随后的\"00001\"是\"B\"。</string>
    <string name="Huffman38">数字\"000001\"可以明确地恢复为文字示例\"AB\"。这一点没有问题。</string>
    <string name="Huffman39">当转换表中的代码出现时，可以立即确定原来的字符的被称为\"瞬时代码\"…</string>
    <string name="Huffman4">例如在字符码ASCⅡ中字母\"A\"，\"B\"，\"C\"和\"D\"如图所示被编码。</string>
    <string name="Huffman40">正如这个例子，没有确认后向字符就不能判断原始字母的不是\"瞬时代码\"。</string>
    <string name="Huffman41">所以解码需要一些时间。</string>
    <string name="Huffman42">为了有效的编码/解码，最好是唯一可解码和瞬时代码。</string>
    <string name="Huffman43">让我们来看看在我们看到的图中两个编码规则是如何发生的。</string>
    <string name="Huffman44">如果我们尝试可视化第一个编码规则...</string>
    <string name="Huffman45">如果在给出的代码里，第一个字母是\"0\"，则确定为\"A\"。</string>
    <string name="Huffman46">但是如果是\"1\"，则可以是\"B\"或\"C\"或\"D\"的一部分。</string>
    <string name="Huffman47">同样我们来看看第二个编码规则。</string>
    <string name="Huffman48">如果给出了一个代码，它的第一个字母只有可能是\"0\"。</string>
    <string name="Huffman49">但是这里的\"0\"有可能是\"A\"或者\"B\"的一部分。</string>
    <string name="Huffman5">在ASCⅡ中，一个字符由8比特表示。</string>
    <string name="Huffman50">为了是唯一可解码和即时码，条件是任何一个代码不包含在其他代码的开头。</string>
    <string name="Huffman51">在前面的两个例子中，它们并没有满足条件。</string>
    <string name="Huffman52">霍夫曼编码是一种能够容易导出\"唯一可解码\"和\"即时码\"的算法。</string>
    <string name="Huffman53">我们来实际看看霍夫曼编码的代码。</string>
    <string name="Huffman54">霍夫曼编码是唯一可解的即时编码。</string>
    <string name="Huffman55">首先，计算每个字符的出现率。在\"ABAABACD\"的情况下，成为图中的比例。</string>
    <string name="Huffman56">接下来，按照出现比例的高的顺序对使用的字符进行排序。在这个例子中，依然是\"ABCD\"的顺序。</string>
    <string name="Huffman57">接下来，按出现比例低的顺序查找两个字母。</string>
    <string name="Huffman58" formatted="false">在这种情况下，它是\"C\"12.5%和\"D\"12.5%。</string>
    <string name="Huffman59">我们用一条线连接两个字母并构成一个树状结果。</string>
    <string name="Huffman6">根据SACⅡ，尝试编码字符示例\"ABAABACD\"。结果，数据的大小变成了64比特。</string>
    <string name="Huffman60">将两个字母合并为\"C或D\"，并将出现比率相加起来。</string>
    <string name="Huffman61">考虑\"C或B\"为一个字符，并重复相同的操作。</string>
    <string name="Huffman62">从\"A\"\"B\"\"C或D\"三个中，按照出现比率低的顺序查找两个字母。</string>
    <string name="Huffman63" formatted="false">在这种情况下，它是\"C\"12.5%和\"D\"12.5%。</string>
    <string name="Huffman64">我们用一条线连接两个字母并构成一个树状结果。</string>
    <string name="Huffman65">将两个字母合并为\"B或C或D\"，并将出现比率相加起来。</string>
    <string name="Huffman66">考虑\"B或C或D\"为一个字符。</string>
    <string name="Huffman67">同样，我们选择两个出现比率小的字母，它们是最后剩下的两个字母\"A\"和\"B或C或D\"。</string>
    <string name="Huffman68">我们用一条线连接它们并构成一个树状结构。</string>
    <string name="Huffman69">所有的字母都变成了\"A或B或C或D\"。出现比率当然变成了100%。</string>
    <string name="Huffman7">为了减少通信费用，我们考虑编码一个小于64比特的字符例子。</string>
    <string name="Huffman70">这就完成了推导霍夫曼编码的树结构。</string>
    <string name="Huffman71">再次显示各个字母的出现比率。</string>
    <string name="Huffman72">接下来，我们将对使用0和1的进行编码。</string>
    <string name="Huffman73">代码0和1被分配给上下延伸的分支。</string>
    <string name="Huffman74">如果0和1的分配是相反的，这并不重要。但是，如果您决定上级分支为1，则无法在中途更改分配方式。</string>
    <string name="Huffman75">所有代码均已分配。</string>
    <string name="Huffman76">接下来，我们从树的根部遍历每个字符并确定相应的代码。</string>
    <string name="Huffman77">在\"A\"的情况下…</string>
    <string name="Huffman78">被分配的代码是\"0\"。</string>
    <string name="Huffman79">在\"B\"的情况下…</string>
    <string name="Huffman8">ASCⅡ由8比特表示一个字符以区分和管理多个字符。</string>
    <string name="Huffman80">被分配的代码是\"10\"。</string>
    <string name="Huffman81">在\"C\"的情况下…</string>
    <string name="Huffman82">被分配的代码是\"110\"。</string>
    <string name="Huffman83">在\"D\"的情况下…</string>
    <string name="Huffman84">被分配的代码是\"111\"。</string>
    <string name="Huffman85">使用霍夫曼编码进行编码现在已完成。</string>
    <string name="Huffman86">通过使用此编码规则，我们将编码示例字母\"ABAABACD\"。</string>
    <string name="Huffman87">从树结构可以看出，\"任何代码都不会被包含在另一个代码的开头\"。</string>
    <string name="Huffman88">因此，它们是\"唯一可解码\"和\"即时编码\"。</string>
    <string name="Huffman89">另外，越是出现比率高的字符被分配较小比特的代码，我们可以看出，编码效率较好。</string>
    <string name="Huffman9">但是在字符示例\"ABAABACD\"中，仅使用了四个字母。以便于区分它们，对这四个数字进行编码似乎很好。</string>
    <string name="Huffman90" formatted="false">具体而言，在本例中，\"C或D\"的出现频率（25%）低于\"A\"的出现频率（50%）。</string>
    <string name="Huffman91">因此，即时\"C或D\"由3比特表示，用1比特表示\"A\"效率更高，这在结果中反应出来。</string>
    <string name="Huffman92">我们使用我们找到的编码规则，编码\"ABAABACD\"。</string>
    <string name="Huffman93">结果是14比特，比用2比特表示一个字符更短。</string>
    <string name="Huffman94">我们来看另一个例子。这次我们试图减少每一个字符的出现率。因此，不需要重新排列。</string>
    <string name="Huffman95">为了方便起见，根据字符串的顺序将出现率设置得更低。因此，不需要重新排列。</string>
    <string name="Huffman96">接下来，按照出现比率低的顺序查找两个字母。</string>
    <string name="Huffman97" formatted="false">这种情况下是，\"C\"（22%）和\"D\"（18%)。</string>
    <string name="Huffman98">用一条线连接两个字符来创建一个树结构。</string>
    <string name="Huffman99">将两个字符组合为\"C或D\"并合计出现比率。</string>
    <string name="HuffmanDescription">\"赫夫曼编码\"是JPEG和ZIP等中使用的算法。您可以在购买所有算法后学习这个主题。</string>
    <string name="HybridEncoding">混合加密</string>
    <string name="HybridEncoding0">使用\"公有密钥加密方法\"有如何安全地交换密钥的\"密钥运输问题\"。</string>
    <string name="HybridEncoding1">另一方面，在\"公开密钥加密\"方法中，存在加密和解密期间处理缓慢的问题。</string>
    <string name="HybridEncoding10">通过用公开密钥加密方法加密密钥，它可以安全地发送给B方。</string>
    <string name="HybridEncoding11">B方接收方创建公开密钥和秘密密钥。</string>
    <string name="HybridEncoding12">公开密钥发送给A方。</string>
    <string name="HybridEncoding13">A方使用他们从B方收到的公开密钥…</string>
    <string name="HybridEncoding14">并加密与公有密钥加密一起使用的密钥。</string>
    <string name="HybridEncoding15">加密的密钥发送给B方。</string>
    <string name="HybridEncoding16">B方使用秘密密钥...</string>
    <string name="HybridEncoding17">解密该密钥的密文。</string>
    <string name="HybridEncoding18">这样，A方将公开密钥加密中使用的密钥安全地发送给B方。</string>
    <string name="HybridEncoding19">现在唯一要做的就是使用这个密钥并发送加密的数据。</string>
    <string name="HybridEncoding2">\"混合加密\"是一个将两者结合起来以弥补每个人的缺点的系统。</string>
    <string name="HybridEncoding20">数据的加密使用处理速度快的公有密钥加密方法。</string>
    <string name="HybridEncoding21">B方能够毫无问题地获得原始数据。</string>
    <string name="HybridEncoding22">这样，混合加密将安全性和快速处理都结合起来了。</string>
    <string name="HybridEncoding23">它是一种用于在互联网上安全地交换信息的，用于\"SSL\"的一种生活上不可缺的加密方法。</string>
    <string name="HybridEncoding24">这就结束了对\"混合加密\"的解释。</string>
    <string name="HybridEncoding3">为了加密数据，使用处理速度快的公有密钥加密方法。</string>
    <string name="HybridEncoding4">然而，公有密钥加密使用的密钥是用更安全的公开密钥加密方法来进行交换的。</string>
    <string name="HybridEncoding5">让我们更加具体地看看混合密码方法的实际应用。</string>
    <string name="HybridEncoding6">假设A方想通过互联网向B方发送数据。</string>
    <string name="HybridEncoding7">数据通过使用处理速度更快的共有密钥加密方法来加密。</string>
    <string name="HybridEncoding8">由于加密所需的密钥也用于解密，因此A方需要将密钥发送给B方。</string>
    <string name="HybridEncoding9">密钥也是数据的一种。</string>
    <string name="HybridEncodingDescription">\"混合加密算法\"是结合了公共密钥加密方法和公开密钥加密方法的方法。您可以在购买所有的算法后学习这个主题。</string>
    <string name="IABSetUpFailed">无法连接到Google Play。请确保您已登录Google Play。</string>
    <string name="Inquiry">反馈</string>
    <string name="InquiryConfirmation">确认</string>
    <string name="InquiryEmail">邮箱地址</string>
    <string name="InquiryFailed">发送邮件时发生错误，请稍后再试。</string>
    <string name="InquiryIsSendOK">确定提交意见/反馈吗？</string>
    <string name="InquiryName">姓名</string>
    <string name="InquiryOptional">（任意）</string>
    <string name="InquiryPleaseInput">请在意见/反馈栏中填写您的留言。</string>
    <string name="InquiryPleaseSmall">请输入少于1000个字符的留言。</string>
    <string name="InquirySend">发送</string>
    <string name="InquirySuccess">非常感谢您的意见/反馈。我们将用它作为应用程序改进的参考。</string>
    <string name="InquirySuccessTitle">意见/反馈已提交</string>
    <string name="InsertionSort">插入排序</string>
    <string name="InsertionSort0">\"插入排序\"是数列排序的算法之一。</string>
    <string name="InsertionSort1">首先，左端的数字已完成排序。</string>
    <string name="InsertionSort10">与左边的数字进行比较。</string>
    <string name="InsertionSort11">由于5大于4，所以交换了数字。</string>
    <string name="InsertionSort12">由于3小于4，出现了更小的数字，所以4停止移动。</string>
    <string name="InsertionSort13">4已完成排序。</string>
    <string name="InsertionSort14">重复相同的操作，直到所有的数字完成排序。</string>
    <string name="InsertionSort18">所有的数字都完成排序，所以排序完成。</string>
    <string name="InsertionSort19">这就结束了插入排序的解释。</string>
    <string name="InsertionSort2">然后，取出那些尚未操作的左端的数字...</string>
    <string name="InsertionSort3">将其与已经操作的左侧的数字进行比较。</string>
    <string name="InsertionSort4">如果左边的数字较大，交换两个数字。</string>
    <string name="InsertionSort5">重复此操作，直到出现一个较小的数字或者数字到达左端。</string>
    <string name="InsertionSort6">这种情况下，由于5大于3，所以交换了数字。</string>
    <string name="InsertionSort7">数字到达了左端，停止数字移动。</string>
    <string name="InsertionSort8">3已完成排序。</string>
    <string name="InsertionSort9">和之前同样取出左端的数字...</string>
    <string name="KmeansClustering">K-均值算法</string>
    <string name="KmeansClustering0">K-均值算法是聚类算法的一种。</string>
    <string name="KmeansClustering1">聚类是，当给定一组数据时...</string>
    <string name="KmeansClustering10">随机设置3个点作为群集的中心点。</string>
    <string name="KmeansClustering100">再次计算最近集群的中心点，并将每个数据分类到集群里。</string>
    <string name="KmeansClustering101">在聚类中，每个组被称为一个\"群集\"。</string>
    <string name="KmeansClustering11">根据每个数据计算并确定最接近的集群的中心点。</string>
    <string name="KmeansClustering12">每个数据被分类到确定的集群中。</string>
    <string name="KmeansClustering13">计算每个集群数据的重心，并将集群的中心点移动到那里。</string>
    <string name="KmeansClustering14">随着中心点的移动，距离每个数据最近的中心点将改变。</string>
    <string name="KmeansClustering15">重复\"每个数据分类到集群\"和\"移动到中心点的重心\"，直到中心点收敛。</string>
    <string name="KmeansClustering2">将类似的数据分组。</string>
    <string name="KmeansClustering26">中心点已收敛，操作结束。</string>
    <string name="KmeansClustering27">数学上证明，当重复操作时，中心点将在某个地方收敛。</string>
    <string name="KmeansClustering28">这就完成了聚类。</string>
    <string name="KmeansClustering29">我们可以看到数据点已经与其他相似的点适当分组。</string>
    <string name="KmeansClustering3">相似性根据算法而变化，取决于数据点之间的距离，坐标等。</string>
    <string name="KmeansClustering30">让我们看看用集群数量为2的相同的数据执行K-均值法会发生什么。</string>
    <string name="KmeansClustering31">随机设置中心点...</string>
    <string name="KmeansClustering32">重复\"每个数据分类到集群\"和\"移动到中心点的重心\"，直到中心点收敛。</string>
    <string name="KmeansClustering4">K-均值算法是通过距每个集群中心点的距离来分类数据。</string>
    <string name="KmeansClustering43">中心点已收敛。</string>
    <string name="KmeansClustering44">这一次，位于左侧和底部的两个数据块被分类为一个集群。</string>
    <string name="KmeansClustering45">由于K-均值法必须要事先确定集群的数量，所以当设置的数目不合适时可能得不到显著的结果。</string>
    <string name="KmeansClustering46">有几种方法可以估计适当数量的集群，比如预先分析数据，或者多次改变集群数量来尝试K-means算法。</string>
    <string name="KmeansClustering47">接下来，使用相同的数据，改变集群中心点的位置，然后尝试看看执行K-均值法会发生什么。</string>
    <string name="KmeansClustering48">重复\"每个数据分类到集群\"和\"移动到中心点的重心\"，直到中心点收敛。</string>
    <string name="KmeansClustering5">让我们看看算法的流程。</string>
    <string name="KmeansClustering58">中心点已收敛。</string>
    <string name="KmeansClustering59">与之前不同的是，右上角和右下角的两个数据块被分类为一个集群。</string>
    <string name="KmeansClustering6">首先，准备要进行聚类的数据。</string>
    <string name="KmeansClustering60">我们为可以看到，K-均值法具有聚类结果根据随机设置的第一个中心点的位置而不同的特征。</string>
    <string name="KmeansClustering61">这就结束了K-均值法的解释。</string>
    <string name="KmeansClustering7">然后，确定群集的数量。</string>
    <string name="KmeansClustering8">K-均值算法的特点是要事先决定群集的数量。</string>
    <string name="KmeansClustering9">这次我们将使用3个群集。</string>
    <string name="KmeansClusteringDescription">\"K-平均算法\"是一种简单但广泛使用的数据分析方法。您可以在购买所有算法后学习这个主题。</string>
    <string name="LangColon">显示语言:</string>
    <string name="LetsUnlock">购买后，您可以学习所有的内容。让我们一起掌握算法吧！</string>
    <string name="LinearSearch">线性搜索</string>
    <string name="LinearSearch0">线性搜索是一种从数组中搜索元素的算法。</string>
    <string name="LinearSearch1">我们来探索一下数字6。</string>
    <string name="LinearSearch2">首先，检查数组中最左边的数字。</string>
    <string name="LinearSearch3">与6进行比较，如果匹配，则搜索结束。如果不匹配，则检查右边一个数字。</string>
    <string name="LinearSearch4">重复比较直到找到6。</string>
    <string name="LinearSearch5">我们找到了6，所以搜索结束。</string>
    <string name="LinearSearch6">我们可以看出，线性搜索是从头按顺序重复比较的一种简单的方法。</string>
    <string name="LinearSearch7">当数据量很大时，比较次数会增加，这需要花费时间。</string>
    <string name="LinearSearch8">这就结束了线性搜索的解释。</string>
    <string name="List">列表</string>
    <string name="List0">\"列表\"是一种数据结构，可以存储多个值。</string>
    <string name="List1">它们的特点是如何将数据与\"指标\"配对，以及指示下一条数据的内存位置。</string>
    <string name="List12">这就结束了对\"列表\"的解释。</string>
    <string name="List2">在列表中，数据存储在内存中分散的位置。</string>
    <string name="List4">由于数据存储在不同的位置，每个数据只能通过其前面的指標访问。</string>
    <string name="List9">数据的添加只需通过替换添加任一侧的指针即可执行。</string>
    <string name="ListSearchSection">列表搜索</string>
    <string name="MAC">讯息鉴别码</string>
    <string name="MAC0">\"讯息鉴别码\"是实现\"认证\"和\"伪造检测\"两种功能的系统。</string>
    <string name="MAC1">首先，我们来看看需要讯息鉴别码的情况。</string>
    <string name="MAC10">密文发送给B方......</string>
    <string name="MAC11">B能够解密接收到的密文并获得包含商品编码的消息。</string>
    <string name="MAC12">虽然在这种情况下没有问题，但可能会发生以下情况。</string>
    <string name="MAC13">我们将把场景返回到A方将加密文本发送给B方的地方。</string>
    <string name="MAC14">A方将试图发送密文给B方…</string>
    <string name="MAC15">假设在通信过程中恶意方X伪造密文。</string>
    <string name="MAC16">B方将收到密文，但不能注意到它已被伪造。</string>
    <string name="MAC17">当B方解密被伪造的密文时，该消息是\"xyz\"。</string>
    <string name="MAC18">B方认为\"xyz\"是订购的物品编号，并向A方发送了不正确的物品。</string>
    <string name="MAC19">由于密码仅仅是数值的计算过程，所以即使密文被伪造，也可以计算解密。</string>
    <string name="MAC2">为了A方从B方购买产品，发送一条消息显示产品代码\"abc \"。</string>
    <string name="MAC20">如果原始信息是长句，并且伪造的信息出现了一些无意义的句子，则有可能有人会注意到伪造。</string>
    <string name="MAC21">但是，对于人类没有直接了解的数据（如产品代码），在解密后很难发现这种伪造。</string>
    <string name="MAC22">为了检测伪造，超出加密的额外措施是必要的。</string>
    <string name="MAC23">如果您使用讯息鉴别码，则可以检测伪造。让我们来看看它们的工作原理。</string>
    <string name="MAC24">我们将把场景返回到A方将加密文本发送给B方的地方。</string>
    <string name="MAC25">A方创建了一个用于创建讯息鉴别码的密钥...</string>
    <string name="MAC26">并使用安全的方法将密钥发送给B方。</string>
    <string name="MAC27">接下来，A方使用密文和密钥创建一个值...</string>
    <string name="MAC28">并获得了\"7f05\"的值。</string>
    <string name="MAC29">通过组合密钥和密文创建的这个值称为\"讯息鉴别码\"。</string>
    <string name="MAC3">A方加密消息。</string>
    <string name="MAC30">由于该讯息鉴别码在英文中被称为\"MAC（讯息鉴别码）\"，因此在本说明的下文中写为\"MAC\"。</string>
    <string name="MAC31">MAC可以被想象为类似由密钥和密文组成的字符串的\"哈希值\"。</string>
    <string name="MAC32">\"哈希值\"在这个应用程序的\"哈希函数\"中有更详细的解释。</string>
    <string name="MAC33">有多种创建MAC的方法，例如\"HMAC \"，\"OMAC \"和\"CMAC \"。 现在，\"HMAC\"方法就是常用的方法。</string>
    <string name="MAC34">A方向B方发送他们创建的MAC和密文。</string>
    <string name="MAC35">B方收到密文和MAC。</string>
    <string name="MAC36">现在B方需要检查密文是否被伪造。</string>
    <string name="MAC37">与A方一样，B方也使用密文和密钥来创建MAC。</string>
    <string name="MAC38">B方能够确认他们自己计算的MAC与从A方收到的MAC相匹配。</string>
    <string name="MAC39">因此，B方知道他们收到的密文没有被伪造。</string>
    <string name="MAC4">假设他们使用共有密钥加密进行加密。</string>
    <string name="MAC40">剩下的就是使用密文的密钥并解密消息。</string>
    <string name="MAC41">A订购的产品代码为\"abc\"的消息已成功被取出。</string>
    <string name="MAC42">让我们回到A方将密文发送给B方的场景。</string>
    <string name="MAC43">让我们看看如果恶意方X在传输过程中试图伪造消息会发生什么。</string>
    <string name="MAC44">A方试图发送给B方的密文和MAC...</string>
    <string name="MAC45">第X方伪造了密文。</string>
    <string name="MAC46">但是当B方再次计算MAC时......</string>
    <string name="MAC47">他们意识到它与从A方收到的MAC不匹配。</string>
    <string name="MAC48">由此，B方知道密文，MAC或两者都可能被伪造。</string>
    <string name="MAC49">在这种情况下，最好丢弃密文和MAC并请求A重新发送它们。</string>
    <string name="MAC5">A方使用安全的方法将此密钥传递给B方。</string>
    <string name="MAC50">那么，是否有可能让X伪造MAC，这与伪造的密文一致？</string>
    <string name="MAC51">因为X先生没有计算MAC的密钥......</string>
    <string name="MAC52">即使他们能够伪造它，但仍不可能使其与伪造的密文一致。</string>
    <string name="MAC53">如预期的那样，当B方重新计算MAC并且它不匹配与伪造的密文配对的MAC时，显然在传输过程中发生了某种伪造。</string>
    <string name="MAC55">正如您所看到的，通过使用讯息鉴别码或MAC，我们可以防止在传输过程中的伪造。</string>
    <string name="MAC56">但是，讯息鉴别码也存在缺点。</string>
    <string name="MAC57">让我们简化流程。</string>
    <string name="MAC58">首先，A方和B方共享用于加密的密钥和计算MAC的密钥。</string>
    <string name="MAC59">因此...</string>
    <string name="MAC6">密钥交换方法使用诸如\"公开密钥加密\"或\"迪菲-赫尔曼密钥交换\"的密钥交换协议。</string>
    <string name="MAC60">就像A方可以加密消息并计算MAC一样......</string>
    <string name="MAC63">B方也可以对消息进行加密并计算MAC。</string>
    <string name="MAC66">换句话说，无法验证创建原始消息的是A方还是B方。</string>
    <string name="MAC67">因此，如果A方是恶意的时候...</string>
    <string name="MAC68">在发送信息后，坚持认为这是B先生编造的信息并可以\"事后否认\"他发送的信息。</string>
    <string name="MAC7">\"公开密钥加密\"和\"迪菲-赫尔曼密钥交换\"在本应用程序中有更详细的解释。</string>
    <string name="MAC71">为了防止这种事后否认，有必要使用这个应用程序中解释的\"数字签名\"。</string>
    <string name="MAC72">这就结束了对\"讯息鉴别码\"的解释。</string>
    <string name="MAC8">A方使用共有密钥并加密消息。</string>
    <string name="MarkAllAsRead">使所有内容标为已读</string>
    <string name="MarkAllAsUnread">使所有内容标为未读</string>
    <string name="MathSection">数学</string>
    <string name="MergeSort">归并排序</string>
    <string name="MergeSort0">\"归并排序\"是数列排序的算法之一。</string>
    <string name="MergeSort1">首先，我们将数字分成两半。</string>
    <string name="MergeSort10">当合并包含多个数字的组时，比较开头的数字，移动较小的数字。</string>
    <string name="MergeSort11">在图中，比较开头的4和3。</string>
    <string name="MergeSort12">4大于3，所以移动3。</string>
    <string name="MergeSort13">同样比较其余列的头数...</string>
    <string name="MergeSort14">4小于7，所以移动4。</string>
    <string name="MergeSort15">6小于7，所以移动6。</string>
    <string name="MergeSort16">移动剩下的7。</string>
    <string name="MergeSort17">递归地重复组的合并操作，直到所有数字都在一个组中。</string>
    <string name="MergeSort22">完成合并，数列将排序。</string>
    <string name="MergeSort23">这就结束了\"归并排序\"的解释。</string>
    <string name="MergeSort5">分割完成。</string>
    <string name="MergeSort6">接下来，我们将结合我们分割的每个组。</string>
    <string name="MergeSort7">合并时，按照数字的升序移动，使得合并后的数字在组内按升序排列。</string>
    <string name="MergeSortDescription">\"归并排序\"的特点是将一系列数字分成较小的组然后按顺序排列。您可以在购买所有算法后学习这个主题。</string>
    <string name="NowBuying">正在准备中…</string>
    <string name="OK">确定</string>
    <string name="OthersSection">其它</string>
    <string name="PKC">公开密钥加密</string>
    <string name="PKC0">\"公开密钥加密\"是一种使用不同密钥进行加密和解密的加密方法。</string>
    <string name="PKC1">用于加密的密钥称为\"公开密钥\"，用于解密的密钥称为\"秘密密钥\"。</string>
    <string name="PKC10">密文发送给B方。</string>
    <string name="PKC11">B方使用秘密密钥并解密从A方收到的密文。</string>
    <string name="PKC12">B方现在已经获得了原始数据。</string>
    <string name="PKC13">因为公开密钥和密文是通过互联网发送的......</string>
    <string name="PKC14">他们有可能被恶意的第三方X窃取。</string>
    <string name="PKC15">但是，由于密文不能用公开密钥解密，因此X方无法获得原始数据。</string>
    <string name="PKC16">因此，与共有密钥加密不同，密钥传送问题不会发生在公开密钥加密中。</string>
    <string name="PKC17">公开密钥加密还有一个额外的优点，可以方便地在不特定的多方之间交换信息。 让我们来更具体的看看。</string>
    <string name="PKC18">假设B方预先准备了公开密钥和加密密钥。</string>
    <string name="PKC19">让别人知道公开密钥不会造成问题。</string>
    <string name="PKC2">与共有密钥加密相比，公开密钥加密往往需要更多的时间用于加密和解密。</string>
    <string name="PKC20">因此，B方可以在互联网上发布公开密钥。</string>
    <string name="PKC21">另一方面，秘密密钥不能被别人知道，因此需要严密保护。</string>
    <string name="PKC22">假设有多人想要将数据发送给B方。</string>
    <string name="PKC23">发送数据的人获得由B方公开的公开密钥...</string>
    <string name="PKC24">并加密他们想要发送的数据。</string>
    <string name="PKC25">他们将密文发送给B方。</string>
    <string name="PKC26">B方使用秘密密钥并解密他们的密文。</string>
    <string name="PKC27">B方现已获得原始数据。</string>
    <string name="PKC28">正如你所看到的，没有必要为每个发送数据的人准备一个密钥。</string>
    <string name="PKC29">另外，因为数据的接收者是唯一有密钥需要保密的，所以它具有高度的安全性。</string>
    <string name="PKC3">图中显示了公开密钥加密计算方法的一些示例。</string>
    <string name="PKC30">但是，公开密钥加密存在两个问题。</string>
    <string name="PKC31">第一个问题是加密和解密都需要时间。</string>
    <string name="PKC32">因此，它不适合来回交换少量数据。</string>
    <string name="PKC33">作为这个问题的解决方案，有一个叫\"混合加密\"的方法，在这个应用程序的其他地方会有更详细的解释。</string>
    <string name="PKC34">第二个问题是，公开密钥的可靠性。</string>
    <string name="PKC35">让我们回到B方创建公开密钥和秘密密钥的场景。</string>
    <string name="PKC36">为了方便起见，我们将使用\"PB \"来表示由B方创建的公开密钥，并使用\"SB \"来表示秘密密钥。</string>
    <string name="PKC37">X方试图窃取A方发送给B方的数据，并创建公开密钥PX和秘密密钥SX。</string>
    <string name="PKC38">当B方将公开密钥PB给A方......</string>
    <string name="PKC39">X方用他自己创建的公开密钥PX替换公开密钥PB ...</string>
    <string name="PKC4">今天，RSA加密被广泛使用，并在这个应用程序的其他地方更详细地解释。</string>
    <string name="PKC40">并将公开密钥PX提供给A方。</string>
    <string name="PKC41">公开密钥本身无法指示谁创建了它。</string>
    <string name="PKC42">因此，A方无法分辨他们收到的公开密钥是被秘密交换的。</string>
    <string name="PKC43">A方用公开密钥PX加密数据。</string>
    <string name="PKC44">当A方将密文发送给B方时......</string>
    <string name="PKC45">X方将收到此密文。</string>
    <string name="PKC46">因为这个密文是用X方准备的公开密钥PX加密的......</string>
    <string name="PKC47">X方可以用它们拥有的秘密密钥SX解密它。</string>
    <string name="PKC48">由此，X方看到A方试图发给B方的数据。</string>
    <string name="PKC49">接下来，X方用B方的公开密钥PB加密数据。</string>
    <string name="PKC5">我们来看看更广泛的数据如何使用公开密钥加密方法来进行交换。</string>
    <string name="PKC50">由此产生的密文给B方。</string>
    <string name="PKC51">由于该密文是用B方准备的公开密钥PB创建的，因此B方可以用它们拥有的秘密密钥SB对其解密。</string>
    <string name="PKC52">由于B方能够解密密文，他们甚至都不会梦想数据被其他人窃取。</string>
    <string name="PKC53">这种通过秘密替换公开密钥而被窃取数据的攻击方法被称为\"中间人攻击\"。</string>
    <string name="PKC54">问题根源在于A方无法确认他们收到的公开密钥是否由B方创建。</string>
    <string name="PKC55">为了解决这个问题，使用了\"数字证书\"系统。\"数字证书\"在本应用的其他地方有更详细的解释。</string>
    <string name="PKC56">这就结束了对’公开密钥加密’的解释。</string>
    <string name="PKC6">假设A方想通过互联网向B方发送数据。</string>
    <string name="PKC7">首先，接收方（B方）创建一个公开密钥和一个秘密密钥。</string>
    <string name="PKC8">公开密钥被发送给A方。</string>
    <string name="PKC9">A方使用他们从B方收到的公开密钥并加密数据。</string>
    <string name="PageRank">佩奇排名（网页排名）</string>
    <string name="PageRank0">\"佩奇排名\"是搜索网站时用来确定结果的排名的算法。</string>
    <string name="PageRank1">谷歌在其搜索引擎中使用该算法成为全球性公司的故事颇为有名。</string>
    <string name="PageRank10">未链接的页面的分数为1。</string>
    <string name="PageRank100">如果我们从互联网的空间一侧观看这项活动，就像网页浏览的人......</string>
    <string name="PageRank101">重复移动页面几次后传送到一个完全不同的页面。</string>
    <string name="PageRank11">有链接的页面的得分是正在链接的页面的总得分。</string>
    <string name="PageRank12">但是，当有多个网页的链接时...</string>
    <string name="PageRank13">链接分数均匀分布。</string>
    <string name="PageRank14">在佩奇排名的思维方式中，来自高度链接网页的链接具有很高的价值。</string>
    <string name="PageRank15">该图中心的页面有三个独立页面指向它的链接，所以它的分数是3。</string>
    <string name="PageRank16">首页有一个很大的分数，因为链接是从分数为3的页面指向它的。</string>
    <string name="PageRank17">在该图中的六个页面中，判断最上面的页面是最重要的页面。</string>
    <string name="PageRank18">这是佩奇排名的基本思想。</string>
    <string name="PageRank19">用这种方式，当链接形成一个循环时会出现问题。</string>
    <string name="PageRank2">在传统的搜索网站中，搜索结果的排名主要取决于搜索关键字与页面中的句子之间的相关性。</string>
    <string name="PageRank20">按顺序计算每个页面的分数时...</string>
    <string name="PageRank24">以这种方式，它将无限循环，并且循环中的页面得分在任何地方都会很高。</string>
    <string name="PageRank25">循环的问题通过称为\"随机游走模型\"的计算方法来解决。</string>
    <string name="PageRank26">让我们来思考一下浏览网页的人是如何浏览网页的。</string>
    <string name="PageRank27">比如说，有一次，访问杂志中介绍的有趣的页面。从这个左下角的页面开始...</string>
    <string name="PageRank28">他们跟随一个链接并移动到另一个页面...</string>
    <string name="PageRank29">看了几页后，他们失去了兴趣......</string>
    <string name="PageRank3">此方法不考虑页面是否包含有用的信息。 因此，搜索结果的准确性不高。</string>
    <string name="PageRank30">并暂时停止浏览。</string>
    <string name="PageRank31">然后，在另一天，他们开始在朋友推荐的完全不同的网页上浏览。</string>
    <string name="PageRank32">跟随链接，移动到另一个页面...</string>
    <string name="PageRank33">一旦失去兴趣就停止浏览。</string>
    <string name="PageRank34">这样，重复从某个页面开始浏览，移动几页后便停止的操作。</string>
    <string name="PageRank35">如果我们定义网络浏览者的行动，会得到如下内容。</string>
    <string name="PageRank36">概率1 - α是选择当前页面中的1个链接的概率。</string>
    <string name="PageRank37">概率α是该人将传送到其他页面的概率。</string>
    <string name="PageRank38">作为解释中的例子，假设传送α的概率为15％。</string>
    <string name="PageRank39">根据这个定义模拟页面之间的转换。</string>
    <string name="PageRank4">佩奇排名是一种算法，可根据页面之间的链接结构计算页面的值。 让我们来看看直到进行计算的具体的流程。</string>
    <string name="PageRank40">考虑链接像之前一样成循环状的情况。</string>
    <string name="PageRank41">每个页面的数量是网页浏览者访问该页面的次数。</string>
    <string name="PageRank42">目前，由于我们还没有开始模拟，所有的数字都是0。</string>
    <string name="PageRank43">根据定义运行模拟，每个页面的访问次数会有所不同。</string>
    <string name="PageRank49">让我们加快时间的流速。</string>
    <string name="PageRank5">假设一个正方形表示一个WEB页面，一个箭头表示一个页面之间的链接。</string>
    <string name="PageRank50">我们继续模拟，直到页面访问次数达到1000次。</string>
    <string name="PageRank51">如图所示，以百分比表示结果。</string>
    <string name="PageRank52">可以说这个值表示\"在某个时间点查看页面的概率\"。</string>
    <string name="PageRank53">将这些值用于网页评分是随机游行模型的方法。</string>
    <string name="PageRank54">使用这种方法，即使链接是循环状的，我们也可以得到计算得分。</string>
    <string name="PageRank55">实际上，使用更实用的计算方法而不是模拟。 现在我们将介绍这些。</string>
    <string name="PageRank56">如图所示，让我们尝试计算复杂的链接网络中每个页面的分数。</string>
    <string name="PageRank57">首先，我们设置每个页面的初始分数。</string>
    <string name="PageRank58">均匀设置分数，使总分加起来为1。</string>
    <string name="PageRank59">接下来，网页浏览者移动一次，计算在每个页面上的概率。</string>
    <string name="PageRank6">此图显示下面3页包含指向上面1页的链接。</string>
    <string name="PageRank60">移动n次时出现在A中的概率将表示为PAn。 同样，移动n次时出现在B中的概率表示为PBn。</string>
    <string name="PageRank61">举一个例子，在移动1次之后求在A的概率（PA 1）。</string>
    <string name="PageRank62">移动到A的一种场景是，C中的一个人选择移动而不是传送......</string>
    <string name="PageRank63">另外，选择A而不是B作为目的地。</string>
    <string name="PageRank64">在初始状态期间（当进行0次移动时）某人处于C 0的概率是PC 0（等于0.25）。</string>
    <string name="PageRank65">此外，在C的人选择移动的概率是1-α，从A或B中选择A的概率是0.5。</string>
    <string name="PageRank66">因此，从C移动到A的概率是PC0 x（1-α）x 0.5。</string>
    <string name="PageRank67">A将被选为传送目标的概率是0.25。</string>
    <string name="PageRank68">并选择A作为传送目的地。</string>
    <string name="PageRank69">A到D中任何一个人选择传送的概率是α。</string>
    <string name="PageRank7">在佩奇排名算法中，网页指向的链接越多，页面被确定为越重要。</string>
    <string name="PageRank70">A被选作传送目的地的概率是0.25。</string>
    <string name="PageRank71">因此，通过传送移动到A的概率是α×0.25。</string>
    <string name="PageRank72">由此可知，移动一次后在A的概率为PA1 = PC0×（1-α）×0.5 +α×0.25。</string>
    <string name="PageRank73">代入PC 0 = 0.25和α= 0.15计算，获得PA 1 = 0.14375。</string>
    <string name="PageRank74">同样，计算在B，C，D页上的概率并更新该值。</string>
    <string name="PageRank75">结果如图所示。</string>
    <string name="PageRank76">接下来，用和之前相同的方法计算移动2次后网页浏览者在每个页面上的概率。</string>
    <string name="PageRank77">结果如图所示。</string>
    <string name="PageRank78">重复相同的计算。 然后，在每个页面上的概率趋于固定值。</string>
    <string name="PageRank79">一旦数值固定，计算完成。</string>
    <string name="PageRank8">在这里，确定首页是最重要的。</string>
    <string name="PageRank80">以这种方式计算的值是每个页面的分数。</string>
    <string name="PageRank81">最后，我们将检查这些佩奇排名的值是否与我们首先介绍的加权链接计算的值一致。</string>
    <string name="PageRank82">使用与之前相同的方法，我们将尝试计算图中链接结构的分数。</string>
    <string name="PageRank83">由于这些值是四舍五入的，因此它们不会全部加起来等于1，但是您可以看到该比率接近于先前的结果。</string>
    <string name="PageRank84">我们也计算这个链接结构的分数。</string>
    <string name="PageRank85">这些也与我们之前获得的比率接近。</string>
    <string name="PageRank86">这样，佩奇排名是通过用访问概率代替链接的权重来计算的机制。</string>
    <string name="PageRank87">搜索结果在谷歌上的实际排名不仅仅取决于佩奇排名。</string>
    <string name="PageRank88">然而，从链接结构计算页面的价值的想法，并且即使链接处于循环状也可以完成计算...</string>
    <string name="PageRank89">通过这两点，佩奇排名算法仍然具有时代特征。</string>
    <string name="PageRank9">实际上，每个页面的重要性都是通过计算来量化的。 首先，我们将解释基本的计算方法的思想。</string>
    <string name="PageRank90">这就结束了对\"佩奇排名\"的解释。</string>
    <string name="PageRankDescription">\"佩奇排名\"是用于确定搜索引擎结果的显示顺序的索引。您可以在购买所有算法后学习这个主题。</string>
    <string name="PrimalityTest">素性测试</string>
    <string name="PrimalityTest0">素性测试是确定某个自然数是否是素数的一种方法。</string>
    <string name="PrimalityTest1">素数是除了1和自己以外没有除数的自然数(n>1)。</string>
    <string name="PrimalityTest100">在进入素性测试的解释之前，我们将解释mod操作。</string>
    <string name="PrimalityTest101">mod操作是找到除法的余数的操作。</string>
    <string name="PrimalityTest102">A mod B表示A被B除后的余数C。</string>
    <string name="PrimalityTest103">让我们用具体的数字来展示一下操作实例。</string>
    <string name="PrimalityTest17">也就是说，3599不是素数。</string>
    <string name="PrimalityTest18">但是，这种方法是不现实的，因为随着想要判断是不是素数的数字变大，操作需要花费时间。</string>
    <string name="PrimalityTest19">\"费马素性检验\"是解决这个问题的一种方法。</string>
    <string name="PrimalityTest2">在现代加密技术中，经常使用的\"RSA加密\"可以处理非常大的素数。</string>
    <string name="PrimalityTest20">费马素性检验被称为确定概率素数的一种方法，判断数字是\"素数的可能性的大小\"。</string>
    <string name="PrimalityTest21">作为费马素性检验的前提知识，我们来看看素数的性质。</string>
    <string name="PrimalityTest22">作为例子，我们来想想素数5的性质。</string>
    <string name="PrimalityTest23">将小于素数5的数字的五次方的结果如图所示。</string>
    <string name="PrimalityTest28">接下来，每个数字将进行mod操作，得到除以5后的余数…</string>
    <string name="PrimalityTest29">计算结果如图所示。</string>
    <string name="PrimalityTest3">在这个RSA加密算法中，素性测试起着重要的作用。</string>
    <string name="PrimalityTest30">当我们检查原来的数字和余数时，我们发现它们匹配。</string>
    <string name="PrimalityTest31">我们可以看到，至少对于素数5来说，图中的公式是有效的。</string>
    <string name="PrimalityTest32">这次我们来看看合数6。</string>
    <string name="PrimalityTest33">合数表示不是素数的自然数。数字6可以用2x3表示，所以不是素数。</string>
    <string name="PrimalityTest34">重复相同的计算…</string>
    <string name="PrimalityTest4">例如，我们来确定数字3599是否是一个素数。</string>
    <string name="PrimalityTest41">在5和2的情况下，我们发现原来的数字和余数不匹配。</string>
    <string name="PrimalityTest42">正如猜想，我们证明，图中的公式不仅适用于素数5，而且适用于所有的素数p。</string>
    <string name="PrimalityTest43">这被称为\"费马小定理\"。</string>
    <string name="PrimalityTest44">此外，通过是否满足费马小定理来确定素数的方法被称为\"费马素性检验\"。</string>
    <string name="PrimalityTest45">让我们使用费马测试来确定数字113是否是素数。</string>
    <string name="PrimalityTest46">随机选取三个小于113的数字。</string>
    <string name="PrimalityTest47">将这些数字提高到113次幂后，得到除以113的余数。</string>
    <string name="PrimalityTest48">在任何数字中，原始数字都与其余数相匹配。</string>
    <string name="PrimalityTest49">匹配得到确认的次数越多，素数的可能性就越高。</string>
    <string name="PrimalityTest5">作为一种简单的方法，可以将3599除以大于2的数，并检查它是否可以整除。</string>
    <string name="PrimalityTest50">然而，检测小于p的所有数字是非常耗时的。</string>
    <string name="PrimalityTest51">实际上，检查几个数字的结果，如果我们可以判断素数的可能性是足够高的话，数字可以被确定为素数。</string>
    <string name="PrimalityTest52">例如，改进的费马素性检验，米勒-拉宾素性检验使用于确定RSA加密算法中的素数。</string>
    <string name="PrimalityTest53">重复该实验，在不是素数的概率比0.5的80次幂小的情况下，判断为素数。</string>
    <string name="PrimalityTest54">另外，即使满足所有费马素性检验，也不能确认它是素数。</string>
    <string name="PrimalityTest55">如果要检查的数字是素数，则满足所有费马素性检验。</string>
    <string name="PrimalityTest56">另一方面，如果要检查的数字是一个合数，那么大部分的数字会在费马素性检验中被卡住…</string>
    <string name="PrimalityTest57">与素数一样，虽然非常罕见，但也存在可以满足所有费马索性检验的合数。</string>
    <string name="PrimalityTest58">例如，我们来考虑一下数字561。</string>
    <string name="PrimalityTest59">数字561是可以用3x187，11x51来表示的合数，并不是素数。</string>
    <string name="PrimalityTest6">\"可以整除\"意味着求余数的mod操作的结果是0。</string>
    <string name="PrimalityTest60">但是它满足费马素性检验。</string>
    <string name="PrimalityTest63">这样的合数被称为\"卡迈克尔数\"，或者\"绝对费马伪素数\"。</string>
    <string name="PrimalityTest64">如图所示将卡迈克尔数按照递增的顺序排列，但是我们可以看到数字很少。</string>
    <string name="PrimalityTest65">我们说素数满足所有的费马素性检验是正确的，但即使满足所有的费马索性检验，我们不能说这个数是素数。</string>
    <string name="PrimalityTest66">最多费马素性检验是一个概率素数确定方法。</string>
    <string name="PrimalityTest67">但是，在大多数情况下使用它，因为没有其它有效的确定方法。</string>
    <string name="PrimalityTest68">这就结束了对\"素性测试\"的解释。</string>
    <string name="PrimalityTest7">由于3599的平方根是59.99…所以应该按照2到59的数字顺序进行mod操作。</string>
    <string name="PrimalityTest8">实际执行了mod操作的结果，发现3599可以被59整除。</string>
    <string name="PrimalityTestDescription">\"素性测试\"解释了作为概率素数确定方法之一的费马素性检验。您可以在购买所有算法后学习这个主题。</string>
    <string name="Queue">队列</string>
    <string name="Queue0">\"队列\"是一种数据结构。</string>
    <string name="Queue1">队列也被称为\"等待线\"，正如名字所暗示的，它们很容易被想象成一群排队等候的人。</string>
    <string name="Queue10">这就结束了对\"队列\"的解释。</string>
    <string name="Queue2">排队时，排队越早，优先级越高。</string>
    <string name="Queue3">将数据添加到队列时，数据放在最后。</string>
    <string name="Queue5">将数据添加到队列中的操作称为\"入队\"。</string>
    <string name="Queue6">从队列中取出数据时，将从最早添加的数据开始取出。</string>
    <string name="Queue8">从队列中取出数据的操作称为\"出队\"。</string>
    <string name="Queue9">首先取出最初添加的数据的方法称为\"先入先出\" (First In First Out)，或简称为\"FIFO\"。</string>
    <string name="QuickSort">快速排序</string>
    <string name="QuickSort0">\"快速排序\"是数列排序的算法之一。</string>
    <string name="QuickSort1">与其他的算法相比，它的特点是数字的比较和交换次数少，在许多情况下可以高速地进行排序。</string>
    <string name="QuickSort100">让我们看看实际的算法流程。</string>
    <string name="QuickSort101">为了清楚起见，我们将在pivot上做一个标记。</string>
    <string name="QuickSort102">接下来，在最左边的数字上标记左标记，最右边的在数字上标记右标记。</string>
    <string name="QuickSort103">快速排序是一种使用这些标记递归地重复一系列操作的算法。</string>
    <string name="QuickSort105">因此，左标记的作用是找到一个大于pivot的数字，右标记的作用是找到一个小于pivot的数字。</string>
    <string name="QuickSort106">通过交换数字，可以在数列的左侧收集小于pivot的数字，右侧收集大于pivot的数字。</string>
    <string name="QuickSort107">这就完成了第一次操作。</string>
    <string name="QuickSort11">由于4＜6，标记停止移动。</string>
    <string name="QuickSort12">当左右侧的标记停止时，更改标记的数字。</string>
    <string name="QuickSort13">交换之后，再次将左标记向右移动。</string>
    <string name="QuickSort14">和之前一样，当左边的标记移动到大于或者等于pivot的数字时停止移动。</string>
    <string name="QuickSort18">由于9＞＝6，标记停止移动。</string>
    <string name="QuickSort19">继续将右标记向左移动。</string>
    <string name="QuickSort2">第一个操作的对象是数列中所有的数字。</string>
    <string name="QuickSort21">当右标记碰撞到左标记时也会停止移动。</string>
    <string name="QuickSort22">如果左右侧的标记停止，并在同一个位置时，将这个数字和pivot的数字交换。</string>
    <string name="QuickSort23">将有左右侧标记的数字认为已排序完成。</string>
    <string name="QuickSort24">通过一系列操作...</string>
    <string name="QuickSort25">我们可以把比pivot更小的数字放在pivot左边，</string>
    <string name="QuickSort26">大于pivot的数字放在pivot的右边。</string>
    <string name="QuickSort27">我们将递归地对分成2部分的数列执行一系列操作。</string>
    <string name="QuickSort28">接下来，我们将操作左侧部分的数列。</string>
    <string name="QuickSort29">我们将建立3个标记。</string>
    <string name="QuickSort3">选择一个数字作为排序的基准。这个数字被称为pivot。</string>
    <string name="QuickSort30">和之前一样进行同样的操作。</string>
    <string name="QuickSort4">我们将左边的标记向右移动。</string>
    <string name="QuickSort40">一系列的操作结束...</string>
    <string name="QuickSort41">我们可以将把序列分成在pivot左边的小于pivot的数字...</string>
    <string name="QuickSort42">和在pivot右边的大于pivot的数字。</string>
    <string name="QuickSort43">另一轮操作重复进行。</string>
    <string name="QuickSort44">对左侧部分的数列进行操作。</string>
    <string name="QuickSort45">如果操作的数列只有一个数字，则认为已完成排序。</string>
    <string name="QuickSort47">第二轮将对右侧部分的数列进行操作。</string>
    <string name="QuickSort48">我们将建立3个标记。</string>
    <string name="QuickSort49">将做左标记向右移动。</string>
    <string name="QuickSort50">当左标记和右标记碰撞时不会停止移动。它在这方面与右标记不同。</string>
    <string name="QuickSort51">当左标记达到数列的最右边时停止移动。</string>
    <string name="QuickSort52">这意味着pivot数字在所操作的数列中是最大的数字。</string>
    <string name="QuickSort53">接下来，移动右标记，但如果它被左标记已标记时，完成操作并不需要移动。</string>
    <string name="QuickSort54">如果左标记已达到数列的最右边时，pivot数字被认为已排序完成，并完成这一轮操作。</string>
    <string name="QuickSort55">此后，重复相同操作，直到所有的数字完成排序。</string>
    <string name="QuickSort6">当左标记达到超过pivot的数字时，停止移动。</string>
    <string name="QuickSort7">这一次，因为8＞＝6而停止了移动。</string>
    <string name="QuickSort8">继续将右标记向左移动。</string>
    <string name="QuickSort83">所有的数字已完成排序。</string>
    <string name="QuickSort84">这就结束了快速排序的解释。</string>
    <string name="QuickSort9">当右标记达到小于pivot的数字时，停止移动。</string>
    <string name="QuickSort99">pivot通常随机选择一个数字。为了方便起见，我们选择最右边的数字作为pivot。</string>
    <string name="QuickSortDescription">\"快速排序\"的特点是数据比较和交换的次数较少。您可以在购买所有算法后学习这个主题。</string>
    <string name="Random">随机</string>
    <string name="RateThisApp">评价/审查这个程序</string>
    <string name="RecursionSection">递归</string>
    <string name="Restore">恢复购买记录</string>
    <string name="RestoreAlert">购买记录已被确认，并将被恢复。您不会收取任何费用。</string>
    <string name="RestoreBuyingLog">恢复购买记录</string>
    <string name="RestoreSuccessed">购买记录恢复完成</string>
    <string name="Reversed">颠倒</string>
    <string name="ReviewConfirmation">打开应用商店</string>
    <string name="ReviewConfirmationAndroid">打开Google Play。</string>
    <string name="RunLength">游程编码</string>
    <string name="RunLength0">让我们编码一个在5x5方块上使用三种颜色绘制的图像。</string>
    <string name="RunLength1">首先，我们用简单的方法。</string>
    <string name="RunLength10">这些操作相对于压缩被称为解压。</string>
    <string name="RunLength11">游程编码有适合它的数据和不适合它的数据。</string>
    <string name="RunLength12">如果我们仔细观察代码，总的来说，字符数已经减少了…</string>
    <string name="RunLength13">但不具有相同颜色的部分，在运行游程编码后，字符数会增加…</string>
    <string name="RunLength14">例如，如图所示，如果对连续性较差的数据执行游程编码…</string>
    <string name="RunLength15">数据翻倍到50个字符。</string>
    <string name="RunLength16">相反，如图所示，对具有数据连续性的数据进行游程编码时…</string>
    <string name="RunLength17">编码的字符数据是10个字符。相比原来的25，已经压缩了相当数量。</string>
    <string name="RunLength18">这样，根据要编码的数据，游程编码可能具有压缩效果，也可能不具有压缩效果。</string>
    <string name="RunLength19">因此，有必要采取多种策略，比如只对有一定数量连续的数据使用游程编码。</string>
    <string name="RunLength2">我们分别给字母分配黄色，绿色和蓝色。</string>
    <string name="RunLength20">作为一个例子，我们来考虑一下在单色传单上使用游程编码。</string>
    <string name="RunLength21">当发送图中的图像时，如果我们简单地用W（White）和B（Black）字母表示每个方块，则将是25个字符。</string>
    <string name="RunLength22">为了减少流量，我们用游程编码来压缩数据。</string>
    <string name="RunLength23">编码的结果，它增加了1个字符，变成了26个字符。在这种情况下，使用游程编码是没有意义的。</string>
    <string name="RunLength24">但是，在黑白图像中仅使用黑和白的2种颜色。</string>
    <string name="RunLength25">因此，在连续的白色方块之后将出现黑色方块。</string>
    <string name="RunLength26">即使没有字母W和B，我们也可以从代码中恢复图像。</string>
    <string name="RunLength27">省略了字母W和B。结果，变成了13个数字，压缩成了一半的大小。</string>
    <string name="RunLength28">但是，有必要制定一个规则，代码的第一个数字是白色方块的连续数。</string>
    <string name="RunLength29">用这样的规则，我们可以正确地从代码中恢复图像。</string>
    <string name="RunLength3">从图的左上角开始，将每一行转换为Y，G，B字符，我们就可以把这个图形编码成25个字母。</string>
    <string name="RunLength30">那么，编程下面的图像时应该怎们做？</string>
    <string name="RunLength31">与前一个不同，图像中的第一个方块不是白色的，而是黑色的。</string>
    <string name="RunLength32">暂时，我们尝试用相同的操作对图形进行编码。</string>
    <string name="RunLength33">代码的第一个数字6表示黑色方块的连续数…</string>
    <string name="RunLength34">没有遵循规则\"代码的第一个数字是白色方块\"。</string>
    <string name="RunLength35">如果我们从当前的代码恢复图像，将得到黑白颠倒的图像。</string>
    <string name="RunLength36">我们在代码的开头添加了0，是为了遵循\"代码中的第一个数字是白色方块的数量\"这一规则。</string>
    <string name="RunLength37">这告诉我们在图像的开始有0个白色方块，换句话说，没有白色方块。</string>
    <string name="RunLength38">将0加到起始处，将字符数增加一个字符，但能够按照相同的规则压缩数据。</string>
    <string name="RunLength39">一般来说，游程编码比数据连续性差的文本数据更适合压缩图像数据。</string>
    <string name="RunLength4">接下来，我们通过用游程编码来表示这个图像，以便用25个字符以下的字符表示。</string>
    <string name="RunLength40">无论哪种情况，都需要设计出能够始终显示更高的压缩效果。</string>
    <string name="RunLength41">这就结束了对\"游程编码\"的解释。</string>
    <string name="RunLength5">游程编码是一种将代码和重复的次数作为一组来编码的方法。</string>
    <string name="RunLength6">例如，通过将第一个\"YYYY\"的部分表示为\"Y4\"，可以将其缩短两个字符。</string>
    <string name="RunLength7">重复相同操作，完成游程编码。</string>
    <string name="RunLength8">结果，代码缩短了5个字符，并被压缩为20个字符。</string>
    <string name="RunLength9">如果知道每行有5个方块，原始图像可以从代码中提取出来。</string>
    <string name="SecurityBase">加密基础知识</string>
    <string name="SecurityBase0">现代互联网社会中，我们为什么需要加密技术？</string>
    <string name="SecurityBase1">假设A先生正在通过互联网向B先生发送数据。</string>
    <string name="SecurityBase10">如果您加密数据，即使它被有恶意的第三者看到也是安全的。</string>
    <string name="SecurityBase11">因此，加密技术在当今的互联网社会中非常重要。</string>
    <string name="SecurityBase12">接下来，我们来看看使用加密的具体操作。</string>
    <string name="SecurityBase13">首先，计算机使用数字0和1来管理任何二进制数据。</string>
    <string name="SecurityBase14">数据有各种格式，如文字，音乐，电影等…</string>
    <string name="SecurityBase15">所有数据在计算机中都以二进制数字形式进行管理。</string>
    <string name="SecurityBase150">在这个解释中，我们解释了加密技术的必要性，数据由数字管理，并且加密是数值计算。</string>
    <string name="SecurityBase16">基于此，我们将考虑加密技术。</string>
    <string name="SecurityBase17">数据是对计算机有意义的数字序列。</string>
    <string name="SecurityBase18">密文也作为数字的序列进行管理，但它是一个无法由计算机解释的随机数。</string>
    <string name="SecurityBase19">加密以为着通过对数据执行某些操作来更改为计算机无法解释的数字。</string>
    <string name="SecurityBase2">数据将通过互联网上的各种网络和设备传送给B先生。</string>
    <string name="SecurityBase20">在加密的数值计算中，使用\"钥匙\"。</string>
    <string name="SecurityBase21">钥匙也是由数值组成。</string>
    <string name="SecurityBase22">换句话说，加密就是使用钥匙来做数值计算，将把数据转换为不能读取的东西。</string>
    <string name="SecurityBase23">相反，解密是通过使用密钥的数值计算来将密文还原为原始数据。</string>
    <string name="SecurityBase24">例如，当数据和钥匙作为图像中的值并且计算方法为\"XOR\"时，我们来看看具体流程。</string>
    <string name="SecurityBase25">XOR（逻辑异或）是可以用图的真值表计算的操作。</string>
    <string name="SecurityBase26">作为逻辑异或的特征，图中的式子成立。</string>
    <string name="SecurityBase27">换句话说，如果通过XOR计算特定值A和特定值B的结果是C的时候，</string>
    <string name="SecurityBase28">对于C用XOR再次计算A或B意味着可以取出另一个值。</string>
    <string name="SecurityBase29">对数据用钥匙计算XOR时…</string>
    <string name="SecurityBase3">因此，试图按原样发送数据…</string>
    <string name="SecurityBase30">我们得到了这样的密文。</string>
    <string name="SecurityBase31">这次我们来解密密文。</string>
    <string name="SecurityBase32">对于密文，再次使用钥匙计算XOR时…</string>
    <string name="SecurityBase33">我们获得了原始数据。</string>
    <string name="SecurityBase34">您可以看到，使用XOR计算方法的密码中，相同的密钥用于加密和解密。</string>
    <string name="SecurityBase35">这就结束了\"加密基础知识\"的解释。</string>
    <string name="SecurityBase4">数据可能会被有恶意的第三者看到。</string>
    <string name="SecurityBase5">因此，您需要加密并发送要保密的数据。</string>
    <string name="SecurityBase6">加密数据被称为\"密文\"。</string>
    <string name="SecurityBase7">把密文发送给B先生。</string>
    <string name="SecurityBase8">B将取消从A先生收到的密文并获取原始数据。</string>
    <string name="SecurityBase9">将密文返回原始数据称为\"解密\"。</string>
    <string name="SecurityBasic">安全基础知识</string>
    <string name="SecurityBasic0">当通过互联网交换数据时，数据通过各种网络和设备到达另一方。</string>
    <string name="SecurityBasic1">因此，为了安全使用互联网，安全技术是不可缺的。</string>
    <string name="SecurityBasic10">这个问题被称为\"欺骗\"。</string>
    <string name="SecurityBasic11">作为第三个问题，即使已经确定将A方的信息传送给B方…</string>
    <string name="SecurityBasic12">在传送的途中，信息有可能被X方重写。</string>
    <string name="SecurityBasic13">这个问题被称为伪造。</string>
    <string name="SecurityBasic14">除了第三方故意伪造以外，接受的数据可能由于某种通信故障而被损坏。</string>
    <string name="SecurityBasic15">作为第四个问题，即使B方相信他们收到了A方的信息…</string>
    <string name="SecurityBasic16">当信息的发送人A方有恶意的情况…</string>
    <string name="SecurityBasic17">之后，A方可能会坚持说\"这不是他发出的信息\"。</string>
    <string name="SecurityBasic18">如果发生这种情况，互联网上的商业交易和合同将不会成立。</string>
    <string name="SecurityBasic19">这个问题被称为\"否认\"。</string>
    <string name="SecurityBasic2">首先，我们来看看在互联网上交换数据时可能出现的四个代表性问题。</string>
    <string name="SecurityBasic20">我们介绍了四个代表性的问题。</string>
    <string name="SecurityBasic21">请注意，上述问题不仅发生在人与人之间的交易，同时在浏览网站时也会发生。</string>
    <string name="SecurityBasic22">接下来，为了解决这些问题，我们来简单看看有哪些安全技术以及如何处理它。</string>
    <string name="SecurityBasic23">为了防止第一个问题\"窃听\"，我们使用\"加密\"技术。</string>
    <string name="SecurityBasic24">为了防止第一个问题\"欺骗\"，我们使用\"消息认证码\"或者…</string>
    <string name="SecurityBasic25">\"数字签名\"技术。</string>
    <string name="SecurityBasic26">为了防止第三个问题\"伪造\"，同样我们使用\"消息认证码\"或者…</string>
    <string name="SecurityBasic27">\"数字签名\"技术。</string>
    <string name="SecurityBasic28">\"数字签名\"的技术也可以应用于防止第四个问题\"否认\"。</string>
    <string name="SecurityBasic29">如图所示，把他们总结在一个表中。</string>
    <string name="SecurityBasic3">第一，当A方即将向B方发送信息时…</string>
    <string name="SecurityBasic30">还有一种称为\"数字证书\"的技术，以解决\"数字签名\"技术中存在的\"公钥持有人无法识别\"这一问题。</string>
    <string name="SecurityBasic31">这个应用程序详细解释了每种安全技术。</string>
    <string name="SecurityBasic32">这就结束了对\"安全基础知识\"的解释。</string>
    <string name="SecurityBasic4">在传输途中邮件内容有可能会被X方窃听。</string>
    <string name="SecurityBasic5">这个问题被称为\"窃听\"。</string>
    <string name="SecurityBasic6">作为第二个问题，即使A方意图将信息发送给B方…</string>
    <string name="SecurityBasic7">X方有可能欺骗了B方。</string>
    <string name="SecurityBasic8">相反，即使B方相信他们收到了A方的信息…</string>
    <string name="SecurityBasic9">X方有可能欺骗了A方。</string>
    <string name="SecuritySection">安全</string>
    <string name="SelectionSort">选择性排序</string>
    <string name="SelectionSort0">\"选择性排序\"是数列排序的算法之一。</string>
    <string name="SelectionSort1">线性搜索数列并找到最小值。\"线性搜索\"在本应用程序中详细描述。</string>
    <string name="SelectionSort2">将最小值替换为列中左端的数字并进行排序。</string>
    <string name="SelectionSort3">如果最小值已经在左端，则不执行任何操作。</string>
    <string name="SelectionSort4">重复相同操作，直到所有数字都被排序。</string>
    <string name="SelectionSort6">排序完成。</string>
    <string name="SelectionSort7">这就结束了对选择性排序的解释。</string>
    <string name="Setting">设置</string>
    <string name="SettingNotShowUnreadButtons">未读标记</string>
    <string name="Share">共享和评估应用程序</string>
    <string name="ShareOnFacebook">在Facebook上分享</string>
    <string name="ShareOnTwitter">在Twitter上分享</string>
    <string name="Shuffle">洗牌</string>
    <string name="SortSection">分类</string>
    <string name="Stack">栈</string>
    <string name="Stack0">\"栈\"是一种数据结构。</string>
    <string name="Stack1">栈的结构可以很容易地想象为一堆垂直堆叠的物品。</string>
    <string name="Stack10">这就结束了对\"栈\"的解释。</string>
    <string name="Stack2">从堆积的山上取出物品时，我们会从顶部依次取出物品。</string>
    <string name="Stack3">将数据添加到堆栈时，数据将添加到最后。</string>
    <string name="Stack5">将数据添加到堆栈的操作称为\"推入\"。</string>
    <string name="Stack6">从栈中取出数据时，会从最近添加的数据开始取出。</string>
    <string name="Stack8">从栈中取出数据的操作称为\"弹出\"。</string>
    <string name="Stack9">这种首先取出最近添加的数据的方法称为\"后进先出\"(Last In First Out)，或简称为\"LIFO\"。</string>
    <string name="ThankYouForUnlocking">非常感谢购买\"算法动画图解\"所有的算法，请您继续使用。</string>
    <string name="ToSendUs">向我们发送请求或错误报告时，请使用\"反馈\"。</string>
    <string name="Unlock">购买所有的算法</string>
    <string name="UnlockSuccessed">购买算法完成</string>
    <string name="WEB">网络</string>
    <string name="YouCanLearnAfter">购买所有的算法后可以学习\"%@\"。</string>
    <string name="YouCanLearnAfterAndroid">\"%s\"在购买所有的算法后可学习。</string>
    <string name="YouCanRestore">如果您已经购买所有算法，则可以通过恢复购买记录再次浏览所有内容。</string>
    <string name="app_name">算法动画图解</string>
    <string name="en">英文</string>
    <string name="es">西班牙文</string>
    <string name="ja">日文</string>
    <string name="ko">韩文</string>
    <string name="pt">葡萄牙文</string>
    <string name="ru">俄文</string>
    <string name="search">搜索</string>
    <string name="zh">中文 (简体)</string>
</resources>
