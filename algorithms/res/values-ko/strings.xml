<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="AStarSearch">A*</string>
    <string name="AStarSearch0">A*(에이 스타라고 읽습니다)는 다익스트라 기법을 발전시킨 것입니다. 이 미로의 최단 경로를 먼저 다익스트라 기법으로 찾아보겠습니다.</string>
    <string name="AStarSearch1">미로는 각 정점 사이의 가중치가 1인 그래프라고 해석할 수 있습니다.</string>
    <string name="AStarSearch10">여기서 설정한 추정 가중치는 해당 지점의 고도를 나타낸다고 생각하면 이해하기 쉽습니다.</string>
    <string name="AStarSearch100">사람이 미리 설정하는 추정 가중치를 ‘발견적 가중치(heuristic weight)’라고 합니다.</string>
    <string name="AStarSearch101">각 지점에 대해 시작점으로부터 실제로 걸린 시간을 가중치로 설정하고 목표까지의 추정 가중치를 더해서 시작점부터 목표까지의 추정 가중치를 계산할 수 있습니다.</string>
    <string name="AStarSearch11">오른쪽 아래에 있는 목표 지점이 가장 낮고 왼쪽 위에 있는 가중치 8인 지점이 가장 높은 곳이 됩니다. 언덕을 올라가는 것보다 내려가는 것이 쉽습니다.</string>
    <string name="AStarSearch12">미로를 탐색할 때에 언덕을 내려가도록 하는 것이 쉽습니다. 즉, 가중치가 낮은 쪽으로 이동하게 하면 쉽게 목표에 도달할 수 있습니다.</string>
    <string name="AStarSearch13">이번에는 A*를 사용해보겠습니다.</string>
    <string name="AStarSearch14">먼저 시작 지점을 탐색 완료했다고 표시합니다.</string>
    <string name="AStarSearch15">시작점으로부터 갈 수 있는 칸의 가중치를 각각 계산합니다.</string>
    <string name="AStarSearch16">가중치는 ‘거기에 도달할 때까지의 가중치’와 ‘발견적 가중치’의 합계로 계산합니다.</string>
    <string name="AStarSearch17">가중치가 가장 낮은 칸을 하나 선택합니다.</string>
    <string name="AStarSearch18">선택한 칸을 탐색 완료 상태로 표시합니다.</string>
    <string name="AStarSearch19">탐색을 완료한 칸에서 갈 수 있는 칸의 가중치를 계산합니다.</string>
    <string name="AStarSearch2">이 것을 전제로 다익스트라 기법으로 최단 경로를 찾아봅시다.</string>
    <string name="AStarSearch20">가중치가 가장 낮은 칸을 하나 선택합니다.</string>
    <string name="AStarSearch21">선택한 점을 탐색 완료로 상태로 표시합니다.</string>
    <string name="AStarSearch22">이후로는 같은 작업을 목표에 도착할 때까지 반복합니다.</string>
    <string name="AStarSearch24">다익스트라 기법 보다 효율적으로 미로를 탐색할 수 있었습니다.</string>
    <string name="AStarSearch25">더 효율적으로 미로를 탐색하려면 어떻게 하면 될까요?</string>
    <string name="AStarSearch26">발견적 가중치를, 직선 거리가 아닌 실제로 소요되는 최단 가중추라고 해보겠습니다.</string>
    <string name="AStarSearch28">이번에는 다른 길로 빠지지 않고 최단 경로를 따라 목표에 도착했습니다.</string>
    <string name="AStarSearch29">현실적으로는 실제로 소요되는 최단 가중치를 알고 있는 경우는 없습니다. 그것을 알고 있다면 탐색할 필요가 없기 때문입니다.</string>
    <string name="AStarSearch30">이처럼 A*에선 발견적 가중치를 어떻게 설정하는지가 중요한 요소가 됩니다.</string>
    <string name="AStarSearch31">발견적 가중치가 실제로 소요되는 최단 가중치에 가까울 수록 더 효율적으로 미로를 탐색할 수 있습니다.</string>
    <string name="AStarSearch32">반대로 발견적 가중치의 조정에 실패한 경우에는 어떻게 되는지 보도록 하겠습니다.</string>
    <string name="AStarSearch33">여기선 극단적인 예로 발견적 가중치를 최단 경로만 제외하고 모두 0으로 설정해보겠습니다.</string>
    <string name="AStarSearch35">다익스트라 기법보다 효율이 나쁜 결과를 보여줍니다. 하지만 최단 경로는 제대로 찾았습니다.</string>
    <string name="AStarSearch36">"A*에선 발견적 가중치를 '현 시점부터 목표까지의 최단 가중치' 이하로 설정하는 경우에는 효율의 차이는 있지만 제대로 된 최단 경로를 찾는다는 것이 보장됩니다."</string>
    <string name="AStarSearch37">나쁜 예로 발견적 가중치를 현 시점부터 목표까지의 최단 가중치보다 크게 설정해보겠습니다.</string>
    <string name="AStarSearch38">여기선 최단 경로에만 설정했던 발견적 가중치를 2배 값으로 설정했습니다. 이를 통해 현 시점부터 목표까지의 최단 가중치를 크게 상회하게 됩니다.</string>
    <string name="AStarSearch4">최단 경로를 찾았지만 미로상의 대부분의 길을 지나고 있습니다.</string>
    <string name="AStarSearch40">알고리즘은 탐색이 완료됐다고 판단하지만 찾은 경로는 최단 경로와 다릅니다.</string>
    <string name="AStarSearch41">이처럼 A*가 똑똑한 탐색 알고리즘이 되는지 여부는 설정 방법에 달려있습니다.</string>
    <string name="AStarSearch42">게임 프로그래밍에서 플레이어를 쫓는 적의 움직임을 계산할 때 등에 자주 사용됩니다.</string>
    <string name="AStarSearch43">하지만 계산량이 많아져서 게임 전체의 진행 속도에 악영향을 끼칠 수도 있습니다. 다른 알고리즘과 조합해서 제한적인 상황에 사용하는 등 사용 시에는 고민이 필요합니다.</string>
    <string name="AStarSearch44">이것으로 A*에 대한 설명을 마칩니다.</string>
    <string name="AStarSearch5">다익스트라 기법에선 시작점부터의 가중치를 고려해서 다음으로 갈 정점을 결정합니다.</string>
    <string name="AStarSearch6">이 때문에 화살표가 가리키고 있는 경로도 목표로부터 멀어진다는 것을 고려하지 않고 탐색할 수가 있습니다.</string>
    <string name="AStarSearch7">A*에선 시작점부터의 가중치뿐만 아니라 현 시점에서 목표까지의 추정 가중치도 함께 고려해서 탐색합니다.</string>
    <string name="AStarSearch8">이 추정치는 자유롭게 설정할 수 있으며 여기선 왼쪽 아래에 있는 목표로부터의 직선 경로를 반올림한 값을 이용하도록 합니다.</string>
    <string name="AStarSearch9">이처럼 다익스트라 기법은 각 정점으로 향하는 최단 경로를 하나씩 결정해가며 그래프를 탐색하는 알고리즘입니다.</string>
    <string name="AStarSearchDescription">A*는 다익스트라 기법을 발전시킨 알고리즘입니다. 이 항목은 모든 알고리즘을 구매 후에 학습할 수 있습니다.</string>
    <string name="AboutDev">알고리즘 도감에 대해</string>
    <string name="AlgorithmText1">RSA 암호</string>
    <string name="AlgorithmText2">타원곡선 암호</string>
    <string name="AlreadyBought">구매 완료</string>
    <string name="AlreadyBoughtRestore">"앱을 재설치한 경우나 다른 단말기에 설치한 적이 있다면 '구매 기록 복원' 메뉴를 사용해주세요."</string>
    <string name="AlreadyBoughtRestoreAndroid">"앱을 재설치한 경우나 다른 단말기에 설치한 적이 있다면 '구매 기록 복원' 메뉴를 사용해주세요."</string>
    <string name="AppTitle">알고리즘 도감</string>
    <string name="Array">배열</string>
    <string name="Array0">배열(Array)은 데이터 구조의 하나로 여러 개의 값을 저장하기 위한 구조입니다.</string>
    <string name="Array1">각 요소에는 첨자(데이터가 몇 번째 칸에 있는지 나타내는 숫자)를 사용해 접근할 수 있습니다.</string>
    <string name="Array10">먼저, 배열의 마지막에 추가를 위한 공간을 확보합니다.</string>
    <string name="Array11">공간이 비므로 하나씩 데이터를 옆으로 이동합니다.</string>
    <string name="Array13">빈 공간에 ‘Green’을 추가해서 작업을 완료합니다.</string>
    <string name="Array14">,반대로 두 번째 요소를 삭제할 때는…</string>
    <string name="Array15">,먼저 요소를 삭제하고</string>
    <string name="Array16">빈 공간을 하나식 왼쪽으로 옮겨서 매꿉니다.</string>
    <string name="Array18">마지막으로 남은 공간을 삭제합니다.</string>
    <string name="Array19">이것으로 삭제 작업이 완료됐습니다.</string>
    <string name="Array2">데이터는 연속된 메모리 영역에 순서대로 저장됩니다.</string>
    <string name="Array3">연속된 영역에 저장돼 있어서 첨자를 사용해서 메모리의 주소를 계산할 수 있습니다. 따라서 각 데이터에 바로 접근할 수 있습니다.</string>
    <string name="Array8">배열은 임의의 위치에 데이터를 추가, 삭제해야 하는 경우에 리스트에 비해 많은 시간이 걸리는 단점이 있습니다.</string>
    <string name="Array9">예를 들어 ‘Green’을 두 번째 요소에 추가하는 경우를 생각해봅시다.</string>
    <string name="BellmanFord">벨만-포드법</string>
    <string name="BellmanFord0">벨만-포드(Bellman-Ford)법은 그래프의 최단 경로 문제를 해결하기 위한 알고리즘입니다.</string>
    <string name="BellmanFord1">각 정점의 초기 가중치를 설정합니다. 시작점은 0, 그 외의 정점은 무한대로 설정합니다.</string>
    <string name="BellmanFord10">계속해서 반대 방향인 정점B에서 정점A로 향하는 경우를 계산해보겠습니다.</string>
    <string name="BellmanFord11">정점B의 가중치가 9이므로 정점B에서 정점A로 가는 가중치는 9+9=18이 됩니다.</string>
    <string name="BellmanFord12">정점A의 현재 값0과 비교하면 현재 값이 작음으로 가중치를 변경하지 않습니다.</string>
    <string name="BellmanFord13">가중치가 큰 정점에서 작은 정점으로 향하는 경우는 간선의 가중치가 마이너스가 아닌 이상 변경될 일이 없습니다.</string>
    <string name="BellmanFord14">동일한 작업을 모든 간선에 적용합니다. 간선의 순서는 임의이지만 여기서는 더 왼쪽에 있는 간선부터 계산해가도록 하겠습니다.</string>
    <string name="BellmanFord15">간선을 하나 선택합시다.</string>
    <string name="BellmanFord150">예를 들어 점 C는 1회 이동, 점 D는 2회 이동으로 최단 경로가 구해집니다.</string>
    <string name="BellmanFord16">가중치를 변경했습니다.</string>
    <string name="BellmanFord17">동일한 방식으로 또다른 간선을 선택합니다.</string>
    <string name="BellmanFord18">가중치를 변경했습니다.</string>
    <string name="BellmanFord19">현시점에선 정점A에서 정점B로 가는 경우 정점A에서 직접 가는 것보다 정점C를 경유하는 것이 가중치가 작다는 것을 알 수 있습니다.</string>
    <string name="BellmanFord2">모든 간선 중에서 하나를 선택합니다. 여기선 A-B를 연결하는 간선을 선택했습니다.</string>
    <string name="BellmanFord20">모든 간선에 대해 변경 작업을 진행해갑니다.</string>
    <string name="BellmanFord21">이것으로 1라운드 작업이 끝난 것입니다.</string>
    <string name="BellmanFord22">동일한 작업을 가중치가 변경되지 않을 때까지 반복합니다.</string>
    <string name="BellmanFord24">정점의 가중치가 변경되지 않았으므로 작업을 멈춥니다.</string>
    <string name="BellmanFord25">이 시점에서 알고리즘에 의한 탐색이 완료되며 시작점에서 모든 정점까지의 최단 경로가 나옵니다.</string>
    <string name="BellmanFord26">어떤 원리로 최단 경로가 구해지는지를 생각해보도록 합시다.</string>
    <string name="BellmanFord27">처음 상태로 되돌려보겠습니다.</string>
    <string name="BellmanFord28">이번에는 시작점인 A에서 접근할 수 있는 간선의 변경이 마지막에 되도록 모든 간선의 변경 작업을 역순, 즉 오른쪽에서부터 진행해보도록 하겠습니다.</string>
    <string name="BellmanFord3">선택한 간선의 한쪽 정점에서 다른 정점으로 이동하기 위한 가중치를 계산합니다. 계산 방법은 ‘시작 정점의 가중치+간선의 가중치’입니다.</string>
    <string name="BellmanFord30">1라운드의 변경 작업이 끝났습니다.</string>
    <string name="BellmanFord31">1라운드가 끝난 시점에서, 시작점 A로부터 1회 이동으로 도달할 수 있는 정점의 가중치만 변경된 것을 알 수 있습니다.</string>
    <string name="BellmanFord32">2라운드 변경 작업을 진행합니다.</string>
    <string name="BellmanFord34">2라운드 변경 작업을 끝냈습니다.</string>
    <string name="BellmanFord35">2라운드 변경이 끝난 시점에서, A로부터 2회 이동으로 도달할 수 있는 정점의 가중치만 변경된 것을 알 수 있습니다.</string>
    <string name="BellmanFord36">사실은 변경 작업을 N회 실시한 시점에서 A로부터 이동을 N회 이하로 제한한 각 정점까지의 최단 경로가 구해집니다.</string>
    <string name="BellmanFord37">그림은 변경 작업을 2회한 상태이므로 시작점에서 2회 이하로 이동한 각 정점의 최단 경로가 구해진 상태입니다.</string>
    <string name="BellmanFord38">어디까지나 2회 이하의 이동 시에 최단 경로입니다. 예를 들어 F는 실제는 A-C-D-F라는 경로를 지나는 것이 가중치가 적지만 3회 이동을 필요로 하므로 고려하지 않았습니다.</string>
    <string name="BellmanFord39">또한, 점 B는 3회 이동한 경우의 최단 경로지만 간선을 변경하는 순서로 인해 우연히 이렇게 된 것입니다.</string>
    <string name="BellmanFord4">계산은 한 방향씩 하지만 어느쪽을 먼저 계산할지는 고려하지 않아도 됩니다. 여기선 가중치가 작은 정점에서 큰 정점으로 가는 방향을 먼저 계산하도록 하겠습니다.</string>
    <string name="BellmanFord40">즉, 간선을 변경하는 순서에 따라선 변경한 횟수 이상의 이동을 필요로 하는 최단 경로가 있을 수 있습니다.</string>
    <string name="BellmanFord41">n회 변경 작업을 실시했을 때에 n회 이하의 이동으로 최단 경로를 구할 수 있다는 것은 몇 번의 변경 작업을 통해 알 수 있을 까요.</string>
    <string name="BellmanFord42">정점이 n개 있다고 하고 동일한 정점을 지나지 않도록 n-1회 이동하면 반드시 모든 정점을 지날 수 있습니다.</string>
    <string name="BellmanFord43">즉, 많아도 n-1회 변경 작업을 하면 모든 점에 대한 최단 경로를 구할 수 있습니다.</string>
    <string name="BellmanFord44">또한, 도중에 변경되지 않은 경우라도 최단 경로가 확정됐다는 것을 판단할 수 있으므로 거기서 작업을 중단합니다.</string>
    <string name="BellmanFord45">그러면 모든 정점에 대한 최단 경로를 구할 때까지 그림의 상태로부터 변경 작업을 재개해보겠습니다.</string>
    <string name="BellmanFord47">변경이 없으면 작업을 멈춥니다.</string>
    <string name="BellmanFord48">앞의 방법과 동일하게 모든 정점에 대한 최단 경로를 구했습니다.</string>
    <string name="BellmanFord49">참고로 그래프의 A-B처럼 각 방향의 가중치가 다른 경우 또는 일반 통행만 가능한 경우에도...</string>
    <string name="BellmanFord5">정점B보다도 A가 현재 가중치가 작으므로 정점A에서 정점B로 가는 경우를 먼저 계산합니다.</string>
    <string name="BellmanFord50">벨만-포드법으로 최단 경로를 구할 수 있습니다.</string>
    <string name="BellmanFord51">"참고로 그림처럼 간선에 방향이 설정돼 있는 그래프를 '방향성 그래프', 설정돼 있지 않은 것을 '비방향성 그래프'라고 합니다."</string>
    <string name="BellmanFord52">"음의 가중치'를 포함하는 경우는 어떻게 될까요?"</string>
    <string name="BellmanFord53">"음의 가중치란 그림에선 C-B에 있는 '-3'를 가리킵니다."</string>
    <string name="BellmanFord54">가중치가 음의 값이라는 것은 무엇을 의미할까요?</string>
    <string name="BellmanFord55">예를 들어 시작점 A로부테 종점 G까지 차로 이동하는 경우를 생각해봅시다. 각 가중치는 연료의 소비량을 나타낸다고 생각할 수 있습니다.</string>
    <string name="BellmanFord56">"이 경우 '음의 가중치' 위치에는 주유소가 있으며 연료를 주유한다고 생각할 수 있습니다."</string>
    <string name="BellmanFord57">"벨만-포드법에선 이처럼 '음의 가중치'를 포함하더라도 올바른 최단 경로를 구할 수 있습니다."</string>
    <string name="BellmanFord58">그래프처럼 C-B의 음의 가중치가 -3에서 -6이 된 경우는 어떻게 될까요?</string>
    <string name="BellmanFord59">문제 없이 최단 경로를 구할 수 있을 것처럼 보이지만…</string>
    <string name="BellmanFord6">정점A의 가중치가 0이므로 정점A에서 B로 가는 가중치는 0+9로 9가 됩니다.</string>
    <string name="BellmanFord60">A-C-B를 일주했을 때의 합계가 -1이 됩니다.</string>
    <string name="BellmanFord61">"이런 경로를 '음의 폐로'라고 합니다."</string>
    <string name="BellmanFord62">음의 폐로가 존재하는 경우 해당 경로를 계속 순회하면 가중치가 계속 작아지게 됩니다.</string>
    <string name="BellmanFord63">따라서 어떤 방법을 사용해도 최단 경로를 구할 수 없습니다.</string>
    <string name="BellmanFord64">이 그래프의 최단 경로를 벨만-포드법으로 구하려고 하면, 몇 번이고 변경 작업을 해도 어느 정점의 값이 바뀌므로 종료되지 않습니다.</string>
    <string name="BellmanFord65">반대로 벨만-포드법은 정점의 수 -1의 작업으로 변경 작업이 완료되므로…</string>
    <string name="BellmanFord66">변경이 n회 이상이 되면 그래프의 어딘가에 음의 폐로가 존재한다는 의미가 됩니다.</string>
    <string name="BellmanFord67">이와 같이 벨만-포드법은 계산량이 많은 알고리즘이지만 음의 가중치가 있어도 최단 경로를 구할 수 있으며…</string>
    <string name="BellmanFord68">음의 폐로가 존재한다는 것도 감지할 수 있습니다.</string>
    <string name="BellmanFord69">이것으로 벨만-포드법의 설명을 마칩니다.</string>
    <string name="BellmanFord7">계산한 결과가 현재 값보다 작으면 가중치를 새로운 값으로 변경합니다.</string>
    <string name="BellmanFord8">정점B의 현재 값은 무한대로 9가 작습니다. 따라서 가중치를 9로 변경합니다.</string>
    <string name="BellmanFord9">값이 변경된 경우에는 어느 정점에서 온 경로인지를 표시해둡니다(위 그림에서 주황색으로 표시).</string>
    <string name="BinarySearch">이분 탐색</string>
    <string name="BinarySearch0">이분 탐색은 정렬된 배열에서 데이터를 탐색하는 알고리즘입니다.</string>
    <string name="BinarySearch1">숫자 6을 탐색해보겠습니다.</string>
    <string name="BinarySearch10">남은 배열의 정중앙에 있는 수를 찾습니다. 여기선 6이 됩니다.</string>
    <string name="BinarySearch11">6 = 6으로 대상 숫자를 발견했습니다.</string>
    <string name="BinarySearch12">이진 탐색은 배열이 정렬돼 있다는 것을 활용해서 탐색할 범위를 매번 반씩 줄여나갈 수 있습니다.</string>
    <string name="BinarySearch13">이것으로 이분 탐색에 대한 설명을 마칩니다.</string>
    <string name="BinarySearch2">먼저 배열의 정중앙에 있는 수를 찾습니다. 여기선 5가 됩니다.</string>
    <string name="BinarySearch3">5와 탐색할 수인 6을 비교합니다. 5 &lt; 6이므로 6은 5보다 오른쪽에 있다는 것을 알 수 있습니다.</string>
    <string name="BinarySearch4">필요가 없어진 숫자는 후보에서 제외합니다.</string>
    <string name="BinarySearch6">남은 배열의 정중앙에 있는 수를 찾습니다. 여기선 7이 됩니다.</string>
    <string name="BinarySearch7">7과 6을 비교합니다. 6 &lt; 7이므로 6은 7보다 왼쪽에 있다는 것을 알 수 있습니다.</string>
    <string name="BinarySearch8">필요 없어진 숫자를 후보에서 제외합니다.</string>
    <string name="BinaryTree">이분 탐색 트리</string>
    <string name="BinaryTree0">이진 탐색 트리(binary search tree)는 데이터 구조의 하나입니다.</string>
    <string name="BinaryTree1">숫자가 적혀 있는 부분을 노드라고 합니다.</string>
    <string name="BinaryTree10">반대로 이분 탐색 트리에서 최대 노드는 최상단의 노드로부터 오른쪽 가지만 계속 따라가면 나오는 가장 끝에 있는 노드가 됩니다.</string>
    <string name="BinaryTree11">이분 탐색 트리에 노드를 추가하는 경우의 순서를 보도록 하겠습니다.</string>
    <string name="BinaryTree12">예를 들어 1을 추가하는 경우입니다.</string>
    <string name="BinaryTree13">노드 추가 위치를 이분 탐색 트리의 최상단 노드부터 탐색해갑니다.</string>
    <string name="BinaryTree14">1 &lt; 15 이므로 왼쪽으로 진행합니다</string>
    <string name="BinaryTree16">１＜９ なので、左に進みます。</string>
    <string name="BinaryTree18">1 &lt; 3이므로 왼쪽으로 진행해야 하지만 노드가 없으므로 새로운 노드로 추가합니다.</string>
    <string name="BinaryTree2">이분 탐색 트리는 두 가지 성질을 지닙니다.</string>
    <string name="BinaryTree20">이것으로 1 추가 작업이 완료됩니다.</string>
    <string name="BinaryTree21">다음은 4를 추가해보도록 하겠습니다.</string>
    <string name="BinaryTree22">앞의 예와 마찬가지로 추가할 위치를 찾습니다. 이분 탐색 트리의 최상단 노드부터 탐색해갑니다.</string>
    <string name="BinaryTree23">4 &lt; 15이므로 왼쪽으로 진행합니다.</string>
    <string name="BinaryTree25">4 &lt; 9이므로 왼쪽으로 진행합니다.</string>
    <string name="BinaryTree27">4 > 3이므로 오른쪽으로 진행합니다.</string>
    <string name="BinaryTree29">4 &lt; 8이므로 왼쪽으로 진행해야 하지만 왼쪽에 노드가 없으므로 새로운 노드로 추가합니다.</string>
    <string name="BinaryTree3">첫 번째 성질은, 모든 노드는 왼쪽 가지에 포함되는 어떤 숫자보다도 큰 숫자가 된다는 것입니다.</string>
    <string name="BinaryTree31">이것으로 4 추가 작업이 완료됩니다.</string>
    <string name="BinaryTree32">이분 탐색 트리에서 노드를 삭제하는 순서를 보도록 하겠습니다.</string>
    <string name="BinaryTree33">예를 들어 28을 삭제하는 경우를 보겠습니다.</string>
    <string name="BinaryTree34">자식 노드가 없는 노드는...</string>
    <string name="BinaryTree35">대상 노드를 삭제만 하면 작업이 끝납니다</string>
    <string name="BinaryTree36">다음은 8을 삭제해보도록 하겠습니다.</string>
    <string name="BinaryTree37">자식 노드가 하나인 노드를 삭제할 때는...</string>
    <string name="BinaryTree38">대상 노드를 삭제하고…</string>
    <string name="BinaryTree39">삭제한 노드의 위치로 자식 노드를 이동시키면 끝입니다.</string>
    <string name="BinaryTree4">예를 들어 노드9는 그 왼쪽에 있는 가지의 모든 숫자보다 큽니다.</string>
    <string name="BinaryTree40">마지막으로 9를 삭제해보겠습니다.</string>
    <string name="BinaryTree41">자식 노드가 두 개인 노드를 삭제할 때는…</string>
    <string name="BinaryTree42">먼저 대상 노드를 삭제하고…</string>
    <string name="BinaryTree43">삭제한 노드의 왼쪽 가지에서 최대 노드를 찾습니다.</string>
    <string name="BinaryTree44">삭제한 노드의 위치로 이동시킵니다.</string>
    <string name="BinaryTree45">이것으로 이분 탐색 트리의 두 가지 성질을 유지하면서 노드를 삭제할 수 있었습니다.</string>
    <string name="BinaryTree46">참고로 이동 대상 노드(여기선 4)도 자식 노드를 지니는 경우에는 동일한 처리를 재귀적으로 반복하면 됩니다</string>
    <string name="BinaryTree47">또한, 이동 대상으로 ‘왼쪽 가지의 최대 노드’를 사용했지만 반대로 ‘오른쪽 가지의 최소 노드’를 사용해도 됩니다.</string>
    <string name="BinaryTree48">이번에는 이분 탐색 트리에서 노드를 탐색하는 순서를 보도록 하겠습니다.</string>
    <string name="BinaryTree49">예를 들어 12를 탐색하는 경우를 보겠습니다.</string>
    <string name="BinaryTree5">마찬가지로 노드15는 그 왼쪽 가지에 있는 어떤 숫자보다 큽니다.</string>
    <string name="BinaryTree50">이분 탐색 트리의 최상단 노드부터 탐색을 시작합니다.</string>
    <string name="BinaryTree51">12 &lt; 15 이므로 왼쪽으로 진행합니다</string>
    <string name="BinaryTree53">12 > 4이므로 오른쪽으로 진행합니다.</string>
    <string name="BinaryTree55">12를 발견했습니다.</string>
    <string name="BinaryTree56">이와 같이 이분 탐색 트리를 사용하면 효율적인 탐색이 가능하다는 것을 알 수 있습니다.</string>
    <string name="BinaryTree57">하지만 트리가 직선에 가까운 형태가 되면 선형 탐색과 마찬가지로 탐색 효율이 매우 나빠집니다.</string>
    <string name="BinaryTree58">한편, 항상 균형을 유지하도록 하는 구조도 있습니다. 이것을 ‘자가 균형 이진 탐색 트리(self-balancing binary search tree)’라고 하며 탐색 효율을 유지할 수 있습니다.</string>
    <string name="BinaryTree59">이것으로 이분 탐색 트리에 대한 설명을 마치겠습니다.</string>
    <string name="BinaryTree6">두 번째 성질은, 모든 노드는 그 노드의 오른쪽 가지에 포함되는 어떤 숫자보다 작은 숫자가 된다는 것입니다.</string>
    <string name="BinaryTree7">예를 들어 노드15는 그 오른쪽 가지에 있는 어떤 수보다도 작습니다.</string>
    <string name="BinaryTree8">이 두 개의 성질로부터 다음 조건이 성립됩니다.</string>
    <string name="BinaryTree9">먼저 이분 탐색 트리의 최소 노드는 최상단에 있는 노드로부터 왼쪽 가지만 계속 따라가면 나오는 가장 끝에 있는 노드가 됩니다.</string>
    <string name="BinaryTreeDescription">이분 탐색 트리는 탐색 트리 중 가장 기본이 되는 것입니다. 이 항목은 모든 알고리즘을 구매 후에 학습할 수 있습니다.</string>
    <string name="BreadthFirstSearch">너비 우선 탐색</string>
    <string name="BreadthFirstSearch0">너비 우선 탐색은 그래프를 탐색하는 알고리즘입니다.</string>
    <string name="BreadthFirstSearch1">A를 시작점, G를 목표로 해서 탐색을 시작합니다.</string>
    <string name="BreadthFirstSearch11">후보 중에서 가장 먼저 추가된 것은 C와 D입니다. 이중에서 왼쪽 C를 선택합니다.</string>
    <string name="BreadthFirstSearch12">선택한 정점으로 이동합니다.</string>
    <string name="BreadthFirstSearch13">현재 위치인 C에서 도달할 수 있는 H를 새로운 후보로 추가합니다.</string>
    <string name="BreadthFirstSearch14">동일한 작업을 목표에 도달하거나 모든 정점의 탐색이 끝날 때까지 반복합니다.</string>
    <string name="BreadthFirstSearch2">A에서 도달할 수 있는 정점B, C, D가 다음 이동 대상 후보가 됩니다.</string>
    <string name="BreadthFirstSearch3">후보들 중에서 하나의 정점을 선택합니다. 선택 기준은 후보 중 가장 먼저 후보에 추가된 것으로 합니다.</string>
    <string name="BreadthFirstSearch38">목표에 도착했으므로 탐색을 종료합니다.</string>
    <string name="BreadthFirstSearch39">이와 같이 너비 우선 탐색은 시작점부터 가까운 순으로 너비를 넓혀 가며 탐색하는 방식입니다.</string>
    <string name="BreadthFirstSearch4">동일한 시점에 후보가 된 정점의 경우는 아무거나 선택해도 됩니다. 여기서는 왼쪽에 있는 정점부터 선택하도록 합니다.</string>
    <string name="BreadthFirstSearch40">이것으로 너비 우선 탐색에 대한 설명을 마칩니다.</string>
    <string name="BreadthFirstSearch5">모두 동일한 시점에 후보가 됐으므로 B를 선택합니다.</string>
    <string name="BreadthFirstSearch6">선택한 정점으로 이동합니다.</string>
    <string name="BreadthFirstSearch7">현재 B에서 도달할 수 있는 E와 F가 새로운 후보로 추가됩니다.</string>
    <string name="BreadthFirstSearch8">후보 정점은 ‘선입선출(FIFO)’ 구조로 관리하므로 ‘큐’ 데이터 구조를 이용할 수 있습니다.</string>
    <string name="BreadthFirstSearch9">큐(queue)에 대해선 이 앱에서 자세히 다루고 있습니다.</string>
    <string name="BubbleSort">버블 정렬</string>
    <string name="BubbleSort0">버블 정렬은 수열을 정렬하는 알고리즘 중 하나입니다.</string>
    <string name="BubbleSort1">수열의 오른쪽 끝에 저울을 두고 저울의 좌우에 있는 숫자를 비교합니다.</string>
    <string name="BubbleSort16">저울이 왼쪽 끝에 도착했습니다.</string>
    <string name="BubbleSort2">이 경우 7과 6을 비교합니다.</string>
    <string name="BubbleSort20">일련의 작업으로 수열 중에서 가장 작은 숫자가 왼쪽 끝으로 이동했습니다.</string>
    <string name="BubbleSort21">왼쪽 끝의 숫자는 정렬을 끝낸 것으로 간주하고…</string>
    <string name="BubbleSort22">저울을 오른쪽 끝으로 다시 옮깁니다.</string>
    <string name="BubbleSort23">동일한 작업을 모든 숫자가 정렬될 때까지 반복합니다.</string>
    <string name="BubbleSort25">정렬이 완료됐습니다.</string>
    <string name="BubbleSort26">이것으로 버블 정렬에 대한 설명을 마치겠습니다.</string>
    <string name="BubbleSort3">비교한 결과 오른쪽 숫자가 작으면 왼쪽과 바꿉니다.</string>
    <string name="BubbleSort4">6 &lt; 7이므로 좌우의 숫자를 교체합니다.</string>
    <string name="BubbleSort5">비교를 완료했으면 저울을 한 칸 왼쪽으로 이동합니다.</string>
    <string name="BubbleSort6">동일한 방법으로 숫자를 비교합니다.</string>
    <string name="BubbleSort7">이번에는 4 &lt; 6이므로 숫자를 교체하지 않습니다.</string>
    <string name="BubbleSort8">저울을 한 칸 왼쪽으로 옮깁니다.</string>
    <string name="BubbleSort9">동일한 작업을 저울이 왼쪽 끝에 도착할 때까지 반복합니다.</string>
    <string name="BuyAllAlgorithms">모든 알고리즘 구매하지:%@</string>
    <string name="BuyAllAlgorithmsAndroid">모든 알고리즘 구매하기</string>
    <string name="CKC">공통키 암호 방식</string>
    <string name="CKC0">공통키 암호 방식은 암호화와 복호화에 동일한 키를 사용하는 암호 방식입니다.</string>
    <string name="CKC1">공통키 암호 방식을 사용한 데이터 전송의 전체 흐름을 보도록 하겠습니다.</string>
    <string name="CKC10">B는 A에게서 받은 암호문을 동일한 키를 사용해서 복호화합니다.</string>
    <string name="CKC11">이것으로 B는 원 데이터를 얻을 수 있습니다.</string>
    <string name="CKC12">데이터를 암호화해두면 설령 악의를 지닌 제삼자가 훔쳐본다고 해도 안심할 수 있습니다.</string>
    <string name="CKC13">암호화와 복호화에 동일한 키를 사용하는 것이 공통키 암호 방식의 특징입니다.</string>
    <string name="CKC14">공통키 암호 방식의 계산 방법에는 다음 그림과 같은 것이 있습니다.</string>
    <string name="CKC15">현재는 AES가 주로 사용되고 있습니다.</string>
    <string name="CKC16">다음은 공통키 암호 방식의 문제점에 대해 알아보겠습니다.</string>
    <string name="CKC17">상황을 약간 앞으로 돌리도록 하겠습니다.</string>
    <string name="CKC18">암호문은 X가 훔쳐볼 가능성이 있습니다.</string>
    <string name="CKC19">A와 B는 직접 대면한적이 없는 관계이며 …</string>
    <string name="CKC2">A가 B에게 인터넷을 경유해서 데이터를 전송하려고 하고 있습니다.</string>
    <string name="CKC20">암호화에 사용된 키를 B가 모른다고 가정해봅시다.</string>
    <string name="CKC21">A는 특정 수단을 사용해서 B에게 키를 전달해야 합니다.</string>
    <string name="CKC22">A는 암호문과 동일하게 인터넷을 통해서 B에게 키를 전송합니다.</string>
    <string name="CKC23">B는 A가 보낸 키를 사용해서...</string>
    <string name="CKC24">암호문을 복호화합니다.</string>
    <string name="CKC25">하지만 이 키는 X도 훔쳐볼 가능성이 있습니다.</string>
    <string name="CKC26">즉, X도 키를 사용해서 암호문을 복호화할 수 있다는 의미입니다.</string>
    <string name="CKC27">키를 전달하는 방법에 문제가 있다는 것을 알 수 있습니다.</string>
    <string name="CKC28">그래서 A는 X가 훔쳐보지 못하도록 키 전체를 암호화하는 방법을 생각했습니다.</string>
    <string name="CKC29">컴퓨터에게는 키도 데이터의 일종에 불과합니다.</string>
    <string name="CKC3">데이터는 인터넷상의 다양한 네트워크나 장비를 통해서 B에게 전달됩니다.</string>
    <string name="CKC30">따라서..</string>
    <string name="CKC31">새로운 키를 사용해서 암호화할 수가 있습니다.</string>
    <string name="CKC32">키의 암호문을…</string>
    <string name="CKC33">B에게 전달합니다.</string>
    <string name="CKC34">B는 데이터의 암호문과 그것을 복호화하기 위한 키의 암호문을 가지고 있습니다.</string>
    <string name="CKC35">키의 암호문도 다시 X에게 노출될 가능성이 있습니다.</string>
    <string name="CKC36">"다음은 '키의 암호화에 사용한 새로운 키'를B에게 전달만 하면 됩니다."</string>
    <string name="CKC37">"A는 이 '새로운 키'를 어떻게 B에게 전달하면 좋을까요?"</string>
    <string name="CKC38">"암호화하지 않으면 X가 '새로운 키'를 훔쳐서 사용할 수 있습니다."</string>
    <string name="CKC39">암호화하면 다시 새로운 키가 생겨서 문제가 반복됩니다.</string>
    <string name="CKC4">따라서 데이터를 그냥 전달하려고 하면…</string>
    <string name="CKC40">"정리하면, '공통키 암호 방식'에선 키를 안전하게 전달할 방법이 필요한 것입니다."</string>
    <string name="CKC41">"이것을 '키 배분 문제'라고 합니다."</string>
    <string name="CKC42">해결 방법으로는 ‘키 교환 프로토콜을 사용하는 방법’과 ‘공개키 암호 방식을 사용하는 방법’ 두 가지가 있으며 이 앱에서 자세히 다루고 있습니다.</string>
    <string name="CKC43">이것으로 공통키 암호 방식에 대한 설명을 마치겠습니다.</string>
    <string name="CKC5">악의를 지닌 제삼자가 데이터를 훔쳐볼 가능성이 있습니다.</string>
    <string name="CKC6">이 때문에 비밀로 하고 싶은 데이터는 암호화해서 전송할 필요가 있습니다.</string>
    <string name="CKC7">키를 사용해서…</string>
    <string name="CKC8">키를 사용해서 데이터를 암호화한 암호문을 만듭니다.</string>
    <string name="CKC9">암호문을 B에게 전송합니다.</string>
    <string name="Cancel">취소</string>
    <string name="CannotPayAlert">구매가 제한돼 있습니다. 아이폰/아이패드의 설정을 변경해주세요.</string>
    <string name="CannotRestoreAlert">구매 기록을 확인할 수 없습니다. 구매했을 때와 동일한 iTunes 계정을 사용해 로그인했는지 확인해주세요.</string>
    <string name="CannotRestoreAlertAndroid">구매 기록을 확인할 수 없습니다. 인터넷에 연결돼 있는지, 구매했을 때와 동일한 Google Play 계정을 사용하고 있는지 확인해주세요.</string>
    <string name="ChangeConfirmation">변경해도 괜찮습니까?</string>
    <string name="ClusteringSection">클러스터링</string>
    <string name="CompressionSection">데이터 압축</string>
    <string name="Config">설정</string>
    <string name="DataStructureSection">데이터 구조</string>
    <string name="DepthFirstSearch">깊이 우선 탐색</string>
    <string name="DepthFirstSearch0">깊은 우선 탐색은 그래프를 탐색하는 알고리즘입니다.</string>
    <string name="DepthFirstSearch1">A를 시작점, G를 목표로 해서 탐색을 시작합니다.</string>
    <string name="DepthFirstSearch11">후보 중 가장 최근에 추가된 것은 E와 F입니다. 이중에서 왼쪽에 있는 E를 선택합니다.</string>
    <string name="DepthFirstSearch12">선택한 정점으로 이동합니다.</string>
    <string name="DepthFirstSearch13">현재 있는 E에서 도달할 수 있는 K를 새로운 후보로 추가합니다.</string>
    <string name="DepthFirstSearch14">동일한 작업을 목표에 도달하거나 모든 정점의 탐색이 끝날 때까지 반복합니다.</string>
    <string name="DepthFirstSearch2">A에서 도달할 수 있는 정점은 B, C, D이므로 다음 후보로 표시합니다.</string>
    <string name="DepthFirstSearch28">목표에 도착했음으로 탐색을 종료합니다.</string>
    <string name="DepthFirstSearch29">이와 같이 깊이 우선 탐색은 하나의 길을 깊이 있게(수직으로) 찾아가는 방식입니다.</string>
    <string name="DepthFirstSearch3">후보 중에서 하나의 정점을 선택합니다. 선택 기준은 후보 중 가장 최근에(가장 늦게) 추가된 것입니다.</string>
    <string name="DepthFirstSearch30">이것으로 깊이 우선 탐색에 대한 설명을 마칩니다.</string>
    <string name="DepthFirstSearch4">동일 시점에 후보가 된 정점은 어느 것을 선택하든 상관 없습니다. 여기선 왼쪽에 있는 정점을 선택하도록 하겠습니다.</string>
    <string name="DepthFirstSearch5">모두 동일한 시점에 후보가 됐으므로 B를 선택합니다.</string>
    <string name="DepthFirstSearch6">선택한 정점으로 이동합니다.</string>
    <string name="DepthFirstSearch7">현재 있는 B로부터 도달할 수 있는 E와 F를 새로운 후보로 추가합니다.</string>
    <string name="DepthFirstSearch8">후보인 정점은 ‘후입선출(LIFO)’ 구조로 관리하므로 ‘스택’ 데이터 구조를 이용할 수 있습니다.</string>
    <string name="DepthFirstSearch9">스택(stack)에 대해선 이 앱에서 자세히 다루고 있습니다.</string>
    <string name="DiffieHellman">디피-헬만(Diffie-Hellman) 키 교환법</string>
    <string name="DiffieHellman0">디피-헬만 키 교환법(Diffie-Hellman key exchange)은 안전하게 키를 교환하기 위한 기법입니다.</string>
    <string name="DiffieHellman1">수식을 사용해서 설명하기 전에 먼저 그림을 통해 개념적으로 접근해보도록 하겠습니다.</string>
    <string name="DiffieHellman10">새로운 키와 합성할 수 있다는 것입니다.</string>
    <string name="DiffieHellman11">그림에선 키 P-S를 이용해서 새로운 키 P-P-S가 만들어집니다.</string>
    <string name="DiffieHellman12">즉, 합성된 키를 다시 합성할 수 있습니다.</string>
    <string name="DiffieHellman13">이 합성 방법을 사용해서 A와 B 사이에 키를 안전하게 교환해보도록 하겠습니다</string>
    <string name="DiffieHellman14">먼저 A가 키 P를 준비합니다. 이 키 P는 아무에게나 공개해도 괜찮습니다.</string>
    <string name="DiffieHellman15">A가 B에게 키 P를 전달합니다.</string>
    <string name="DiffieHellman16">다음은 A와 B가 각각 비밀키 SA와 비밀키 SB를 준비합니다.</string>
    <string name="DiffieHellman17">키 SA와 키 SB는 제삼자가 모르게 관리해야 합니다.</string>
    <string name="DiffieHellman18">A는 키P와 비밀키 SA로부터 새로운 키 P-SA를 합성합니다.</string>
    <string name="DiffieHellman19">B도 키 P와 비밀키 SB로부터 새로운 키 P-SB를 합성합니다.</string>
    <string name="DiffieHellman2">두 개의 키를 합성하는 특별한 방법이 있다고 가정해보겠습니다.</string>
    <string name="DiffieHellman20">A가 B에게 키 P-SA를 보냅니다.</string>
    <string name="DiffieHellman21">마찬가지로 B도 A에게 키 P-SB를 보냅니다.</string>
    <string name="DiffieHellman22">A는 비밀키 SA와 B에게서 받은 키 P-SB를 합성해서 새로운 키 SA-P-SB를 얻습니다.</string>
    <string name="DiffieHellman23">동일하게 B도, 비밀키 SA와 A에게서 받은 키 P-SA를 합성해서 새로운 키 P-SA-SB를 얻습니다.</string>
    <string name="DiffieHellman24">A와 B 모두 키 P-SA-SB를 가지게 됩니다.</string>
    <string name="DiffieHellman25">이 키를 암호키, 복호키로 사용할 수 있습니다.</string>
    <string name="DiffieHellman26">이 키 교환법의 안전성을 검증해보도록 하겠습니다.</string>
    <string name="DiffieHellman27">키 P, 키 P-SA, 키 P-SB는 인터넷을 경유해서 전송되기 때문에…</string>
    <string name="DiffieHellman28">제삼자인 X가 훔쳐볼 가능성이 있습니다.</string>
    <string name="DiffieHellman29">하지만 X가 얻은 키로는 키 P-SA-SB를 합성할 수 없습니다.</string>
    <string name="DiffieHellman3">이 합성 방법으로 키 P와 키 S를 합성하면…</string>
    <string name="DiffieHellman30">또한, 키는 분해할 수 없으므로 비밀키 SA와 SB를 얻을 수 없습니다.</string>
    <string name="DiffieHellman31">따라서 X는 키 P-SA-SB를 만들 수 없으며 이 키 교환법은 안전하다고 볼 수 있습니다.</string>
    <string name="DiffieHellman32">다음은 이 키 교환법을 수식으로 표현해보겠습니다.</string>
    <string name="DiffieHellman33">먼저 mod 연산에 대해 설멍하겠습니다.</string>
    <string name="DiffieHellman34">mod 연산은 나눗셈의 나머지를 구하는 연산입니다.</string>
    <string name="DiffieHellman35">A mod B는 A를 B로 나누었을 때의 나머지 C를 구합니다.</string>
    <string name="DiffieHellman36">구체적인 숫자를 사용한 연산 예를 보겠습니다.</string>
    <string name="DiffieHellman37">그러면 키 교환법을 수식으로 표현해보겠습니다. .</string>
    <string name="DiffieHellman38">가장 먼저 준비해야 하는 것은 키 P로, 수식에선 P와 G라는 두 개의 정수로 표현됩니다.</string>
    <string name="DiffieHellman39">P는 매우 큰 소수이고, G는 소수 P에 대응하는 ‘생성자’(또는 원시근(primitive root))라고 하는 숫자로부터 하나 선택합니다.</string>
    <string name="DiffieHellman4">새로운 키 P-S가 만들어집니다.</string>
    <string name="DiffieHellman40">소수 P의 생성자는 모든 소수 P에 대해 일정한 개수로 존재합니다.</string>
    <string name="DiffieHellman41">먼저 A가 소수 P와 생성자 G를 준비합니다. 이들은 제삼자에게도 노출돼도 괜찮습니다.</string>
    <string name="DiffieHellman42">A가 소수 P와 생성자 G를 B에게 전달합니다.</string>
    <string name="DiffieHellman43">다음은 A와 B가 비밀값 X와 Y를 준비합니다.</string>
    <string name="DiffieHellman44">비밀값 X와 Y는 P-2보다도 작아야 합니다.</string>
    <string name="DiffieHellman45">A와 B는 ‘(G를 비밀값으로 제곱) mod P’를 계산합니다.</string>
    <string name="DiffieHellman46">.이 계산이 이론상의 ‘합성’에 해당합니다.</string>
    <string name="DiffieHellman47">A와 B는 계산 결과를 서로 교환합니다.</string>
    <string name="DiffieHellman48">A와 B는 서로에게서 받은 수를 자신의 비밀키로 제곱하고 mod P를 계산합니다.</string>
    <string name="DiffieHellman49">이 계산 결과는 A와 B 동일한 값이 됩니다.</string>
    <string name="DiffieHellman5">이 합성 방법에는 두 가지 특성이 있습니다.</string>
    <string name="DiffieHellman50">이것으로 A와 B는 암호의 키로 사용할 수 있는 숫자를 공유하게 됩니다.</string>
    <string name="DiffieHellman51">이 키 교환법의 안정성을 검증해보겠습니다.</string>
    <string name="DiffieHellman52">각각의 숫자는 인터넷을 경유해서 전달되므로…</string>
    <string name="DiffieHellman53">X가 훔처볼 가능성이 있습니다.</string>
    <string name="DiffieHellman54">하지만 X가 얻은 숫자로는 A와 B가 공유하는 숫자를 계산할 수 없습니다.</string>
    <string name="DiffieHellman55">또한, 비밀값 X나 Y를 구하는 것도 불가능합니다.</string>
    <string name="DiffieHellman56">소수P, 생성자 G, G의 X승 mod P로부터 X를 구하는 문제는 ‘이산대수 문제’라고 불리며, 아직 효율적인 해법이 발견되지 않은 상태입니다.</string>
    <string name="DiffieHellman57">"디피-헬만 키교환법은 이 이산대수 문제'를 이용한 키 교환법이라고 할 수 있습니다."</string>
    <string name="DiffieHellman58">이것으로 디피-헬만 키 교환법에 대한 설명을 마칩니다.</string>
    <string name="DiffieHellman6">. 첫 번째는 키 P와 그것을 이용해서 합성한 키 P-S가 있다고 해도...</string>
    <string name="DiffieHellman7">키 S를 추출하는 것은 불가능하다는 것입니다.</string>
    <string name="DiffieHellman8">즉, 키를 합성할 수는 있지만 분해할 수는 없습니다.</string>
    <string name="DiffieHellman9">두 번째는 합성된 키라도…</string>
    <string name="DiffieHellmanDescription">디피-헬만 키 교환법은 안전하게 키를 교환하기 위한 기법입니다. 이 항목은 모든 알고리즘을 구매 후에 학습할 수 있습니다.</string>
    <string name="DigitalCertification">전자 인증서</string>
    <string name="DigitalCertification0">공개키 암호 방식이나 전사 서명에선 공개키가 정말로 통신하고자 하는 상대인지 보장되지 않는다는 문제가 있었습니다.</string>
    <string name="DigitalCertification1">따라서 A가 B에게 공개키를 보내려고 할 때에…</string>
    <string name="DigitalCertification10">인증 기관은 자신이 준비한 공개키 PC와 비밀키 SC를 보유하고 있습니다.</string>
    <string name="DigitalCertification11">A는 공개키 PA와 메일 주소를 포함한 개인 정보를 준비해서…</string>
    <string name="DigitalCertification12">인증 기관에 보냅니다.</string>
    <string name="DigitalCertification13">확인을 완료하면 인증 기관의 비밀키 SC를 이용해서 A의 데이터로부터 전자 서명을 작성합니다.</string>
    <string name="DigitalCertification14">전자 서명에 대해선 이 앱에서 자세히 다루고 있습니다.</string>
    <string name="DigitalCertification15">작성한 전자 서명과 데이터를 하나의 파일로 만듭니다.</string>
    <string name="DigitalCertification16">그리고 이 파일을 A에게 보냅니다.</string>
    <string name="DigitalCertification17">이 파일이 A의 전자 인증서가 됩니다.</string>
    <string name="DigitalCertification18">A는 공개키 대신에 전자 인증서를 B에게 보냅니다.</string>
    <string name="DigitalCertification19">B는 받은 인증서에 적힌 메일 주소가 A의 것인지 확인합니다.</string>
    <string name="DigitalCertification2">악의를 지닌 제삼자가 공개키를 바꾸어 전달해도 받는 측에선 눈치채지 못할 수도 있습니다.</string>
    <string name="DigitalCertification20">계속해서 B는 인증 기관의 공개키를 취득합니다.</string>
    <string name="DigitalCertification21">인증서 내의 서명이 인증 기관의 것인지 검증합니다.</string>
    <string name="DigitalCertification22">인증서의 서명은 인증 기관의 공개키 PC로만 검증할 수 있습니다.</string>
    <string name="DigitalCertification23">. 즉, 검증 결과에 문제가 없다면 이 인증서는 인증 기관이 발행한 것이라는 것이 보장됩니다.</string>
    <string name="DigitalCertification24">인증서가 인증 기관에서 발행된 것인고 A의 것임이 확인됐으므로 인증서에서 A의 공개키 PA를 꺼냅니다.</string>
    <string name="DigitalCertification25">이것으로 A에게서 B로의 공개키 전달이 완료됩니다.</string>
    <string name="DigitalCertification26">공개키 전달에 문제가 없는지 보도록 하겠습니다.</string>
    <string name="DigitalCertification27">악의를 지닌 X가 A로 위장해서 B에게 공개키 PX를 전달하려고 합니다.</string>
    <string name="DigitalCertification28">하지만 B는 인증서로 전달되지 않는 공개키를 신뢰할 필요가 없습니다.</string>
    <string name="DigitalCertification29">그렇다면 X가 A로 위장해서 인증 기관에 자신의 공개키를 등록하려고 하면 어떻게 될까요?</string>
    <string name="DigitalCertification3">전자 인증서를 이용하면 공개키 작성자가 누구인지를 보증할 수 있습니다.</string>
    <string name="DigitalCertification30">X는 A의 메일 주소를 소유하고 있지 않아서 인증서를 발급 받을 수 없습니다.</string>
    <string name="DigitalCertification31">X는 X의 메일 주소를 이용한 증명서만 작성할 수 있게 됩니다. 따라서 A의 인증서를 가져올 수 없습니다.</string>
    <string name="DigitalCertification32">전자 인증서를 사용해서 공개키 작성자를 확인할 수 있다는 것을 보았습니다.</string>
    <string name="DigitalCertification33">그런데 앞에서 B는 인증 기관의 공개키를 받았다고 했지만…</string>
    <string name="DigitalCertification34">여기서 한가지 의문이 생깁니다.</string>
    <string name="DigitalCertification35">B가 받은 공개키 PC는 정말 인증 기관이 발급한 것일까요?</string>
    <string name="DigitalCertification36">공개키 자체는 작성자를 확인할 수단이 없으므로 인증 기관으로 위장한 X가 작성한 것일 수도 있습니다.</string>
    <string name="DigitalCertification37">즉, 공개키가 가진 문제가 동일하게 발생하는 것입니다.</string>
    <string name="DigitalCertification38">실은 이 인증 기관의 공개키 PC도…</string>
    <string name="DigitalCertification39">전자 인증서로 전달됩니다.</string>
    <string name="DigitalCertification4">전자 인증서의 구조를 구체적으로 보도록 하겠습니다.</string>
    <string name="DigitalCertification40">그렇다면 이 인증 기관의 인증서에는 누가 서명하는 것일까요?</string>
    <string name="DigitalCertification41">더 상위에 있는 인증 기관입니다</string>
    <string name="DigitalCertification42">인증 기관은 트리 구조로 돼 있으며 상위의 인증 기관이 하위 인증 기관의 인증서를 작성합니다.</string>
    <string name="DigitalCertification43">인증 기관의 트리 구조는 어떻게 형성되는 것일까요?</string>
    <string name="DigitalCertification44">예를 들어 많은 신뢰를 받는 인증 기관 Y가 있다고 합시다.</string>
    <string name="DigitalCertification45">여기에 새로운 회사 G가 인증 기관을 하고 싶다고 해도 신용도가 없습니다.</string>
    <string name="DigitalCertification46">그래서 G는 Y사에게서 전자 인증서를 발급받습니다. 물론 Y사는 G사가 인증 기관 업무를 적절히 수행하고 있는지를 감독합니다.</string>
    <string name="DigitalCertification48">인증서가 발행되면 B사는 A사의 신뢰를 받고 있는 회사라고 어필할 수 있습니다.</string>
    <string name="DigitalCertification49">이처럼 더 큰 조직이 작은 조직의 신뢰를 담보하는 형태로 트리 구조가 형성됩니다.</string>
    <string name="DigitalCertification5">A는 공개키 PA와 비밀키 SA 쌍을 가지고 있으며…</string>
    <string name="DigitalCertification50">인증 기관의 최상위 기관은 어떻게 형성돼 있을까요?</string>
    <string name="DigitalCertification51">최상위에 있는 인증 기관은 ‘최상위 인증 기관(Root CA)’라고 하며 자신의 정당성을 스스로 증명하게 됩니다.</string>
    <string name="DigitalCertification52">참고로 최상위 인증 기관이 스스로 인증하는 인증서는 ‘최상위 인증서’라고 합니다.</string>
    <string name="DigitalCertification53">최상위 인증 서는 기관 자체가 신뢰받지 못하면 이용할 수가 없습니다.</string>
    <string name="DigitalCertification54">따라서 대기업이나 정부 관련 기관 등 이미 사회적으로 신뢰를 얻고 있는 기관이 많습니다.</string>
    <string name="DigitalCertification55">지금까지 개인 간의 공개키 교환 흐름을 다뤘지만…</string>
    <string name="DigitalCertification56">웹사이트와 통신할 때도 전자 인증서가 사용됩니다.</string>
    <string name="DigitalCertification57">웹사이트로부터 공개키가 붙은 인증서를 받으면 해당 사이트가 제삼자에 의해 위장되지 않은 것을 확인할 수 있습니다.</string>
    <string name="DigitalCertification58">이 인증서는 ‘서버 인증서’라고 하는 것으로 인증 기관에 의해 발행됩니다.</string>
    <string name="DigitalCertification59">개인의 경우 인증서는 메일 주소와 연결되지만…</string>
    <string name="DigitalCertification6">공개키 PA를 B에게 보내려고 합니다.</string>
    <string name="DigitalCertification60">서버 인증서는 도메인과 연결됩니다.</string>
    <string name="DigitalCertification61">서버 인증서는, 공개키가 인증서의 도메인을 관리하는 조직이 발행한 것임을 보증합니다.</string>
    <string name="DigitalCertification62">즉, 웹사이트의 도메인을 관리하는 있는 조직과 웹사이트의 내용이 담긴 서버를 관리하고 있는 조직이 동일하다는 것을 확인할 수 있습니다.</string>
    <string name="DigitalCertification63">이와 같이 전자 인증서는 인증 기관의 통해서 공개키 작성자를 보증하는 사회적 구조입니다.</string>
    <string name="DigitalCertification64">이것으로 전자 인증성에 대한 설명을 마치겠습니다.</string>
    <string name="DigitalCertification7">A는 먼저 인증 기관(CA: Certification Authority)에 공개키 PA가 자신의 것임을 나타내는 인증서 발행을 의뢰합니다.</string>
    <string name="DigitalCertification8">인증 기관은 전자 서명을 관리하기 위한 조직입니다. 원론상으로는 누구든 인증 기관을 만들 수 있어서 많은 기관이 존재합니다</string>
    <string name="DigitalCertification9">따라서 정부나 외부 기관을 통해 감사를 받은 대기업 등 신뢰할 수 있는 기관을 이용하는 것이 안전합니다.</string>
    <string name="DigitalCertificationDescription">전자 인증서는 공개키 작성자를 보증하기 위한 구조입니다. 이 항목은 모든 알고리즘을 구매 후에 학습할 수 있습니다.</string>
    <string name="DigitalSignature">전자 서명</string>
    <string name="DigitalSignature0">전자 서명은 메시지 인증 코드가 가지는 ‘인증’과 ‘변조 검출’ 두 가지 기능에…</string>
    <string name="DigitalSignature1">‘부인 방지’를 추가한 것입니다.</string>
    <string name="DigitalSignature10">예를 들어 A가 B에게 메시지를 전송한 후에 해당 메시지는 B가 임의의로 작성한 것이라고 주장할 수 있습니다.</string>
    <string name="DigitalSignature100">참고로 엄밀히 말해선 서명의 작성은 ‘암호문’과 다른 계산 방법인 경우도 있습니다.</string>
    <string name="DigitalSignature101">하지만 서명의 작성에는 비밀키를 사용하고 서명 검증에선 공개키를 사용한다는 점은 공통이므로 여기선 편의상 그렇게 설명하고 있습니다.</string>
    <string name="DigitalSignature11">또한, 공통키를 이용하고 있어서 A가 B 이외의 사람에게 메시지를 전송하려면 다른 키를 준비해야 합니다.</string>
    <string name="DigitalSignature12">한편 전자 서명 구조에선 MAC이 아닌 전송자만 작성할 수 있는 ‘전자 서명’이라는 데이터를 이용해서 메시지 작성자가 누군이지 식별할 수 있습니다. 이 데이터를 전자 서명이라고 합니다.</string>
    <string name="DigitalSignature13">구조를 보도록 하겠습니다.</string>
    <string name="DigitalSignature14">"그림에서 'Sig'라고 적힌 전자 서명은 A만 작성할 수 있습니다."</string>
    <string name="DigitalSignature15">A의 전자 서명이 첨부된 메시지를 전송한 경우, 전송자가 A인 것이 보장됩니다.</string>
    <string name="DigitalSignature16">메시지를 받은 B는 전자 서명이 A의 것인지 확인할 수 있지만, 동일한 전자 서명을 만들 수는 없습니다.</string>
    <string name="DigitalSignature17">메시지 인증 코드와 달리 공통키를 사용하지 않으므로 A는 동일 전자 서명을 사용해서 여러 사람에게 메시지를 전송할 수 있습니다.</string>
    <string name="DigitalSignature2">메시지 인증 코드에 대해 간단히 살펴보겠습니다.</string>
    <string name="DigitalSignature20">전자 서명의 작성 방법을 구체적으로 살펴 보겠습니다.</string>
    <string name="DigitalSignature21">메시지 인증 코드에선 MAC 작성에 사용하는 키가 공통이었지만…</string>
    <string name="DigitalSignature22">"전자 서명 작성에는 '공개키 암호 방식'의 순서를 응용합니다."</string>
    <string name="DigitalSignature23">"공개이 암호 방식'은 이 앱에서 자세히 설명하고 있습니다. 여기선 대략적인 흐름만 살펴보도록 하겠습니다."</string>
    <string name="DigitalSignature24">A가 B에게 암호화한 데이터를 전송하려고 합니다.</string>
    <string name="DigitalSignature25">먼저 데이터를 전달 받는 B가 공개키(P)와 비밀키(S)를 만듭니다.</string>
    <string name="DigitalSignature26">B가 A에게 공개키를 전달합니다.</string>
    <string name="DigitalSignature27">A는 받은 공개키를 사용해서 데이터를 암호화합니다.</string>
    <string name="DigitalSignature28">암호문을 B에게 보냅니다.</string>
    <string name="DigitalSignature29">B는 받은 암호문을 비밀키를 사용해서 원 데이터로 복원합니다. 이것으로 작업이 완료됩니다.</string>
    <string name="DigitalSignature3">메시지 인증 코드란 메시지에 MAC을 부여하므로 메시지 전송자가 키의 소유자임을 증명하기 위한 구조입니다.</string>
    <string name="DigitalSignature30">공개키 암호 방식에선 암호화에 공개키, 복호화에 비밀키를 사용했습니다.</string>
    <string name="DigitalSignature31">따라서 공개키를 사용해서 누구나 데이터를 암호화할 수 있지만…</string>
    <string name="DigitalSignature32">비밀키는 B만 가지고 있으므로 B만 복호화할 수 있다는 것이 보장됩니다.</string>
    <string name="DigitalSignature33">그러면 이 순서를 반대로 해서 비밀키를 암호화하고 공개키를 복호화하면 어떻게 될까요?</string>
    <string name="DigitalSignature34">이 경우에는 비밀키를 가진 A만 암호화할 수 있지만, 공개키를 사용해서 누구나 복호화할 수 있는 암호문이 작성됩니다.</string>
    <string name="DigitalSignature35">암호로서는 전혀 의미가 없지만, 관점을 바꾸면 이 암호문의 작성자가 비밀키를 가진 A라는 것이 보장되게 됩니다.</string>
    <string name="DigitalSignature36">전자 서명에선 이 A만이 만들 수 있는 암호문을 ‘서명’으로 활용합니다.</string>
    <string name="DigitalSignature37">전자 서명을 사용한 메시지 교환 순서를 보도록 하겠습니다</string>
    <string name="DigitalSignature38">먼저 A가 전송하고 싶은 메시지와 비밀키, 공개키를 준비합니다.</string>
    <string name="DigitalSignature39">메시지 전송 측이 비밀키과 공개키를 준비하는 점이 공개키 암호 방식과 다릅니다.</string>
    <string name="DigitalSignature4">여기선 편의상 메시지는 암호화하지 않고 전송되는 걸로 간주합니다.</string>
    <string name="DigitalSignature40">A는 B에게 공개키를 전달합니다.</string>
    <string name="DigitalSignature41">비밀키를 사용해서 메시지를 암호화합니다.</string>
    <string name="DigitalSignature42">이것(메시지를 암호화한 것)이 전자 서명입니다. 이후 그림에선 Sig라고 표시하고 있습니다.</string>
    <string name="DigitalSignature43">메시지와 서명을 B에게 전송합니다.</string>
    <string name="DigitalSignature44">B는 공개키를 사용해서 암호문(서명)을 복호화합니다.</string>
    <string name="DigitalSignature45">복호화한 메시지와 받은 받은 메시지가 일치하는지 확인합니다. 이것으로 데이터 교환이 마무리 됩니다.</string>
    <string name="DigitalSignature46">A의 공개키로 복호화할 수 있는 암호문은 A 본인만 만들 수 있는 것입니다.</string>
    <string name="DigitalSignature47">이 때문에 메시지를 전송한 것이 A라는 것과 메시지가 변조되지 않아다는 것을 판단할 수 있습니다.</string>
    <string name="DigitalSignature48">또한, A의 서명은 공개키만 가진 B는 작성할 수 없으므로 부인 방지 역할도 하게 됩니다.</string>
    <string name="DigitalSignature49">단, 공개키 암호 방식은 암호화와 복호화 모두 시간이 걸리는 경향이 있습니다.</string>
    <string name="DigitalSignature5">A는 메시지와 MAC 및 MAC 작성에 사용한 키를 B에게 보냅니다.</string>
    <string name="DigitalSignature50">따라서 계산 시간을 단축하기 위해 실제로는 메시지를 직접 암호화하는 것이 아니라…</string>
    <string name="DigitalSignature51">먼저 메시지의 해시값을 구한 후…</string>
    <string name="DigitalSignature52">그것을 암호화해서 서명으로 사용합니다.</string>
    <string name="DigitalSignature53">"참고호 해시화에 대해선 이 앱의 '해시 함수'에서 자세히 다루고 있습니다."</string>
    <string name="DigitalSignature54">메시지와 서명을 B에게 전송합니다.</string>
    <string name="DigitalSignature55">B도 마찬가지로 받은 메시지의 해시값을 구합니다.</string>
    <string name="DigitalSignature56">다음은 받은 서명을 공개키로 복호화해서 해시값을 구합니다.</string>
    <string name="DigitalSignature57">구한 두 개의 해시값이 같은지 확인이 되면 전자 서명을 사용한 데이터 교환이 완료됩니다.</string>
    <string name="DigitalSignature58">‘인증’, ‘변조 검출’, ‘부인 방지’ 기능을 모두 갖춘 전사 서명이지만 한 가지 문제가 있습니다.</string>
    <string name="DigitalSignature59">B는 전자 서명을 이용한 데이터 교환해서 메시지 전송자가 A라고 믿고 있지만…</string>
    <string name="DigitalSignature6">B는 받은 메시지와 키로부터 MAC을 재작성하고 그것이 받은 MAC과 같은 것인지 확인합니다.</string>
    <string name="DigitalSignature60">실제로는 A로 가장한 x와 데이터를 주고받을 가능성이 존재합니다.</string>
    <string name="DigitalSignature61">그 근본적인 원인은, 공개키 암호 방식에서 공개키가 누구 것인지 알 수 없다는 데 있습니다.</string>
    <string name="DigitalSignature62">받은 공개키에는 작성자를 가리키는 정보가 일절 포함돼 있지 않습니다.</string>
    <string name="DigitalSignature63">받은 공개키에는 작성자를 가리키는 정보가 일절 포함돼 있지 않습니다.</string>
    <string name="DigitalSignature64">정말로 A가 작성한 공개키일 가능성도 있어서 확실하게 판단하기가 어렵습니다.</string>
    <string name="DigitalSignature66">"이 문제는 '전자 인증서'를 사용하면 해결할 수 있습니다."</string>
    <string name="DigitalSignature67">전자 인증서에선 공개키에 작성자의 정보를 첨부한 것을 인증서로 사용합니다.</string>
    <string name="DigitalSignature68">전자 인증서에 대해선 이 앱에서 자세히 다루고 있습니다.</string>
    <string name="DigitalSignature69">이것으로 전자 서명에 대한 설명을 마칩니다.</string>
    <string name="DigitalSignature8">이것으로 전송자가 A인 것과 받은 메시지가 변조되지 않은 것을 확인할 수 있습니다.</string>
    <string name="DigitalSignature9">하지만 메시지 인증 코드는 공통키를 이용하는 구조이므로 키를 가진 누구나나 메시지 전송자가 될 수 있습니다.</string>
    <string name="DigitalSignatureDescription">전자 서명은 위장, 변조, 사후 부인 등을 해결해주는 구조입니다. 이 항목은 모든 알고리즘을 구매 후에 학습할 수 있습니다.</string>
    <string name="Dijkstra">다익스트라 기법</string>
    <string name="Dijkstra0">다익스트라 기법은 그래프의 최단 경로를 찾는 알고리즘입니다. 벨만-포드법보다 효율적인 방법입니다.</string>
    <string name="Dijkstra1">먼저 각 정점의 초기 가중치를 설정합니다. 시작점은 0, 그 외의 정점은 무한대로 설정합니다.</string>
    <string name="Dijkstra10">최단 경로를 결정한 정점B로 이동합니다.</string>
    <string name="Dijkstra100">왜냐하면 다른 경로를 사용하면 반드시 정점C를 경유해야 해서 결과적으로 현재 경로보다 가중치가 높아기지 때문입니다.</string>
    <string name="Dijkstra101">경로 A-B-D는 후보 정점 중에서 가장 가중치가 낮은 것을 선택한 결과입니다. 따라서 다른 정점을 경유해서 D로 가면 가중치가 반드시 지금보다 높아지게 됩니다.</string>
    <string name="Dijkstra102">여기선 정점B와 정점C가 후보가 됩니다.</string>
    <string name="Dijkstra11">현재 있는 정점에서 갈 수 있는 정점을 새로운 후보로 추가합니다. 여기선 C, D, E가 됩니다.</string>
    <string name="Dijkstra12">앞의 계산 방법과 동일한 방법으로 각 후보 정점들의 가중치를 계산합니다.</string>
    <string name="Dijkstra13">정점B에서 정점C로 가는 가중치는 2+6=8이 되지만 현재 값인 5가 더 작기 때문에 변경하지 않습니다.</string>
    <string name="Dijkstra14">나머지 정점D와 E의 가중치를 변경합니다.</string>
    <string name="Dijkstra15">후보 정점 중에서 가중치가 가장 작은 정점을 선택합니다. 여기선 정점D가 됩니다.</string>
    <string name="Dijkstra16">이 시점에서 선택한 정점D로 가는 경로 A-B-D가 시작점에서 정점D로 가는 최단 경로로 결정됩니다.</string>
    <string name="Dijkstra17">이처럼 다익스트라 기법은 각 정점으로 향하는 최단 경로를 하나씩 결정해가며 그래프를 탐색하는 알고리즘입니다.</string>
    <string name="Dijkstra18">동일한 작업을 종점 G에 도착할 때까지 반복합니다.</string>
    <string name="Dijkstra2">시작점부터 시작하겠습니다.</string>
    <string name="Dijkstra3">현재 있는 정점에서 갈 수 있는, 탐색하지 않은 정점을 찾습니다. 발견한 정점은 다음에 진행할 후보로 설정합니다.</string>
    <string name="Dijkstra35">종점G에 도착했으므로 탐색을 종료합니다.</string>
    <string name="Dijkstra36">최종적으로 만들어진 주황색 트리를 최단 경로 트리라고 하며, 각 정점으로 가는 최단 경로를 나타냅니다.</string>
    <string name="Dijkstra37">두꺼운 선으로 강조하고 있는 것은 시작점A에서 종점G까지의 최단 경로입니다.</string>
    <string name="Dijkstra38">가중치 계산과 변경을 모든 간선에 대해 반복하는 벨먼-포드법과 달리, 다익스트라 기법은 정점 선택 방법을 고민해서 효율이 좋은 최단 경로를 구합니다.</string>
    <string name="Dijkstra39">다익스트라 기법은 벨만-포드법과 마찬가지로 방향에 따라 가중치가 다른 경우나 일반 통행의 간선이 존재해도…</string>
    <string name="Dijkstra4">후보인 각 정점의 가중치를 계산합니다. 계산 방법은 ‘현재 있는 정점의 가중치+현재 있는 정점에서 후보 정점까지 가는 가중치’가 됩니다.</string>
    <string name="Dijkstra40">최단 경로를 제대로 구할 수 있습니다.</string>
    <string name="Dijkstra41">"참고로 그림처럼 간선에 방향이 설정돼 있는 그래프를 '방향성 그래프', 설정돼 있지 않은 것을 '비방향성 그래프'라고 합니다."</string>
    <string name="Dijkstra42">다익스트라 기법에선 마이너스 가중치를 포함하는 경우에는 최단 경로가 잘못되는 경우가 있습니다. 이 점은 벨먼-포드법과 다른 점입니다.</string>
    <string name="Dijkstra43">위 그래프에선 마이너스 가중치가 있는 C-B를 통과하는 경로 A-C-B-G(가중치 2)가 올바른 최단 경로입니다.</string>
    <string name="Dijkstra44">다익스트라 기법을 적용해서 풀어보겠습니다.</string>
    <string name="Dijkstra45">시작점A에서 도달할 수 있는, 검색이 완료되지 않은 정점은 B와 C입니다. 각각의 가중치는 2와 4입니다.</string>
    <string name="Dijkstra46">이 시점에서 다익스트라 기법은 경로 A-B가 시작점A에서 B로 가는 최단 경로라고 결정합니다.</string>
    <string name="Dijkstra47">다른 경로를 사용하는 경우에는 반드시 C를 경유해야 하지만, A-C의 가중치가 A-B의 가중치보다 크기 때문입니다.</string>
    <string name="Dijkstra48">이미 알고 있는 것처럼 이것은 모든 간선의 가중치가 0보다 큰 경우, 즉 그래프상에 마이너스 가중치가 존재하지 않는다는 조건하에서입니다.</string>
    <string name="Dijkstra49">알고리즘은 시작점A로부터 종점G까지의 최단 경로가 A-B-G이고 그 가중치가 3이라는 결론을 짓습니다. 앞서 설명한 것처럼 이 결과는 틀린 것입니다.</string>
    <string name="Dijkstra5">예를 들어 정점B의 경우 현재 있는 시작점 가중치가 0이므로 0+2=2가 됩니다. 동일한 방식으로 C의 가중치는 0+5=5가 됩니다.</string>
    <string name="Dijkstra52">참고로 위 그래프처럼…</string>
    <string name="Dijkstra53">"특정 경로를 지나는 가중치가 마이너스가 되는 '음의 폐로'를 포함하는 그래프에선…"</string>
    <string name="Dijkstra54">다익스트라 기법을 사용하면 최단 경로가 존재하지 않음에도 불구하고 잘못된 최단 경로를 찾아냅니다.</string>
    <string name="Dijkstra55">이와 같이 다익스트라 기법은 마이너스 가중치를 포함하는 그래프에선 사용할 수 없습니다.</string>
    <string name="Dijkstra56">반대로 다익스트라 기법은, 그래프에 마이너스 가중치가 존재하지 않는 경우에 벨만-포드법보다 더 적은 계산량으로 최단 경로를 구할 수 있습니다.</string>
    <string name="Dijkstra57">이것으로 다익스트라 기법에 대한 설명을 마칩니다.</string>
    <string name="Dijkstra6">계산한 결과가 현재 가중치보다 작으면 가중치를 새로운 값으로 변경합니다.</string>
    <string name="Dijkstra7">정점B, C의 현재 가중치는 무한대로 계산한 결과가 작습니다. 따라서 각각을 새로운 값으로 변경합니다.</string>
    <string name="Dijkstra8">후보 정점 중에서 가중치가 가장 작은 정점을 선택합니다. 여기선 정점B가 됩니다.</string>
    <string name="Dijkstra9">이 시점에서 선택한 정점B로 가는 경로 A-B는 시작점에서 정점B로 가는 최단 경로로 정해집니다.</string>
    <string name="DijkstraDescription">다익스트라 기법은 최단 경로를 효율적으로 찾아주는 알고리즘입니다. 이 항목은 모든 알고리즘을 구매 후에 학습할 수 있습니다.</string>
    <string name="Euclidean">유클리드 호제법</string>
    <string name="Euclidean0">유클리드 호제법은 두 수의 최대공약수를 구하는 알고리즘입니다.</string>
    <string name="Euclidean1">유클리드에 의해 기원전 300년경에 발견된 것으로 세계에서 가장 오래된 알고리즘으로 알려져 있습니다.</string>
    <string name="Euclidean10">A mod B는 A를 B로 나누었을 때의 나머지 C를 구합니다.</string>
    <string name="Euclidean11">구체적인 숫자를 사용한 연산 예를 보겠습니다.</string>
    <string name="Euclidean12">그러면 유클리드 호제법의 과정을 보도록 하겠습니다.</string>
    <string name="Euclidean13">먼저 큰 숫자를 작은 숫자로 나눈 나머지를 구합니다.</string>
    <string name="Euclidean14">즉, 큰 숫자와 작은 숫자로 mod 연산을 합니다.</string>
    <string name="Euclidean15">나눗셈의 결과 417이 나머지가 됩니다.</string>
    <string name="Euclidean16">이번에는 나눈 수 695와 나머지 417로 mod 연산을 합니다.</string>
    <string name="Euclidean17">그 결과 278이 나옵니다.</string>
    <string name="Euclidean18">동일한 계산을 반복합니다. 417과 287로 mod 연산을 합니다.</string>
    <string name="Euclidean19">139가 나옵니다.</string>
    <string name="Euclidean2">예로 1112와 695의 최대공약수를 계산해보도록 하겠습니다.</string>
    <string name="Euclidean20">278과 139로 mod 연산을 하면…</string>
    <string name="Euclidean21">0이 나옵니다.</string>
    <string name="Euclidean22">즉, 278은 139로 나누어지며 나머지가 없습니다.</string>
    <string name="Euclidean23">나머지가 0이 됐을 때 마지막 계산에서 나누는 수로 사용된 139가 1112와 695의 최대공약수가 됩니다.</string>
    <string name="Euclidean24">어떻게 유클리드 호제법으로 최대공약수를 구할 수 있는 걸까요? 그림을 통해 생각해보도록 하겠습니다.</string>
    <string name="Euclidean25">1112와 695를 각각 막대의 길이로 나타내봅니다.</string>
    <string name="Euclidean26">최대공약수를 n으로 해서 눈금을 나누어봅니다.</string>
    <string name="Euclidean27">최대공약수가 139인지 알고 있으므로 이해하기 쉽도록 1112는 8눈금, 695는 6눈금으로 표시했습니다.</string>
    <string name="Euclidean28">실제로는 각 막대를 몇 등분할 수 있는지 모릅니다.</string>
    <string name="Euclidean29">단, 1112와 695 모두 최대공약수 n의 배수인 것은 알고있습니다.</string>
    <string name="Euclidean3">일반적인 방법에선 두 개의 수를 소인수분해해서 …</string>
    <string name="Euclidean30">여기서 앞서 계산한 것처럼 큰 숫자를 작은 숫자로 나눈 나머지를 구합니다.</string>
    <string name="Euclidean31">417이라는 결과가 나옵니다. 그림을 통해 417도 n 눈금으로 정확히 표시할 수 있다는 것을 알 수 있습니다.</string>
    <string name="Euclidean32">동일한 방법으로 mod 연산을 반복합니다.</string>
    <string name="Euclidean35">695를 417로 나누면 나머지 278이 나옵니다.</string>
    <string name="Euclidean36">이 나머지 278도 n을 정수 배한 숫자로 동일한 최대공약수를 가집니다.</string>
    <string name="Euclidean37">계속해서 계산을 반복합니다.</string>
    <string name="Euclidean38">278은 139로 나누어지므로 나머지가 0이 됩니다.</string>
    <string name="Euclidean39">이때 최대공약수 n이 139라는 것을 알 수 있습니다.</string>
    <string name="Euclidean4">공통되는 소수를 최대공약수(GCD)로 구합니다.</string>
    <string name="Euclidean40">이와 같이 유클리드 호제법에선 나눗셈만 반복하면 최대공약수를 구할 수 있습니다.</string>
    <string name="Euclidean41">두 개의 숫자가 큰 수라도 정해진 순서로 계산하면 효율적으로 최대공약수를 구할 수 있는 것이 큰 장점입니다.</string>
    <string name="Euclidean42">이것으로 유클리드 호제법에 대한 설명을 마칩니다.</string>
    <string name="Euclidean5">1112와 695의 최대공약수는 139라는 것을 알 수 있습니다.</string>
    <string name="Euclidean6">하지만 이 방법에선 두 개의 수가 커질수록 소인수분해가 어려워집니다.</string>
    <string name="Euclidean7">유클리드 호제법에선 더 효율적으로 최대공약수를 구하는 것이 가능합니다.</string>
    <string name="Euclidean8">유클리드 호제법의 설명에 앞서 mod 연산에 대해 알아보겠습니다.</string>
    <string name="Euclidean9">mod 연산은 나눗셈의 나머지를 구하는 연산입니다.</string>
    <string name="ExperimentalModeTitle">실험</string>
    <string name="FewUnique">중첩</string>
    <string name="GetItemInfoFailed">아이템 정보를 갸져올 수 없습니다. 인터넷에 연결돼 있는지 확인해주세요.</string>
    <string name="GraphSearchSection">그래프 탐색</string>
    <string name="Hanoi">하노이의 탑</string>
    <string name="Hanoi0">하노이의 탑은 원반을 이동해서 탑을 쌓는 게임입니다.</string>
    <string name="Hanoi1">그림에선 A, B, C 세 개의 막대가 있으며 A 막대에 2개의 원반이 꽂혀있습니다.</string>
    <string name="Hanoi101">이상의 조건을 바탕으로 실제로 원반을 움직이는 예를 보겠습니다.</string>
    <string name="Hanoi102">앞서 본 것과 동일한 방식으로 B의 두 개를 C로 이동합니다.</string>
    <string name="Hanoi15">작은 원반이 가장 위에 있으므로 B로 이동할 수 있습니다.</string>
    <string name="Hanoi16">큰 원반을 C로 이동합니다.</string>
    <string name="Hanoi17">작은 원반을 C로 이동하면 게임이 종료됩니다. 원반이 두 개인 경우 목표에 도달할 수 있는 것을 확인했습니다.</string>
    <string name="Hanoi18">원반이 세 개인 경우는 어떨까요?</string>
    <string name="Hanoi19">가장 큰 원반을 무시하고 나머지 원반을 B로 이동하는 방법을 생각해보겠습니다.</string>
    <string name="Hanoi2">A의 원반을 순서를 유지한채 C로 이동하는 것이 게임의 목적입니다.</string>
    <string name="Hanoi20">나머지 원반(가장 큰 원반을 제외한)은 앞서 본 두 개의 원반 이동 방식과 동일한 방식을 사용하면 B로 이동할 수 있습니다.</string>
    <string name="Hanoi21">여기서 가장 큰 원반을 C로 이동합니다.</string>
    <string name="Hanoi22">이동을 완료했습니다. 원반이 세 개인 경우라도 목표를 달성할 수 있습니다.</string>
    <string name="Hanoi23">사실은 이 게임은 원반이 몇 장이라도 목표를 달성할 수 있습니다.</string>
    <string name="Hanoi24">이것을 수학적 귀납법을 사용해서 증명해보겠습니다.</string>
    <string name="Hanoi25">원반이 한 개일 때 목표를 달성합니다.</string>
    <string name="Hanoi27">원반이 n개일 때 목표를 달성할 수 있다고 가정합니다.</string>
    <string name="Hanoi29">n+1 개를 이동하는 경우를 생각해보겠습니다.</string>
    <string name="Hanoi30">가장 큰 원반을 무시합니다.</string>
    <string name="Hanoi31">가정에 의해 n 개라면 이동할 수 있으므로 n 개를 B로 이동합니다.</string>
    <string name="Hanoi32">가장 큰 원반을 C로 이동합니다.</string>
    <string name="Hanoi33">B에 있는 n 개를 C로 이동합니다. 이것으로 이동이 완료됩니다.</string>
    <string name="Hanoi34">수학적 귀납법을 통해 원반이 몇 개이든 목표를 달성할 수 있다는 것이 증명됐습니다.</string>
    <string name="Hanoi35">하노이 탑의 해법에 대해 생각해봅시다.</string>
    <string name="Hanoi36">n 개 원반의 하노이 탑 문제는 n-1 개의 하노이 탑을 해결하는 방식을 이용하면 되는 것입니다.</string>
    <string name="Hanoi37">이 n-1 개의 하노이 탑을 풀려면 n-2 개의 하노이 탑을 해결하는 방식을 이용하면 됩니다. 이것을 계속하다 보면 최종적으로 한 개의 원반을 푸는 방법에까지 이릅니다.</string>
    <string name="Hanoi38">이 재귀적 접근법은 다양한 알고리즘에 사용되고 있으며 재귀적 알고리즘이라고 합니다.</string>
    <string name="Hanoi39">이것으로 하노이의 탑에 대한 설명을 마치겠습니다.</string>
    <string name="Hanoi4">원반의 이동에는 다음 두 가지 조건이 있습니다. 첫 번째 조건은, 한 번에 한 개의 원반만 이동할 수 있다는 것입니다.</string>
    <string name="Hanoi5">이처럼 한 개를 움직이는 것은 문제가 없지만…</string>
    <string name="Hanoi6">그림처럼 2개를 동시에 움직여서는 안 됩니다.</string>
    <string name="Hanoi9">두 번째 조건은, 작은 원반의 위에 그것보다 큰 원반을 둘 수 없습니다.</string>
    <string name="Hash">해시 테이블</string>
    <string name="Hash0">해시 테이블은 데이터 구조의 하나입니다.</string>
    <string name="Hash1">해시 테이블은 키(Key)와 값(Value)이 한 쌍으로 구성된 데이터를 저장합니다.</string>
    <string name="Hash10">2번 상자에 저장된 키도 ‘Ally’가 아닙니다</string>
    <string name="Hash11">3번 상자에 저장된 키도 ‘Ally’가 아닙니다</string>
    <string name="Hash12">4번 상자에 저장된 데이터의 키가 ‘Ally’와 일치합니다.</string>
    <string name="Hash13">대응되는 값을 꺼내면 Ally의 성별이 여성(F)이라는 것을 알 수 있습니다.</string>
    <string name="Hash14">이와 같이 선형 탐색은 데이터량에 비례해서 계산 시간이 늘어납니다.</string>
    <string name="Hash15">배열 탐색에 시간이 걸리므로 탐색에는 적합하지 않은 구조라는 것을 알 수 있습니다.</string>
    <string name="Hash16">이 문제를 해결해주는 것이 해시 테이블입니다.</string>
    <string name="Hash17">먼저 데이터를 저장하기 위한 배열을 준비합니다.</string>
    <string name="Hash18">준비됐으면 데이터를 추가해보겠습니다.</string>
    <string name="Hash19">Joe의 데이터를 추가하는 경우입니다.</string>
    <string name="Hash2">여기선 이름을 키로, 성별을 값으로 저장하고 있습니다.</string>
    <string name="Hash20">해시 함수를 이용해서 키의 해시값을 계산합니다.</string>
    <string name="Hash21">해시 함수에 대해선 이 앱에서 자세히 설명하고 있습니다. 데이터를 고정된 길이의 수치로 변환하는 함수입니다.</string>
    <string name="Hash22">구한 해시값을 배열의 상자 수인 5로 나누어 나머지를 구합니다.</string>
    <string name="Hash23">나머지를 구하는 연산을 ‘mod 연산’이라고 합니다.</string>
    <string name="Hash24">mod 연산 결과 3이라는 숫자가 나옵니다.</string>
    <string name="Hash25">구한 수와 동일한 배열의 3번 상자에 Joe의 데이터를 저장합니다.</string>
    <string name="Hash26">이 처리를 반복해서 다른 데이터도 하나씩 채워갑니다.</string>
    <string name="Hash27">Sue의 데이터를 저정하려면...</string>
    <string name="Hash28">키의 해시값을 구해서 배열의 상자 수인 5로 mod 연산을 합니다. 결과는 1이 나옵니다.</string>
    <string name="Hash29">배열의 1번 상장에 Sue의 데이터를 저장합니다.</string>
    <string name="Hash3">예를 들어 그림의 데이터를 배열에 저장하는 경우를 생각해보겠습니다.</string>
    <string name="Hash30">Dan의 데이터를 저장하려면…</string>
    <string name="Hash31">키의 해시값을 구해서 배열의 상자 수인 5로 mod 연산을 합니다. 결과는 4가 나옵니다.</string>
    <string name="Hash32">배열의 4번 상자에 Nell의 데이터를 저장합니다.</string>
    <string name="Hash33">Nell의 데이터를 저장하려면…</string>
    <string name="Hash34">키의 해시값을 구해서 배열의 상자 수인 5로 mod 연산을 합니다. 결과는 1이 나옵니다.</string>
    <string name="Hash35">배열의 1번 상자에 Nell의 데이터를 저장합니다.</string>
    <string name="Hash36">1번 상자에는 이미 Sue의 데이터가 저장돼 있습니다. 이런 경우에는…</string>
    <string name="Hash37">리스트 구조로 기존 데이터와 연결합니다.</string>
    <string name="Hash38">"해시 테이블에는 몇 가지 종류가 있으며 리스트를 이용하는 방법을 '연쇄법'이라고 합니다."</string>
    <string name="Hash39">Ally의 데이터를 저장하기 위해서…</string>
    <string name="Hash4">6개 상자로 이루어진 배열을 준비해서 데이터를 저장합니다.</string>
    <string name="Hash40">키의 해시값을 구해서 배열의 상자 수인 5로 mod 연산을 합니다. 결과는 3이 나옵니다.</string>
    <string name="Hash41">배열의 3번 상자에는 ‘Joe’의 데이터가 이미 있으므로 ‘Ally’ 를 리스트로 연결합니다.</string>
    <string name="Hash42">Bob의 데이터를 저장하기 위해서…</string>
    <string name="Hash43">키의 해시값을 구해서 배열의 상자 수인 5로 mod 연산을 합니다. 결과는 3이 나옵니다.</string>
    <string name="Hash44">배열의 3번 상자에는 Joe와 Allye의 데이터가 있으므로 ‘Bob’ 를 리스트로 연결합니다.</string>
    <string name="Hash45">모든 데이터를 저장하면 해시 테이블이 완성됩니다.</string>
    <string name="Hash46">Dan의 성별을 찾는 경우를 생각해보겠습니다.</string>
    <string name="Hash47">Dan이 배열의 몇 번째 상자에 저장돼 있는지 알려면…</string>
    <string name="Hash48">키인 Dan의 해시값을 구해서 배열의 상자 수인 5로 mod 연산을 합니다. 결과는 4가 나옵니다.</string>
    <string name="Hash49">배열의 4번 상장에 저장된 데이터의 키가 Dan과 일치합니다.</string>
    <string name="Hash5">여기서 Ally의 성별을 알고싶다고 가정해봅시다.</string>
    <string name="Hash50">대응되는 값을 꺼내면 Dan의 성별이 남성(M)이라는 것을 알 수 있습니다.</string>
    <string name="Hash51">Ally의 성별을 찾는 경우를 생각해보겠습니다.</string>
    <string name="Hash52">Ally가 배열의 몇 번째 상자에 저장돼 있는지 알기 위해서…</string>
    <string name="Hash53">키인 Ally의 해시값을 구해서 배열의 상자 수인 5로 mod 연산을 합니다. 결과는 3이 나옵니다.</string>
    <string name="Hash54">배열의 3번 상자에는 Joe가 있으며 Ally가 아닙니다.</string>
    <string name="Hash55">Joe의 데이터를 선두로 하는 리스트를 선형 탐색합니다.</string>
    <string name="Hash56">키를 Ally로 하는 데이터를 발견했습니다.</string>
    <string name="Hash57">대응하는 값을 추출하면 ‘Ally’의 성별이 여성(F)인 것을 알 수 있습니다.</string>
    <string name="Hash58">해시 테이블은 해시 함수를 이용해서 배열 내의 특정 데이터에 빠르게 접근할 수 있습니다.</string>
    <string name="Hash59">한편 해시값이 충돌할 때는 리스트를 이용하고 있어서 저장할 데이터 수가 정해져있지 않더라도 유연하게 대응할 수 있습니다.</string>
    <string name="Hash6">Ally가 배열의 몇 번째 상자에 저장돼 있는지 모릅니다.</string>
    <string name="Hash60">해시 테이블에 사용하는 배열의 크기는 너무 작으면 충돌이 많아지고, 선형 탐색의 빈도가 높아지게 됩니다.</string>
    <string name="Hash61">반대로 크기가 너무 크면 데이터가 없는 상자가 많아져서 메모리를 낭비하게 됩니다.</string>
    <string name="Hash62">데이터의 유연한 저장과 빠른 접근이 가능한 해시 테이블은 프로그래밍 언어의 연관 배열(associative array) 등에 사용되고 있습니다.</string>
    <string name="Hash63">"해시 테이블에는 몇 가지 종류가 있으며 리스트를 이용하는 방법을 '연쇄법'이라고 합니다."</string>
    <string name="Hash7">따라서 앞에서부터 차례대로 확인해야 합니다. 이 처리를 ‘선형 탐색’이라고 합니다</string>
    <string name="Hash8">0번 상자에 저장된 데이터의 키는 ‘Joe’이며 ‘Ally’가 아닙니다.</string>
    <string name="Hash9">1번 상자에 저장된 키도 ‘Ally’가 아닙니다</string>
    <string name="HashFunction">해시 함수</string>
    <string name="HashFunction0">해시 함수란 주어진 데이터를 고정 길이의 불규칙적인 숫자로 변환하는 함수입니다.</string>
    <string name="HashFunction1">믹서기를 생각하면 이해하기 쉽습니다.</string>
    <string name="HashFunction10">이런 내용을 전제로 해시 함수의 특징을 보도록 하겠습니다.</string>
    <string name="HashFunction11">첫 번째 특징은 출력하는 값의 데이터 길이가 바뀌지 않는다는 것입니다.</string>
    <string name="HashFunction12">출력되는 데이터의 길이는 함수에 따라 다르지만, 예를 들어 SHA-1에선 20바이트 고정됩니다.</string>
    <string name="HashFunction13">매우 큰 데이터를 입력해도 출력되는 해시값의 데이터 길이는 바뀌지 않습니다.</string>
    <string name="HashFunction16">마찬가지로 아무리 작은 데이터를 입력해도 해시값의 데이터 길이는 같습니다.</string>
    <string name="HashFunction19">두 번째 특징은 입력이 동일하면 출력도 반드시 동일하다는 것입니다.</string>
    <string name="HashFunction2">데이터를 해시 함수에 넣으면…</string>
    <string name="HashFunction25">세 번째 특징은, 비슷한 데이터를 입력해도 1비트라도 다른 데이터라면 출력이 크게 달라진다는 점입니다. 비슷한 데이터를 입력한다고 해서 해시값도 비슷해지는 것은 아닙니다.</string>
    <string name="HashFunction3">불규칙한 숫자를 출력합니다.</string>
    <string name="HashFunction31">세 번째 특징은, 비슷한 데이터를 입력한다고 해서 해시값도 비슷해지는 것은 아니라는 것입니다.</string>
    <string name="HashFunction32">네 번째 특징은, 전혀 다른 데이터를 입력해도 동일한 해시값이 나올 수 있는 경우가 낮은 확률이지만 존재한다는 것입니다.</string>
    <string name="HashFunction38">이것을 ‘해시값 충돌’이라고 합니다.</string>
    <string name="HashFunction39">다섯 번째 특징은, 해시값으로부터 원 데이터를 역산하는 것이 사실상 불가능하다는 것입니다.</string>
    <string name="HashFunction4">해시 함수는 데이터를 분리하는 기계라고 생각하면 이해하기 쉽습니다.</string>
    <string name="HashFunction41">데이터 입력과 출력의 흐름이 단방향으로 이루어지며 이것은 ‘암호화’와 크게 다른 점입니다.</string>
    <string name="HashFunction43">마지막 특징으로 해시값을 결정하는 계산이 비교적 간단하다는 것을 들 수 있습니다.</string>
    <string name="HashFunction46">해시 함수의 알고리즘에는 몇 가지가 있지만, 현재는 SHA-2가 일반적으로 사용됩니다.</string>
    <string name="HashFunction47">해시 함수는 다양한 상황에서 사용됩니다.</string>
    <string name="HashFunction48">"이 앱에선 해시 함수의 이용 예로 '메시지 인증 코드'와 '해시 테이블'에 대해 자세히 다루고 있습니다."</string>
    <string name="HashFunction49">이것으로 해시 함수에 대한 설명을 마칩니다.</string>
    <string name="HashFunction5">출력된 불규칙한 숫자를 ‘해시값’이라고 합니다.</string>
    <string name="HashFunction6">해시값은 숫자지만 16진수로 표기하는 경우가 많습니다.</string>
    <string name="HashFunction7">컴퓨터는 모든 데이터를 0과 1로 이루어진 2진수로 관리하고 있습니다.</string>
    <string name="HashFunction8">해시값도 데이터의 일종이므로, 표기는 16진수로 하지만 내부에선 2진수로 관리됩니다.</string>
    <string name="HashFunction9">실제로는 해시 함수는 컴퓨터 내부에서 수치 계산을 하고 있는 것입니다.</string>
    <string name="Heap">힙</string>
    <string name="Heap0">힙(Heap)은 트리 구조의 하나로 ‘우선순위 큐(priority queue)’를 구현할 때 사용됩니다.</string>
    <string name="Heap1">우선순위 큐는 데이터 구조의 하나입니다.</string>
    <string name="Heap10">부모6 > 자식5이므로 숫자를 교환했습니다.</string>
    <string name="Heap11">이런 처리를 교환이 발생하지 않을 때까지 반복합니다.</string>
    <string name="Heap12">부모1 &lt; 자식5이므로 부모의 숫자가 작습니다. 따라서 교환이 발생하지 않습니다.</string>
    <string name="Heap13">이것으로 힙에 숫자 추가가 완료됩니다.</string>
    <string name="Heap14">힙에서 숫자를 꺼낼 때는 가장 위에 있는 숫자가 추출됩니다.</string>
    <string name="Heap15">힙에서 숫자를 꺼낼 때는 가장 위에 있는 숫자가 추출됩니다.</string>
    <string name="Heap16">가장 위에 있는 숫자가 없어졌으므로 힙의 구조를 다시 정리해야 합니다.</string>
    <string name="Heap17">가장 후미에 있는 숫자를 가장 위로 이동합니다.</string>
    <string name="Heap18">부모 숫자보다 자식 숫자가 작은 경우는 자식의 좌우에 있는 숫자 중 더 작은 쪽과 교환합니다.</string>
    <string name="Heap19">부모6 > 자식(우)5 > 자식(좌)3 이므로 왼쪽 자식과 부모를 교환합니다.</string>
    <string name="Heap2">우선순위 큐에는 데이터를 자유롭게 추가할 수 있습니다.</string>
    <string name="Heap20">이 처리를 교환이 발생하지 않을 때까지 반복합니다.</string>
    <string name="Heap22">자식(우)8 > 부모6 > 자식(좌)4 이므로 왼쪽 자식과 부모를 교환합니다.</string>
    <string name="Heap23">이것으로 숫자 추출 처리가 완료됐습니다.</string>
    <string name="Heap24">이처럼 힙을 사용하면 최솟값을 빠르게 추출할 수 있습니다.</string>
    <string name="Heap25">단, 도중에 있는 데이터를 추출할 수는 없습니다.</string>
    <string name="Heap26">힙은 우선순위 큐나 다익스트라 기법 등에서도 사용되고 있습니다.</string>
    <string name="Heap27">이것으로 힙에 대한 설명을 마칩니다.</string>
    <string name="Heap3">반면 데이터를 추출할 때는 최솟값부터 순서대로 선택됩니다.</string>
    <string name="Heap4">추가는 자유롭게 하고 추출할 때는 작은 값부터 꺼내는 것이 우선순위 큐입니다.</string>
    <string name="Heap5">그러면 힙 구조를 보도록 하겠습니다.</string>
    <string name="Heap6">자식 노드의 숫자는 반드시 부모의 숫자보다 커야한다는 규칙이 있습니다.</string>
    <string name="Heap7">힙에 숫자를 추가하는 경우를 보겠습니다.</string>
    <string name="Heap8">추가되는 수는 먼저 가장 후미에 저장됩니다.</string>
    <string name="Heap9">부모의 숫자가 큰 때는 부모와 자식을 교환합니다.</string>
    <string name="HeapDescription">힙(heap)은 최솟값을 빠르게 찾기 위한 데이터 구조입니다. 이 항목은 모든 알고리즘을 구매 후에 학습할 수 있습니다.</string>
    <string name="HeapSort">힙(heap) 정렬</string>
    <string name="HeapSort0">힙 정렬은 수열을 정렬하는 알고리즘 중 하나로, 힙이라는 데이터 구조를 사용하는 것이 특징입니다.</string>
    <string name="HeapSort1">처음에는 힙에 모든 숫자를 저장합니다. 힙은 내림차순으로 구축합니다.</string>
    <string name="HeapSort10">구체적으로는 힙상의 각 요소(노드)와 배열 간에…</string>
    <string name="HeapSort105">참고로 힙 구축에는 더 효율적인 방법이 있지만 여기서는 간단한 방법을 사용하고 있습니다.</string>
    <string name="HeapSort11">그림과 같은 대응 관계를 만듭니다.</string>
    <string name="HeapSort15">보면 알겠지만 배열 안에 힙을 무리해서 구겨 넣은 상태라고 할 수 있습니다.</string>
    <string name="HeapSort16">그러면 실제로 정렬 작업을 해보도록 하겠습니다.</string>
    <string name="HeapSort17">여기선 이해를 돕기 위해 트리 구조의 힙을 표시한 상태로 두겠습니다.</string>
    <string name="HeapSort18">앞서 본 것처럼 힙에 숫자를 넣는 작업부터 시작하겠습니다.</string>
    <string name="HeapSort20">트리 구조의 힙 내에서 숫자가 바뀌면 배열 내에서도 동일하게 숫자를 교체합니다.</string>
    <string name="HeapSort21">힙에 모든 숫자를 저장했습니다. 동시에 배열이 내림차순으로 정리됐습니다.</string>
    <string name="HeapSort22">다음은 힙에 저장한 숫자를 하나씩 꺼냅니다.</string>
    <string name="HeapSort23">내림차순 힙은 큰 것부터 순서대로 데이터가 추출됩니다.</string>
    <string name="HeapSort24">배열 내에선 선두에 있는 숫자가 힙 내에서 가장 큰 숫자가 됩니다.</string>
    <string name="HeapSort25">배열의 선두 숫자를 힙의 마지막 요소에 대응하는 배열과 바꾸면 작업이 완료됩니다.</string>
    <string name="HeapSort26">힙의 구조가 유지되도록 정리합니다.</string>
    <string name="HeapSort27">이 작업을 모든 숫자가 작업 완료 상태가 될 때까지 반복합니다.</string>
    <string name="HeapSort28">정렬을 완료</string>
    <string name="HeapSort29">이것으로 힙 정렬에 대한 설명을 마칩니다.</string>
    <string name="HeapSort3">힙에 모든 숫자를 저장했습니다.</string>
    <string name="HeapSort4">힙에 저장된 숫자를 하나씩 꺼냅니다.</string>
    <string name="HeapSort5">내림차순 힙은 큰 것부터 순서대로 데이터를 추출하는 성질이 있으므로 꺼낸 숫자를 역순으로 나열하면 정렬이 완료됩니다.</string>
    <string name="HeapSort7">모든 숫자를 힙에서 꺼내면 정령이 완료됩니다.</string>
    <string name="HeapSort8">여기서는 이 배열과 별도로 힙이라는 데이터 구조를 준비했지만…</string>
    <string name="HeapSort9">보통은 수열이 저장돼 있는 배열 자체에 힙을 넣어서 배열상에서 숫자를 교체해가며 정렬합니다.</string>
    <string name="Huffman">허프만 부호</string>
    <string name="Huffman0">허프만 부호는 데이터를 부호화하는 알고리즘입니다.</string>
    <string name="Huffman1">JPEG이나 ZIP 등의 이미지나 파일 압축에 사용됩니다.</string>
    <string name="Huffman10">단순한 예로 그림처럼 부호화 규칙을 정해보았습니다. 하나의 문자를 2비트로 표현하고 있습니다.</string>
    <string name="Huffman100">"C or D'를 하나의 문자로 생각하고 동일한 작업을 반복합니다."</string>
    <string name="Huffman101">"A, B, 'C or D' 의 세 개 중에서 등장 빈도가 낮은 순으로 두 개의 문자를 찾습니다."</string>
    <string name="Huffman102" formatted="false">이 경우 A(35%)와 B(25%)가 됩니다.</string>
    <string name="Huffman103">두 개의 문자를 연결해서 트리 구조를 만듭니다.</string>
    <string name="Huffman104">"두 개의 문자를 'A or B'로 합체하고 등장 빈도를 더합니다."</string>
    <string name="Huffman105">"A or B'를 하나의 문자열로 생각합니다."</string>
    <string name="Huffman106">"동일하게 등장 빈도가 작은 두 개의 문자를 선택하는데, 이번에는 마지막에 남은 'A or B'와 'C or D' 두 개를 연결하게 됩니다."</string>
    <string name="Huffman107">양쪽을 연결해서 트리 구조를 만듭니다.</string>
    <string name="Huffman108">"모든 문자가 'A or B or C or D'로 하나의 문자가 됐습니다. 등장 빈도는 당연히 100%가 됩니다."</string>
    <string name="Huffman109">이것으로 허프만 부호를 구하기 위한 트리 구조가 완성됐습니다.</string>
    <string name="Huffman11">규칙에 따라 ABAABACD를 부호화해보았습니다. 그 결과 데이터의 크기가 16비트가 되면서 괘 많이 줄어듭니다.</string>
    <string name="Huffman110">각 문자의 등장 빈도를 다시 표시했습니다.</string>
    <string name="Huffman111">0과 1인 부호를 상하로 연결된 각 가지에 할당합니다.</string>
    <string name="Huffman112">다음은 트리의 뿌리로부터 각 문자를 따라가면서 대응하는 문자를 결정합니다.</string>
    <string name="Huffman113">A인 경우 할당된 부호는 00이 됩니다.</string>
    <string name="Huffman114">B인 경우 할당된 부호는 01이 됩니다.</string>
    <string name="Huffman115">C인 경우 할당된 부호는 10이 됩니다.</string>
    <string name="Huffman116">D인 경우 할당된 부호는 11이 됩니다.</string>
    <string name="Huffman117">이것으로 허프먼에 의한 부호화를 완료했습니다.</string>
    <string name="Huffman118">앞의 예와 트리 구조가 다르며, 문자의 등장 빈도에 큰 차이가 없어서 모든 문자가 2비트의 부호로 표현됩니다.</string>
    <string name="Huffman119">예를 들어 등장 빈도가 가장 높은 A를 비트로 표현하기 위해 C와 D를 3비트로 표현하려고 해도…</string>
    <string name="Huffman12">물론 아무렇게나 정한 규칙이어서 문자열을 전송받는 쪽에도 부호화 규칙을 전달할 필요가 있습니다.</string>
    <string name="Huffman120" formatted="false">"C or D'의 등장 빈도(40%)는 A의 등장 빈도(35%)보다 높아서 부호화 효율이 나빠집니다."</string>
    <string name="Huffman121">이처럼 허프만 부호는 문자의 등장 빈도에 따라 효율이 좋은 부호화를 쉽게 구현할 수 있다는 것을 알 수 있습니다.</string>
    <string name="Huffman122">이것으로 허프만 부호에 대한 설명을 마칩니다.</string>
    <string name="Huffman13">편의상 여기선 규칙 전달에 필요한 통신량을 고려하고 있지 않습니다.</string>
    <string name="Huffman14">문자열을 받은 쪽이 부호를 복호화하려면…</string>
    <string name="Huffman15">부호를 두 문자 단위로 잘라서…</string>
    <string name="Huffman16">"각각을 규칙에 맞게 복원하면 원래 문자열인 'ABAABACD'를 얻을 수 있습니다."</string>
    <string name="Huffman17">"ABAABACD'라는 문자열을 더 작게 부호화하는 방법을 생각해봅시다."</string>
    <string name="Huffman18">앞의 규칙에선 하나의 문자열을 2비트로 표현했지만…</string>
    <string name="Huffman19">A와 B를 1비트로 표현해서 더 작게 부호화할 수 있을 것 같습니다.</string>
    <string name="Huffman2">"예로 'ABAABACD'라는 문자열을 네트워크를 통해 전송하는 경우를 생각해보겠습니다."</string>
    <string name="Huffman20">"참고로 'ABAABACD'라는 문자열에선 C와 D보다 A와 B가 더 많이 사용되고 있습니다."</string>
    <string name="Huffman21">이 사실로부터 C와 D가 아닌 A와 B를 1비트로 표현하는 것이 좋아보입니다.</string>
    <string name="Huffman22">"규칙에 따라 'ABAABACD'를 부호화했습니다. 그 결과 데이터의 크기가 10비트가 되면서 크기가 더 줄어듭니다."</string>
    <string name="Huffman23">부호를 받은 쪽이 부호를 문자열로 복원하려면…</string>
    <string name="Huffman24">각각을 규칙에 맞게 복원하면 되지만…</string>
    <string name="Huffman25">예를 들어 10이라는 부호는 BA는 물론 C로도 표현할 수 있습니다.</string>
    <string name="Huffman26">따라서 틀린 문자열이 복원돼 버립니다.</string>
    <string name="Huffman27">이외에도 다양한 문자열이 복원될 수 있어서 해당 문자열이 정확하다고 확정지을 수가 없습니다.</string>
    <string name="Huffman28">"이처럼 부호를 보더라도 원래 문자열을 확정지을 수 없는 것을 '유일 복호 불가능'이라고 합니다."</string>
    <string name="Huffman29">다른 한 가지 예를 보겠습니다. 편의상 A와 B, 두 개의 문자가 그림처럼 복호화된다고 가정해보겠습니다.</string>
    <string name="Huffman3">데이터는 2진수(0과 1로)로 부호화해서 전송됩니다.</string>
    <string name="Huffman30">이 부호화 규칙에서 000001이라는 부호가 주어진 경우의 복호화 과정을 생각해보겠습니다.</string>
    <string name="Huffman31">복호화를 위해 선두의 숫자부터 차례대로 보겠습니다.</string>
    <string name="Huffman32">첫 숫자가 0이지만 이것만으로는 A를 의미하는지 B의 일부를 의미하는지 판단할 수 없습니다.</string>
    <string name="Huffman33">두 번째 문자까지의 숫자가 00이지만 AA를 의미하는지 B의 일부를 의미하는지 판단할 수 없습니다.</string>
    <string name="Huffman34">계속해서 세 번째 숫자까지 000이지만 AAA를 의미하는지 B의 일부를 의미하는지 판단할 수 없습니다.</string>
    <string name="Huffman35">동일하게 네 번째 숫자까지도 판단이 어렵습니다.</string>
    <string name="Huffman36">다섯 번째도 마찬가집니다.</string>
    <string name="Huffman37">최종적으로 여섯 번째 숫자 1을 보고서야 선두 문자 0이 A를 의미하고 그 뒤의 00001가 B라는 것을 알 수 있습니다.</string>
    <string name="Huffman38">000001이라는 숫자는 AB라는 문자열로 한 번에 복원할 수 있습니다. 이 점에선 문제가 없습니다.</string>
    <string name="Huffman39">"변환표에 있는 부호가 등장하면 즉시 원래 문자를 결정할 수 있는 것을 '순간 부호'라고 하지만…"</string>
    <string name="Huffman4">예를 들어 ASCII(아스키)라는 문자 코드에선 A, B, C, D 각각의 문자가 그림처럼 부호화됩니다.</string>
    <string name="Huffman40">"이 예처럼 더 뒤에 있는 문자를 확인하지 않으면 원래 문자를 판단할 수 없는 것은 '순간 부호'가 아닙니다."</string>
    <string name="Huffman41">따라서 부호를 복호화하려면 시간이 걸립니다.</string>
    <string name="Huffman42">"효율이 좋은 부호화, 복호화를 위해서는 '유일 복호 가능' 그리고 '순간 부호'인 것이 좋습니다."</string>
    <string name="Huffman43">예로 본 그림의 두 가지 부호화 규칙에 문제가 있는지 확인해보겠습니다.</string>
    <string name="Huffman44">첫 번째 부호화 규칙을 가시화해보면…</string>
    <string name="Huffman45">특정 부호가 주어진 경우 첫 번째 문자가 0이면 A로 확정합니다.</string>
    <string name="Huffman46">하지만 1이면 B인 경우와 C 또는 D의 일부일 가능성이 있습니다.</string>
    <string name="Huffman47">마찬가지로 두 번째 부호화 규칙도 가시화해보겠습니다.</string>
    <string name="Huffman48">특정 부호가 주어진 경우 첫 번째 문자는 0이 될 수밖에 없습니다.</string>
    <string name="Huffman49">하지만 이 0이 A일 수도 있고 B의 일부일 수도 있습니다.</string>
    <string name="Huffman5">ASCII에선 하나의 문자가 8비트로 표현됩니다.</string>
    <string name="Huffman50">"유일 복호 가능이면서 순간 부호이려면 '어떤 부호도 다른 부호의 선두에 포하돼서는 안 된다'는 것이 전제가 돼야 합니다."</string>
    <string name="Huffman51">지금까지의 두 예에선 이것을 만족하고 있지 않았습니다.</string>
    <string name="Huffman52">허프먼 부호는 유일 복호 가능이면서 순간 부호인 부호를 간단히 찾아내는 알고리즘입니다.</string>
    <string name="Huffman53">실제로 허프먼 부호로 부호화하는 과정을 보겠습니다.</string>
    <string name="Huffman54">허프먼 부호는 유일 복호 가능이면서 순간 부호입니다.</string>
    <string name="Huffman55">먼저 각 문자의 등장 빈도를 계산합니다. ABAABACD의 경우 그림의 비율이 됩니다.</string>
    <string name="Huffman56">다음은 사용된 문자를 등장 빈도가 높은 순으로 정렬합니다. 이 예에선 ABCD 순입니다.</string>
    <string name="Huffman57">다음은 등장 빈도가 낮은 순으로 두 개의 문자를 찾습니다.</string>
    <string name="Huffman58" formatted="false">이 예에선 C(12.5%)와 D(12.5%)가 됩니다.</string>
    <string name="Huffman59">두 개의 문자를 연결해서 트리 구조를 만듭니다.</string>
    <string name="Huffman6">"ASCII에 의해 'ABAABACD'라는 문자열을 부호화해보았습니다. 그 결과 64비트가 됩니다."</string>
    <string name="Huffman60">"두 개의 문자를 'C or D'로 합체해서 등장 빈도를 더합니다."</string>
    <string name="Huffman61">"C or D'를 하나의 문자로 생각하고 동일한 작업을 반복합니다."</string>
    <string name="Huffman62">"A, B, 'C or D' 의 세 개 중에서 등장 빈도가 낮은 순으로 두 개의 문자를 찾습니다."</string>
    <string name="Huffman63" formatted="false">"여기선 B(25%)와 'C or D'(25%)가 됩니다."</string>
    <string name="Huffman64">두 개의 문자를 연결해서 트리 구</string>
    <string name="Huffman65">"두 개의 문자를 'B or C or D'로 합체하고 등장 빈도를 더합니다."</string>
    <string name="Huffman66">"B or C or D'를 하나의 문자열로 간주하겠습니다."</string>
    <string name="Huffman67">"동일하게 등장 빈도가 작은 두 개의 문자를 선택하는데, 이번에는 마지막에 남은 A와 'B or C or D' 두 개를 연결하게 됩니다."</string>
    <string name="Huffman68">양쪽을 연결해서 트리 구조를 만듭니다.</string>
    <string name="Huffman69">"모든 문자가 'A or B or C or D'로 하나의 문자가 됐습니다. 등장 빈도는 당연히 100%가 됩니다."</string>
    <string name="Huffman7">통신량을 줄이기 위해 문자열을 64비트보다 작게 만드는 방법을 생각해보겠습니다.</string>
    <string name="Huffman70">이것으로 허프먼 부호를 구하기 위한 트리 구조가 완성됐습니다.</string>
    <string name="Huffman71">각 문자의 등장 빈도를 다시 표시했습니다.</string>
    <string name="Huffman72">다음은 0과 1을 이용한 부호화를 해보겠습니다.</string>
    <string name="Huffman73">0과 1의 부호를, 상하로 연결하는 가지에 각각 할당합니다.</string>
    <string name="Huffman74">0과 1의 할당은 역순이어도 상관 없습니다. 단, 위쪽 가지를 1이라고 정하면 도중에 할당 방법을 변경할 수는 없습니다.</string>
    <string name="Huffman75">모든 부호를 할당했습니다.</string>
    <string name="Huffman76">다음은 트리의 뿌리로부터 각 문자를 따라가면서 대응하는 문자를 결정합니다.</string>
    <string name="Huffman77">A인 경우…</string>
    <string name="Huffman78">할당된 부호는 0이 됩니다.</string>
    <string name="Huffman79">B인 경우…</string>
    <string name="Huffman8">ASCII는 대부분의 문자를 구분해서 관리하기 위해 하나의 문자를 8비트로 표현하고 있습니다.</string>
    <string name="Huffman80">할당된 부호는 10이 됩니다.</string>
    <string name="Huffman81">C인 경우…</string>
    <string name="Huffman82">할당된 부호는 110이 됩니다.</string>
    <string name="Huffman83">D인 경우…</string>
    <string name="Huffman84">할당된 부호는 111이 됩니다.</string>
    <string name="Huffman85">이것으로 허프먼 부호에 의한 부호화가 완료됐습니다.</string>
    <string name="Huffman86">이 부호화 규칙을 이용해서 ABAABACD라는 문자열을 부호화하면 됩니다.</string>
    <string name="Huffman87">"어떤 부호도 다른 부호의 선두에 포함돼서는 안 된다' 조건은 트리 구조이기 때문에 보장됩니다."</string>
    <string name="Huffman88">따라서 유일 복화 가능이면서 순간 부호가 됩니다.</string>
    <string name="Huffman89">또한, 등장 빈도가 높은 문자일 수록 비트 수가 작은 부호가 할당되므로 부호화 효율이 좋다는 것을 알 수 있습니다.</string>
    <string name="Huffman9">"하지만 'ABAABACD'라는 문자열에선 단 네 개의 문자만 사용되고 있습니다. 이 문자들이 구분될 수 있도록 부호화하면 됩니다."</string>
    <string name="Huffman90" formatted="false">"구체적으로는 이 예의 경우 A의 등장 빈도(50%)보다 'C or D'의 등장 빈도(25%)가 작습니다."</string>
    <string name="Huffman91">"따라서 'C or D'를 3비트로 표현해서라도 A를 1비트로 표현하는 것이 효율적이라는 것을 알 수 있습니다."</string>
    <string name="Huffman92">이렇게 찾은 부호화 규칙을 이용해서 ABAABACD를 부호화해보겠습니다.</string>
    <string name="Huffman93">결과는 14비트가 되며 하나의 문자를 2비트로 표현한 보다 더 짧아졌습니다.</string>
    <string name="Huffman94">다른 한 가지 예를 보겠습니다. 각 문자의 등장 빈도에 큰 차이가 없는 경우입니다.</string>
    <string name="Huffman95">편의상 문자열 순서에 따라 등장 빈도가 낮아지도록 설정하겠습니다. 따라서 정렬은 불필요합니다.</string>
    <string name="Huffman96">다음은 등장 빈도가 낮은 순으로 두 개의 문자를 찾습니다.</string>
    <string name="Huffman97" formatted="false">여기선 C(22%)와 D(18%)가 됩니다.</string>
    <string name="Huffman98">두 개의 문자를 연결해서 트리 구조를 만듭니다.</string>
    <string name="Huffman99">"두 개의 문자를 'C or D'로 합체해서 등장 빈도를 더합니다."</string>
    <string name="HuffmanDescription">허프만 부호는 JPEG, ZIP 등에서 사용되는 알고리즘입니다. 이 항목은 모든 알고리즘을 구매 후에 학습할 수 있습니다.</string>
    <string name="HybridEncoding">하이브리드 암호 방식</string>
    <string name="HybridEncoding0">공통키 암호 방식에는 키를 어떻게 안전하게 교환해야 하는지 ‘키 분배 문제’가 있었습니다.</string>
    <string name="HybridEncoding1">한편 공개키 암호 방식에는 암호화와 복호화의 처리 속도가 느리다는 문제가 있었습니다.</string>
    <string name="HybridEncoding10">키를 공개키 암호 방식으로 암호화하므로 안전하게 B에게 전달할 수 있습니다.</string>
    <string name="HybridEncoding11">B는 공개키와 비밀키를 생성합니다.</string>
    <string name="HybridEncoding12">공개키를 A에게 보냅니다.</string>
    <string name="HybridEncoding13">A는 B에게서 받은 공개키를 사용해서 …</string>
    <string name="HybridEncoding14">공통키 암호 방식에 사용하는 키를 암호화합니다.</string>
    <string name="HybridEncoding15">암호화한 키를 B에게 전달합니다.</string>
    <string name="HybridEncoding16">B는 비밀키를 사용해서 키의 암호문을 복호화합니다.</string>
    <string name="HybridEncoding17">키의 암호문을 복호화합니다.</string>
    <string name="HybridEncoding18">이것으로 A는 공통키 암호 방식에 사용하는 키를 B에게 안전하게 전달할 수 있습니다.</string>
    <string name="HybridEncoding19">이후로는 이 키를 사용해서 암호화한 데이터를 보내기만 하면 됩니다.</string>
    <string name="HybridEncoding2">하이브리드 방식은 이 두 가지 방식을 결합해서 약점을 보완한 방식입니다.</string>
    <string name="HybridEncoding20">데이터 암호화에는 처리 속도가 빠른 공통키 암호 방식을 사용합니다.</string>
    <string name="HybridEncoding21">B는 무사히 원 데이터를 취득할 수 있습니다.</string>
    <string name="HybridEncoding22">이와 같이 하이브리드 암호 방식은 안정성과 속도를 모두 만족합니다.</string>
    <string name="HybridEncoding23">하이브리드 암호 방식은 인터넷상에서 정보를 안전하게 교환하기 위한 프로토콜인 ‘SSL’에서 사용되고 있습니다.</string>
    <string name="HybridEncoding24">이것으로 하이브리드 암호 방식에 대한 설명을 마칩니다.</string>
    <string name="HybridEncoding3">데이터 암호화에는 처리 속도가 빠른 공통키 암호 방식을 사용합니다.</string>
    <string name="HybridEncoding4">. 반면, 공통키 암호 방식에서 사용하는 키는 키 분배가 불필요한 공개키 암호 방식을 이용합니다.</string>
    <string name="HybridEncoding5">하이브리드 암호 방식의 구체적인 흐름을 보도록 하겠습니다.</string>
    <string name="HybridEncoding6">A가 B에게 인터넷을 통해서 데이터를 전달하려고 하는 상황입니다.</string>
    <string name="HybridEncoding7">데이터는 처리 속도가 빠른 공통키 암호 방식으로 암호화합니다.</string>
    <string name="HybridEncoding8">암호화에 필요한 키는 복호화에도 사용하므로 A는 키를 B에게 전달해야 합니다.</string>
    <string name="HybridEncoding9">키도 데이터의 일종입니다.</string>
    <string name="HybridEncodingDescription">하이브리드 암호 방식은 공통키 암하 방식과 공개키 암호 방식을 조합한 것입니다. 이 항목은 모든 알고리즘을 구매 후에 학습할 수 있습니다.</string>
    <string name="IABSetUpFailed">Google Play 접속에 실패했습니다. Google Play에 로그인했는지 확인해주세요.</string>
    <string name="Inquiry">의견 및 건의</string>
    <string name="InquiryConfirmation">확인</string>
    <string name="InquiryEmail">메일 주소</string>
    <string name="InquiryFailed">의견 및 건의 사항 전송에 실패했습니다. 잠시 후에 다시 시도해주세요.</string>
    <string name="InquiryIsSendOK">의견 및 건의 사항을 전송합니다.</string>
    <string name="InquiryName">이름</string>
    <string name="InquiryOptional">(선택)</string>
    <string name="InquiryPleaseInput">의견 및 건의 사항을 기입해주세요.</string>
    <string name="InquiryPleaseSmall">메시지는 1,000자까지 입력할 수 있습니다.</string>
    <string name="InquirySend">전송하기</string>
    <string name="InquirySuccess">의견 및 건의 사항을 보내주셔서 감사합니다. 이후 앱 개선 시에 참고하도록 하겠습니다.</string>
    <string name="InquirySuccessTitle">의견 및 건의 사항을 전송했습니다.</string>
    <string name="InsertionSort">삽입 정렬</string>
    <string name="InsertionSort0">삽입 정렬은 수열을 정렬하는 알고리즘 중 하나입니다.</string>
    <string name="InsertionSort1">처음에는 왼쪽 끝의 숫자를 정렬이 끝났다고 간주합니다</string>
    <string name="InsertionSort10">왼쪽에 있는 숫자와 비교합니다.</string>
    <string name="InsertionSort11">5 > 4이므로 숫자를 교체합니다.</string>
    <string name="InsertionSort12">비교하지만 3 &lt; 4로 자신보다 작은 숫자가 나타났으므로 멈춥니다.</string>
    <string name="InsertionSort13">숫자를 작업 완료 상태로 바꿉니다.</string>
    <string name="InsertionSort14">동일한 작업을 모든 숫자가 작업 완료 상태가 될 때까지 반복합니다.</string>
    <string name="InsertionSort18">모든 숫자가 작업 완료 상태가 돼서 정렬를 완료합니다.</string>
    <string name="InsertionSort19">이것으로 삽입 정렬의 설명을 마칩니다.</string>
    <string name="InsertionSort2">계속해서 아직 작업하지 않은 숫자 중에서 왼쪽 끝에 있는 숫자를 꺼내서…</string>
    <string name="InsertionSort3">왼쪽에 있는 작업이 끝난는 숫자와 비교합니다.</string>
    <string name="InsertionSort4">왼쪽의 숫자가 크면 두 개의 숫자를 바꿉니다.</string>
    <string name="InsertionSort5">이 작업을 자신보다 작은 숫자가 나타나거나 왼쪽 끝에 도착할 때까지 반복합니다.</string>
    <string name="InsertionSort6">이 경우 5 > 3이므로 숫자를 교체합니다.</string>
    <string name="InsertionSort7">숫자가 왼쪽 끝에 도착했으므로 여기서 멈춥니다.</string>
    <string name="InsertionSort8">숫자를 작업 완료 상태로 바꿉니다.</string>
    <string name="InsertionSort9">동일한 방식으로 왼쪽 끝의 숫자를 꺼내서…</string>
    <string name="KmeansClustering">k-means법</string>
    <string name="KmeansClustering0">k-means법은 클러스터링 알고리즘 중 하나입니다</string>
    <string name="KmeansClustering1">클러스터링(clustering)이란 데이터가 주어졌을 때…</string>
    <string name="KmeansClustering10">클러스터의 중심점이 될 세 점을 임의의 위치에 설치합니다.</string>
    <string name="KmeansClustering100">가장 가까운 클러스터의 중심점을 재계산하고 각 데이터를 클러스터로 재분류합니다.</string>
    <string name="KmeansClustering101">이때 개별 그룹을 ‘클러스터(cluster)’라고 합니다.</string>
    <string name="KmeansClustering11">각 데이터로부터 가장 가까운 중심점을 계산을 통해 결정합니다.</string>
    <string name="KmeansClustering12">각 데이터가 속하는 클러스터로 분류합니다.</string>
    <string name="KmeansClustering13">각 클러스터의 중심을 재계산해서 해당 위치로 클러스터의 중심점을 이동시킵니다.</string>
    <string name="KmeansClustering14">중심점을 이동하므로 ‘가장 가까운 중심점’이 바뀌는 데이터가 생깁니다.</string>
    <string name="KmeansClustering15">‘각 데이터의 클러스터 분류’와 ‘중심점을 클로스터 중심으로 이동’을 중심점이 수렴할 때까지(움직일 수 없을 때까지) 반복합니다.</string>
    <string name="KmeansClustering2">‘비슷한 것’들을 묶어 그룹으로 분류하는 작업을 가리킵니다.</string>
    <string name="KmeansClustering26">중심점이 수렴하므로 작업을 종료합니다.</string>
    <string name="KmeansClustering27">작업을 반복하다보면 중심점이 반듯이 수렴하게 된다는 것은 수학적으로 이미 증면된 사실입니다.</string>
    <string name="KmeansClustering28">이것으로 클러스터링이 완료됐습니다.</string>
    <string name="KmeansClustering29">데이터가 비슷한 것끼리 분류된 것을 확인할 수 있습니다.</string>
    <string name="KmeansClustering3">"비슷한 것'의 기준은 각 데이터 간 거리나 좌표 등 알고리즘에 따라 달라집니다."</string>
    <string name="KmeansClustering30">동일한 데이터에 대해 클러스터 수를 2로 설정하면 어떻게 되는지 확인해보겠습니다.</string>
    <string name="KmeansClustering31">중심점으로 임의로 설치하고…</string>
    <string name="KmeansClustering32">‘각 데이터의 클러스터 분류’와 ‘중심점을 클로스터 중심으로 이동’을 중심점이 수렴할 때까지(움직일 수 없을 때까지) 반복합니다.</string>
    <string name="KmeansClustering4">k-means법은 각 클러스터의 중심점으로부터의 거리로 데이터를 분류합니다.</string>
    <string name="KmeansClustering43">중심점이 수렴했습니다.</string>
    <string name="KmeansClustering44">이번에는 왼쪽과 아래에 위치한 두 개의 데이터 그룹이 하나의 클러스터로 분류됩니다.</string>
    <string name="KmeansClustering45">이와 같이 k-means법은 클러스터 수를 미리 정해두어야 하므로 이 수가 최적의 수가 아니면 유효한 결과가 나오지 않을 수도 있습니다.</string>
    <string name="KmeansClustering46">최적의 클러스터 수를 추측하기 위해 데이터를 사전에 분석하거나 클러스터 수를 몇 번 변경해가며 k-means법을 실행해보는 기법이 있습니다.</string>
    <string name="KmeansClustering47">이번에는 동일한 데이터에 대해 중심점의 위치를 변경하면 어떻게 되는지 보도록 하겠습니다.</string>
    <string name="KmeansClustering48">‘각 데이터의 클러스터 분류’와 ‘중심점을 클로스터 중심으로 이동’을 중심점이 수렴할 때까지(움직일 수 없을 때까지) 반복합니다.</string>
    <string name="KmeansClustering5">알고리즘의 과정을 보도로 하겠습니다.</string>
    <string name="KmeansClustering58">중심점이 수렴했습니다.</string>
    <string name="KmeansClustering59">이번에는 오른쪽 상단과 오른쪽 하단에 위치한 두 개의 데이터 그룹이 하나의 클러스터로 분류됩니다.</string>
    <string name="KmeansClustering6">먼저 클러스터링을 하고 싶은 데이터를 준비합니다.</string>
    <string name="KmeansClustering60">k-means법은 임의의 위치에 배치되는 중심점에 의해 클러스터링 결과가 달라지는 성질이 있습니다.</string>
    <string name="KmeansClustering61">이것으로 k-means법에 대한 설명을 마칩니다.</string>
    <string name="KmeansClustering7">다음은 클러스터 수를 정합니다</string>
    <string name="KmeansClustering8">클러스터 수를 미리 정하는 것이 k-means법의 특징입니다.</string>
    <string name="KmeansClustering9">여기선 클러스터 수를 3으로 설정하고 있습니다.</string>
    <string name="KmeansClusteringDescription">k-means법은 단순하지만 폭넓게 사용되는 클러스터링 기법입니다. 이 항목은 모든 알고리즘을 구매 후에 학습할 수 있습니다.</string>
    <string name="LangColon">언어:</string>
    <string name="LetsUnlock">구매를 통해 이제 모든 항목을 학습할 수 있습니다. 함께 알고리즘을 마스터해봅시다!</string>
    <string name="LinearSearch">선형 탐색</string>
    <string name="LinearSearch0">선형 탐색은 배열에서 데이터를 탐색하는 알고리즘입니다</string>
    <string name="LinearSearch1">6을 탐색해보도록 하겠습니다.</string>
    <string name="LinearSearch2">먼저 배열의 왼쪽 끝 숫자를 확인합니다.</string>
    <string name="LinearSearch3">6과 비교해서 일치하면 탐색을 종료합니다. 그렇지 않으면 하나 오른쪽에 있는 숫자를 확인합니다.</string>
    <string name="LinearSearch4">6을 찾을 때까지 비교를 반복합니다.</string>
    <string name="LinearSearch5">6을 찾았으므로 탐색을 종료합니다.</string>
    <string name="LinearSearch6">선형 탐색은 이처럼 선두에서부터 차례대로 비교를 반복해가는 간단한 기법입니다.</string>
    <string name="LinearSearch7">데이터 수가 많으면 비교 횟수가 많아져서 시간이 걸립니다.</string>
    <string name="LinearSearch8">이것으로 선형 탐색에 대한 설명을 마칩니다.</string>
    <string name="List">리스트</string>
    <string name="List0">리스트(List)는 데이터 구조의 하나로 여러 개의 값을 저정하기 위한 구조입니다.</string>
    <string name="List1">데이터와 포인터가 한 쌍으로 구성된 것이 특징으로, 포인터가 다음 데이터의 메모리 위치를 가리킵니다.</string>
    <string name="List12">이것으로 리스트에 대한 설명을 마칩니다.</string>
    <string name="List2">리스트에선 데이터가 메모리상의 떨어진 영역에 흩어져서 저장됩니다.</string>
    <string name="List4">흩어져 저장돼 있으므로 포인터를 처음부터 순서대로 따라가야만 원하는 데이터에 접근할 수 있습니다</string>
    <string name="List9">데이터 추가는 추가할 위치의 앞뒤 포인터를 변경만 하면 되므로 간단하다고 볼 수 있습니다.</string>
    <string name="ListSearchSection">리스트 탐색</string>
    <string name="MAC">메시지 인증 코드</string>
    <string name="MAC0">메시지 인증 코드는 ‘인증’과 ‘변조 검출’의 두 가지 기능을 가지는 구조입니다.</string>
    <string name="MAC1">먼저 메시지 인증 코드가 필요한 상황을 생각해보겠습니다.</string>
    <string name="MAC10">암호문을 B에게 보내고…</string>
    <string name="MAC11">B는 이것을 복호화해서 메시지인 상품 번호 ‘abc’를 확인할 수 있습니다.</string>
    <string name="MAC12">지금까지는 문제가 없는 경우지만 다음과 같은 상황이 발생할 수도 있습니다.</string>
    <string name="MAC13">상황을, A가 B에게 암호문을 보내는 부분으로 되돌리겠습니다.</string>
    <string name="MAC14">A가 B에게 전송하려고 한 암호문을…</string>
    <string name="MAC15">악의를 지닌 X가 통신 도중에 변조한 상황을 생각해보겠습니다.</string>
    <string name="MAC16">B는 암호문을 받지만 변조된 것을 눈치채지 못합니다.</string>
    <string name="MAC17">변조된 암호문을 B가 복호화하면 메시지가 ‘xyz’로 변경돼 있습니다.</string>
    <string name="MAC18">B는 ‘xyz’가 주문한 상품 번호라고 믿고 A에게 잘못된 상품을 발송합니다.</string>
    <string name="MAC19">암호는 어디까지나 수치 계산 처리에 불과하기 때문에, 변조된 암호문이라도 복호화 계산을 할 수가 있습니다.</string>
    <string name="MAC2">A가 B에게서 상품을 사기 위해 상품 번호를 나타내는 ‘abc’라는 메시지를 보냅니다.</string>
    <string name="MAC20">원 메시지가 긴 문장이라면 변조에 의해 의미가 이상해지기 때문에 변조됐다는 사실을 알 수 있습니다.</string>
    <string name="MAC21">하지만 원 메시지가 상품 번호처럼 사람이 직접 이해할 수 없는 데이터라면 복호화해도 변조된 사실을 인지하기가 어렵습니다.</string>
    <string name="MAC22">변조를 감지하려면 암호화는 다른 또다른 수단이 필요합니다.</string>
    <string name="MAC23">메시지 인증 코드를 사용하면 메시지 변조를 감지할 수 있습니다. 실제 흐름을 보기 위해…</string>
    <string name="MAC24">상황을 A가 B에게 암호문을 전달하는 부분으로 되돌려 보겠습니다.</string>
    <string name="MAC25">A는 메시지 인증 코드 작성을 위한 키를 만들고…</string>
    <string name="MAC26">안전한 방법으로 B에게 키를 전달합니다.</string>
    <string name="MAC27">A는 암호문과 키를 사용해서 특정 값을 만듭니다.</string>
    <string name="MAC28">여기선 ‘7f05’라는 값이 만들어집니다.</string>
    <string name="MAC29">이 키와 암호문을 조합해서 만든 값을 ‘메시지 인증 코드’라고 합니다.</string>
    <string name="MAC3">여기서 A는 메시지를 암호화합니다.</string>
    <string name="MAC30">메시지 인증 코드는 영어로는 ‘MAC(Message Authentication Code)’라고 부르기 때문에, 지금부터는 ‘MAC’이라고 표기하겠습니다.</string>
    <string name="MAC31">맥은, 키와 암호문을 조합한 문자열의 ‘해시값’이라고 보면 됩니다.</string>
    <string name="MAC32">"해시값에 대해선 이 앱의 '해시 함수'에서 자세히 다루고 있습니다."</string>
    <string name="MAC33">MAC 작성 방법에는 HMAC, OMAC, CMAC 등이 있습니다. 현재는 HMAC이 주로 사용되고 있습니다.</string>
    <string name="MAC34">A는 B에게 작성한 MAC과 암호문을 보냅니다.</string>
    <string name="MAC35">B가 암호문과 MAC을 받았습니다.</string>
    <string name="MAC36">B는 받은 암호문이 변조됐는지를 확인할 필요가 있습니다.</string>
    <string name="MAC37">A와 마찬가지로 B도 암호문과 키를 사용해서 MAC을 작성합니다.</string>
    <string name="MAC38">B가 직접 계산한 MAC과 A에게서 받은 MAC이 일치하는 것을 확인했습니다.</string>
    <string name="MAC39">이를 통해 B가 받은 암호문은 변조되지 않은 것임을 알 수 있습니다.</string>
    <string name="MAC4">암호화에는 ‘공통키 암호 방식’을 사용하기로 합니다.</string>
    <string name="MAC40">이후로는 암호문용 키를 사용해서 복호화하기만 하면 됩니다.</string>
    <string name="MAC41">무사히 A가 주문한 상품 번호인 ‘abc’라는 메시지를 추출할 수 있습니다.</string>
    <string name="MAC42">상황을, A가 암호문을 B에게 전송하려는 시점으로 돌려보겠습니다.</string>
    <string name="MAC43">만약 악의를 지닌 X가 통신 중에 암호문을 변조하면 어떻게 될까요?</string>
    <string name="MAC44">A가 B에게 전달하려고 한 암호문과 MAC 중에서…</string>
    <string name="MAC45">암호문을 X가 변조합니다.</string>
    <string name="MAC46">B는 암호문으로부터 MAC을 계산해서…</string>
    <string name="MAC47">. A가 받은 MAC과 일치하지 않는다는 것을 알았습니다.</string>
    <string name="MAC48">이를 통해 B는 암호문이나 맥, 또는 양쪽 모두가 변조됐을 가능성이 있다고 생각합니다.</string>
    <string name="MAC49">A에게서 받은 암호문과 MAC을 파기하고 A에게 다시 전송을 요청하면 됩니다.</string>
    <string name="MAC5">A는 안전한 방법으로 키를 B에게 보냅니다.</string>
    <string name="MAC50">X가 암호문의 변조 내용에 맞추어 MAC도 변조한다면 어떻게 될까요?</string>
    <string name="MAC51">X는 MAC을 계산하기 위한 키를 가지고 있지 않으므로…</string>
    <string name="MAC52">MAC을 변조했다고 해도 암호문의 변조에 맞추는 것은 불가능합니다.</string>
    <string name="MAC53">B가 MAC을 다시 계산하면 변조된 암호문에 대한 MAC과 일치하지 않아서 통신 중에 어딘가에서 변조가 발생했다는 것을 알 수 있습니다</string>
    <string name="MAC55">이와 같이 메시지 인증 코드라 불리는 MAC을 이용하면 통신상의 변조를 방지할 수 있습니다.</string>
    <string name="MAC56">단, 여기에도 결점이 있습니다.</string>
    <string name="MAC57">일련의 처리를 단순화해보겠습니다.</string>
    <string name="MAC58">먼저 A와 B는 암호화에 사옹하는 키와 MAC을 계산하기 위한 키를 공유하고 있습니다.</string>
    <string name="MAC59">따라서…</string>
    <string name="MAC6">키 교환 방법은 ‘공개키 암호 방식’ 또는 ‘디피-헬만 키 교환법’같은 키 교환 프로토콜을 사용합니다.</string>
    <string name="MAC60">A가 메시지를 암호화해서 MAC을 계산할 수 있도록…</string>
    <string name="MAC63">B도 마찬가지로 메시지를 암호화해서 MAC을 계산할 수가 있습니다.</string>
    <string name="MAC66">즉, 원 메시지를 작성한 것이 A인지 B인지를 증명할 수 없게 됩니다.</string>
    <string name="MAC67">따라서 A가 악의를 지닌 경우…</string>
    <string name="MAC68">메시지를 보낸 후에 ‘그건 B가 조작한 메시지야’라고 자신이 보낸 것을 사후 부인할 수 있게 됩니다.</string>
    <string name="MAC7">공개키 암호 방식과 디피-헬만 키 교환법 모두 이 앱에서 자세히 다루고 있습니다.</string>
    <string name="MAC71">"이런 사후 부인을 방지하기 위해서는 이 앱에서 설명하고 있는 '전자 서명'을 사용해야 합니다."</string>
    <string name="MAC72">"이것으로 '메시지 인증 코드'에 대한 설며을 마칩니다."</string>
    <string name="MAC8">A는 공유한 키를 사용해서 메시지를 암호문으로 만듭니다.</string>
    <string name="MarkAllAsRead">모든 항목을 읽음으로 표시</string>
    <string name="MarkAllAsUnread">모든 항목을 읽지 않음으로 표시</string>
    <string name="MathSection">수학</string>
    <string name="MergeSort">병합 정렬</string>
    <string name="MergeSort0">병합 정렬은 수열을 정렬하는 알고리즘 중 하나입니다.</string>
    <string name="MergeSort1">처음에는 수열을 반씩 분할해나갑니다.</string>
    <string name="MergeSort10">여러 숫자를 포함하고 있는 그룹들을 서로 병합할 때는 선두의 숫자를 비교해서 작은 숫자를 이동합니다.</string>
    <string name="MergeSort11">그림의 첫 4와 3을 비교합니다.</string>
    <string name="MergeSort12">4 > 3이므로 3을 이동합니다.</string>
    <string name="MergeSort13">마찬가지로 남은 열의 선두를 비교해서…</string>
    <string name="MergeSort14">4 &lt; 7이므로 4를 이동합니다.</string>
    <string name="MergeSort15">6 &lt; 7이므로 6을 이동합니다.</string>
    <string name="MergeSort16">남은 7을 이동합니다.</string>
    <string name="MergeSort17">그룹 병합 작업은 모든 숫자가 하나의 그룹이 될 때까지 재귀적으로 반복합니다.</string>
    <string name="MergeSort22">병합이 끝나고 수열이 정렬됩니다.</string>
    <string name="MergeSort23">이것으로 병합 정렬에 대한 설명을 마치겠습니다.</string>
    <string name="MergeSort5">분할이 완료됐습니다.</string>
    <string name="MergeSort6">분할이 완료됐습니다. 다음은 분할한 각 그룹을 병합해나갑니다.</string>
    <string name="MergeSort7">병합할 때에는 병합 후의 그룹 내에서 숫자가 작은 순으로 나열되도록 합니다.</string>
    <string name="MergeSortDescription">병합 정렬은 전체를 작게 분해해서 정렬하는 것이 특징입니다. 이 항목은 모든 알고리즘을 구매 후에 학습할 수 있습니다.</string>
    <string name="NowBuying">과금 처리를 준비 중입니다…</string>
    <string name="OK">승인</string>
    <string name="OthersSection">기타</string>
    <string name="PKC">공개키 암호 방식</string>
    <string name="PKC0">공개키 암호 방식은 암호화와 복호화에 서로 다른 키를 사용하는 방식입니다.</string>
    <string name="PKC1">암호화에 사용하는 키를 ‘공개키’, 복호화에 사용하는 키를 ‘비밀키’라고 합니다.</string>
    <string name="PKC10">암호문을 B에게 전송합니다.</string>
    <string name="PKC11">B는 받은 암호문을 비밀키를 사용해 복호화합니다.</string>
    <string name="PKC12">B는 원 데이터를 얻을 수 있습니다.</string>
    <string name="PKC13">공개키와 암호문 모두 인터넷을 통해 전달되므로…</string>
    <string name="PKC14">악의를 가진 제삼자가(X) 훔쳐볼 가능성이 있습니다.</string>
    <string name="PKC15">하지만 공개키로는 암호문을 복호화할 수 없으므로 X는 원 데이터를 얻을 수 없습니다.</string>
    <string name="PKC16">공통키 암호 방식과 달리 공개키 암호 방식에선 ‘키 분배 문제’가 발생하지 않습니다.</string>
    <string name="PKC17">이외에도 공개키 암호 방식은 불특정다수 간 데이터 교환이 쉽다는 장점이 있습니다. 구체적으로 보겠습니다.</string>
    <string name="PKC18">B가 미리 공개키와 비밀키를 준비했다고 합시다.</string>
    <string name="PKC19">공개키는 다른 사람들에게 노출돼도 문제가 없습니다.</string>
    <string name="PKC2">공통키 암호 방식에 비해 공개키 암호 방식의 경우 암호화 및 복호화에 시간이 많이 걸리는 경향이 있습니다.</string>
    <string name="PKC20">따라서 B는 공개키를 인터넷상에 공개할 수 있습니다.</string>
    <string name="PKC21">반면 비밀키는 노출되지 않도록 엄중하게 관리할 필요가 있습니다.</string>
    <string name="PKC22">B에게 데이터를 전송하고 싶은 사람이 여러 명인 경우를 생각해봅시다.</string>
    <string name="PKC23">데이터를 전송하는 사람은 B가 공개한 공개키를 가져옵니다.</string>
    <string name="PKC24">전송하고 싶은 데이터를 이 공개키로 암호화합니다.</string>
    <string name="PKC25">그리고 암호문을 B에게 보냅니다.</string>
    <string name="PKC26">B는 받은 암호문을 비밀키를 사용해서 복호화합니다.</string>
    <string name="PKC27">이것으로 B는 원 데이터를 얻을 수 있습니다.</string>
    <string name="PKC28">이처럼 데이터를 전송하는 상대방 모두가 키를 가지고 있을 필요가 없습니다.</string>
    <string name="PKC29">또한, 데이터를 받는 쪽만 노출되지 않은 키를 소유하면 되므로 안전성도 높습니다.</string>
    <string name="PKC3">공개키 암호 방식의 계산 방법으로는 그림과 같은 것이 있습니다.</string>
    <string name="PKC30">한편 공개키 암호 방식에는 두 가지 문제점이 있습니다.</string>
    <string name="PKC31">첫 번째는 암호화 및 복호화에 시간이 많이 걸린다는 점입니다.</string>
    <string name="PKC32">따라서 상세한 데이터를 연속적으로 교환하는 구조에는 적합하지 않습니다.</string>
    <string name="PKC33">이 문제를 해결하려면 ‘하이브리드 암호 방식’을 사용해야 합니다. 이 앱에서 자세히 다루고 있습니다.</string>
    <string name="PKC34">두 번째는 공개키의 신뢰도에 관한 문제입니다.</string>
    <string name="PKC35">상황을 B가 공개키와 비밀키를 만든 시점으로 돌려보겠습니다.</string>
    <string name="PKC36">설명을 위해서 B가 작성한 공개키를 ‘PB’, 비밀키를 ‘SB’라고 표시하겠습니다.</string>
    <string name="PKC37">A가 B에게 보낸 데이터를 훔쳐 보려는 X가, 공개키 Px와 비밀키Sx를 만듭니다.</string>
    <string name="PKC38">B가 공개키 PB를 A에게 보낼 때에…</string>
    <string name="PKC39">X가 공개키 PB를 자신이 만든 Px로 바꿉니다.</string>
    <string name="PKC4">현재는 RSA가 주로 사용되고 있습니다.</string>
    <string name="PKC40">공개키Px를 A에게 전달합니다.</string>
    <string name="PKC41">공개키 자체에는 누가 작성한지를 표시하는 수단이 없습니다.</string>
    <string name="PKC42">따라서 A가 받은 공개키가 바뀐 것이라는 것을 알 수 없습니다.</string>
    <string name="PKC43">A는 공개키 Px로 데이터를 암호화합니다.</string>
    <string name="PKC44">A가 암호문을B에게 보내려고 할 때…</string>
    <string name="PKC45">X가 이 암호문을 가로챕니다.</string>
    <string name="PKC46">이 암호문은 X가 만든 공개키Px로 암호화된 것으로…</string>
    <string name="PKC47">X가 가진 비밀키Sx로 복호화할 수 있습니다.</string>
    <string name="PKC48">X는 A가 B에게 보내려고 한 데이터를 가로챕니다.</string>
    <string name="PKC49">다음은 X가 B의 공개키인 PB로 데이터를 암호화합니다.</string>
    <string name="PKC5">공개키 암호 방식을 사용한 데이터 교환의 전체적인 흐름을 보도록 하겠습니다.</string>
    <string name="PKC50">작성한 암호문을 B에게 전달합니다.</string>
    <string name="PKC51">이 암호문은 B가 만든 공개키 PB로 작성한 것이므로 B는 자신이 가지고 있는 SB로 복호화할 수 있습니다.</string>
    <string name="PKC52">B는 아무런 문제 없이 받은 암호문을 복호화할 수 있으므로 도중에 데이터가 노출된 것을 꿈에도 모릅니다.</string>
    <string name="PKC53">이와 같이 도중에 공개키를 바꿔치기 해서 데이터를 가로채는 기법을 ‘man-in-the-middle 공격’이라고 합니다.</string>
    <string name="PKC54">문제의 원인은, A가 받은 공개키의 작성자가 B인지 판단할 수 있는 방법이 없다는 것입니다.</string>
    <string name="PKC55">이 문제를 해결하려면 ‘전자 인증서’을 사용하면 됩니다. 전자 인증서에 대해선 이 앱에서 자세히 다루고 있습니다.</string>
    <string name="PKC56">이것으로 공개키 암호 방식에 대한 설명을 마칩니다.</string>
    <string name="PKC6">A가 B에게 인터넷을 통해 데이터를 전송하려고 하고 있습니다.</string>
    <string name="PKC7">먼저 데이터를 전달 받는 B가 공개키와 비밀키를 만듭니다.</string>
    <string name="PKC8">그중 공개키를 A에게 전송합니다.</string>
    <string name="PKC9">A는 B에서 받은 공개키를 사용해서 데이터를 암호화합니다.</string>
    <string name="PageRank">페이지 랭크</string>
    <string name="PageRank0">검색 사이트에서 검색 결과의 순위를 결정하기 위해 사용되는 알고리즘입니다.</string>
    <string name="PageRank1">구글이 이 알고리즘을 검색 엔진에 적용해서 세계적인 기업이 될 수 있었습니다.</string>
    <string name="PageRank10">링크되지 않은 페이지의 점수를 1이라고 합니다.</string>
    <string name="PageRank100">인터넷 공간으로 시점을 옮겨서 이 동작을 보도록 하겠습니다.</string>
    <string name="PageRank101">페이지들을 정해진 횟수 없이 이동한 후에 전혀 다른 페이지로 순간이동하는 것을 반복하는 것처럼 보입니다.</string>
    <string name="PageRank11">링크돼 있는 페이지의 점수는 링크를 하고 있는 페이지의 점수를 합한 것이 됩니다.</string>
    <string name="PageRank12">단, 링크가 여러 페이지로 나누어 지는 경우는…</string>
    <string name="PageRank13">링크 점수를 균등하게 배분합니다.</string>
    <string name="PageRank14">페이지랭크에선 링크를 모으고 있는 페이지로부터 링크되는 경우 큰 가치를 지닙니다.</string>
    <string name="PageRank15">그림의 가운데 페이지는 세 개의 독립된 페이지로부터 링크되므로 점수가 3이 됩니다.</string>
    <string name="PageRank16">최상단에 있는 페이지는 점수가 3인 페이지가 링크하고 있어서 큰 점수를 부여받습니다.</string>
    <string name="PageRank17">이 그림에 있는 6개의 페이지에선 가장 상단에 있는 페이지가 가장 중요한 페이지로 인식됩니다.</string>
    <string name="PageRank18">이상이 페이지랭크의 기본적인 개념입니다.</string>
    <string name="PageRank19">이 방법에선 링크가 원형을 이루는 경우 문제가 발생합니다.</string>
    <string name="PageRank2">이전 검색 사이트에선 검색 키워드와 페이지 내 문장과의 관련성을 중심으로 검색 결과의 순위를 결정했었습니다.</string>
    <string name="PageRank20">각 페이지의 점수를 순서대로 계산하다 보면…</string>
    <string name="PageRank24">이처럼 무한 루프가 돼서 루프 내의 페이지 점수가 계속 증가되게 됩니다.</string>
    <string name="PageRank25">루프 문제는 ‘랜덤 서퍼모델(Random Surfer Model)’이라는 계산 방법으로 해결할 수 있습니다.</string>
    <string name="PageRank26">인터넷 서핑을 하는 사용자가 어떤 식으로 페이지를 열람하는지 생각해봅시다.</string>
    <string name="PageRank27">우연히 본 잡지에 재미있는 사이트가 소개돼서 접속하려고 합니다.</string>
    <string name="PageRank28">링크를 따라 다른 페이지로 이동합니다.</string>
    <string name="PageRank29">몇 개의 페이지를 방문하다 재미가 없어지면…</string>
    <string name="PageRank3">이 방법에선 페이지 내에 유익한 정보가 포함돼 있는지는 고려되고 있지 않습니다. 이 때문에 검색 결과의 정확도가 높다고 볼 수 없었습니다.</string>
    <string name="PageRank30">일단 서핑을 중단합니다.</string>
    <string name="PageRank31">그리고 며칠 후, 이번에는 친구가 추천해준 다른 페이지를 통해 인터넷 서핑을 시작합니다.</string>
    <string name="PageRank32">여기서도 링크를 따라서 다른 페이지로 이동하며…</string>
    <string name="PageRank33">재미가 없어지면 서핑을 중단합니다.</string>
    <string name="PageRank34">이와 같이 어떤 페이지에서 열람을 시작해서 몇 페이지 이동한 후 종료하는 동작이 반복됩니다.</string>
    <string name="PageRank35">인터넷 서핑을 하는 사람의 동작을 정의하면 다음과 같이 됩니다.</string>
    <string name="PageRank36">확률 1-α로 지금 있는 페이지의 링크 중 하나를 선택합니다.</string>
    <string name="PageRank37">확률 α로 다른 페이지로 순간이동합니다.</string>
    <string name="PageRank38">순간이동하는 확률인 α를 여기선 15%라고 하겠습니다.</string>
    <string name="PageRank39">이 정의에 따라서 페이지 간 전이를 시뮬레이션 해보겠습니다.</string>
    <string name="PageRank4">페이지랭크는 페이지 간의 링크 구조로부터 페이지의 가치를 산출하는 알고리즘입니다. 산출까지의 구체적인 과정을 보도록 하겠습니다.</string>
    <string name="PageRank40">앞에서 본 것처럼 링크가 루프(원형) 상태인 경우를 생각해보겠습니다</string>
    <string name="PageRank41">각 페이지상의 숫자는 인터넷 서핑을 한 사람이 페이지를 방문한 수를 나타냅니다.</string>
    <string name="PageRank42">현재는 시뮬레이션 전이므로 모든 숫자가 0입니다.</string>
    <string name="PageRank43">정의에 따라서 시뮬레이션을 하면 페이지당 방문 횟수의 차가 나옵니다.</string>
    <string name="PageRank49">시간의 흐름을 빠르게 해보겠습니다.</string>
    <string name="PageRank5">사각형이 웹페이지고 화살표가 페이지 간 링크를 나타냅니다.</string>
    <string name="PageRank50">페이지의 방문 횟수가 합계 1000회에 도달할 때까지 시뮬레이션을 계속한 결과 위와 같은 결과가 됐습니다.</string>
    <string name="PageRank51">이것을 비율로 바꾸면 이와 같이 됩니다.</string>
    <string name="PageRank52">"해시 테이블에는 몇 가지 종류가 있으며 리스트를 이용하는 방법을 '연쇄법'이라고 합니다."</string>
    <string name="PageRank53">이 값은 ‘특정 시점에 해당 페이지를 열람할 확률’을 나타낸다고 볼 수 있습니다.</string>
    <string name="PageRank54">이 기법이라면 링크가 루프 상태여도 점수를 계산할 수 있습니다.</string>
    <string name="PageRank55">실제로는 시뮬레이션을 하는 것이 아니라 더 효율적인 계산 방식을 사용합니다. 이 방식을 보도록 하겠습니다.</string>
    <string name="PageRank56">그림처럼 복잡한 링크 구조에서 각 페이지의 점수를 계산해보겠습니다.</string>
    <string name="PageRank57">먼저 각 페이지의 초기 점수를 설정합니다.</string>
    <string name="PageRank58">점수는 전체의 합이 1이 되도록 균등하게 분배합니다.</string>
    <string name="PageRank59">다음은 인터넷 서핑을 하는 사람이 1회 이동했을 때에 각 페이지에 있을 확률을 구합니다.</string>
    <string name="PageRank6">다음 그림에선 아래 세 개의 페이지가 하나의 페이지를 링크하고 있는 것을 보여주고 있습니다.</string>
    <string name="PageRank60">참고로 n회 이동했을 때에 A에 있을 확률을 PAn이라고 표시합니다.</string>
    <string name="PageRank61">예로 1회 이동한 후에 A에 있을 확률(PA1)을 구해보겠습니다.</string>
    <string name="PageRank62">이동해서 A에 있을 경우는 C에 있는 사람이 순간이동을 하지 않고…</string>
    <string name="PageRank63">목적지를 B가 아닌 A를 선택한 경우입니다.</string>
    <string name="PageRank64">초기 상태(0회째 이동 시점)에 C에 사람이 있을 확률은 PC0(=0.25)입니다.</string>
    <string name="PageRank65">또한, C에 있는 사람이 이동을 선택할 확률은 1-α로, A/B에서 A를 선택할 확률은 0.5입니다.</string>
    <string name="PageRank66">따라서 C에서 A로 이동할 확률은 PC0x(1-α)x0.5가 됩니다.</string>
    <string name="PageRank67">이동해서 A에 있을 경우가 한가지 더 있습니다. A~D페이지 중 한 페이지에 있는 사람이 순간이동을 하기로 하고...…</string>
    <string name="PageRank68">순간이동 목적지로 A를 선택하는 경우입니다.</string>
    <string name="PageRank69">A~D 페이지 중 한 페이지에 있는 사람이 순간이동을 선택할 확률은 α입니다.</string>
    <string name="PageRank7">페이지랭크에선 링크된 수가 많을수록 중요한 페이지라고 판단합니다.</string>
    <string name="PageRank70">또한, 순간이동 목적지로 A를 선택할 확률은 0.25입니다.</string>
    <string name="PageRank71">따라서 A로 순간이동으로 이동할 확률은 α x 0.25가 됩니다.</string>
    <string name="PageRank72">이상으로부터 1회 이동한 후에 A에 있을 확률은 PA1=PC0 x (1-α) x 0.5 + α x 0.25가 됩니다.</string>
    <string name="PageRank73">PC0=0.25, α=0.15를 대입해서 계산하면 PA1=0.14375가 됩니다.</string>
    <string name="PageRank74">마찬가지로 B, C, D 페이지에 있을 확률도 계산해서 값을 변경합니다.</string>
    <string name="PageRank75">결과는 그림과 같습니다.</string>
    <string name="PageRank76">다음은 인터넷 서핑을 하는 사람이 2회 이동했을 때에 각 페이지에 있을 확률을 동일한 방법으로 구합니다.</string>
    <string name="PageRank77">결과는 다음과 같습니다.</string>
    <string name="PageRank78">동일한 계산을 반복합니다. 그러면 각 페이지에 있을 확률이 수렴하게 됩니다.</string>
    <string name="PageRank79">수렴한 단게에서 계산을 종료합니다.</string>
    <string name="PageRank8">이 그림에선 상위에 있는 페이지가 가장 중요한 페이지라고 판단합니다.</string>
    <string name="PageRank80">이렇게 구한 값을 각 페이지의 점수로 설정합니다.</string>
    <string name="PageRank81">마지막으로 페이지랭크 값이 처음 설명한 링크의 가중치 계산과 일치하는지 확인합니다.</string>
    <string name="PageRank82">그림의 링크 구조에서 앞의 계산 방법을 사용해서 점수를 계산해보겠습니다.</string>
    <string name="PageRank83">각 값을 반올림하고 있으므로 전체를 더해도 1이 되지 않지만, 비슷한 비율이 되는 것을 알 수 있습니다.</string>
    <string name="PageRank84">이 링크 구조에서도 점수를 계산해보겠습니다.</string>
    <string name="PageRank85">여기서도 앞의 결과와 비슷한 비율이 되는 것을 알 수 있습니다.</string>
    <string name="PageRank86">이처럼 링크의 가중치를 방문할 확률로 대체해서 계산하는 것이 페이지랭크입니다.</string>
    <string name="PageRank87">실제 구글의 검색 순위는 페이지랭크만 사용하는 것은 아닙니다.</string>
    <string name="PageRank88">하지만, 링크 구조로부터 페이지의 가치를 산출한다는 발상과 링크가 루프 상태인 경우에도 계산할 수 있다는 점에서…</string>
    <string name="PageRank89">페이지랭크라는 알고리즘이 획기적이었다는 사실에는 변함이 없습니다.</string>
    <string name="PageRank9">실제로는 각 페이지의 중요도가 계산에 의해 수치화됩니다. 기본적인 계산 방법을 보도록 하겠습니다.</string>
    <string name="PageRank90">이것으로 페이지랭크에 대한 설명을 마칩니다.</string>
    <string name="PageRankDescription">페이지랭크는 검색 사이트에서 표시 순위를 결정하는 지표가 되는 것입니다. 이 항목은 모든 알고리즘을 구매 후에 학습할 수 있습니다.</string>
    <string name="PrimalityTest">소수 판별법</string>
    <string name="PrimalityTest0">소수 판별법은 특정 자연수가 소수인지를 판별하는 방법입니다.</string>
    <string name="PrimalityTest1">소수(prime number)란 1과 자신 이외는 약수로 가지지 않는 1보다 큰 자연수입니다.</string>
    <string name="PrimalityTest100">소수 판별법을 설명하기 전에 mod 연산에 대해 알아보겠습니다.</string>
    <string name="PrimalityTest101">mod 연산은 나눗셈의 나머지를 구하는 연산입니다.</string>
    <string name="PrimalityTest102">A mod B는 A를 B로 나누었을 때의 나머지 C를 구합니다.</string>
    <string name="PrimalityTest103">구체적인 숫자를 사용한 연산 예를 보겠습니다.</string>
    <string name="PrimalityTest17">즉, 3599는 소수가 아니라는 결과가 됩니다.</string>
    <string name="PrimalityTest18">하지만 이 방법은 판별할 숫자가 클수록 연산에 많은 시간이 걸려서 현실적이지 못합니다.</string>
    <string name="PrimalityTest19">이 문제를 해결하는 방법으로 ‘페르마 테스트(Fermat test)’가 있습니다.</string>
    <string name="PrimalityTest2">현대 암호 기술에서 자주 사용되는 ‘RSA 암호’에선 매우 큰 소수를 다룹니다.</string>
    <string name="PrimalityTest20">페르마 테스트는 확률적 소수 판별법이라고 불리며, 어떤 수가 ‘소수일 가능성이 높은지’를 판별하는 것입니다.</string>
    <string name="PrimalityTest21">페르마 테스트의 전제 지식이 되는 소수의 성질에 대해 설명하도록 하겠습니다.</string>
    <string name="PrimalityTest22">예를 들어 소수인 5라는 숫자의 성질을 보도록 하겠습니다.</string>
    <string name="PrimalityTest23">소수 5보다 작은 수를 각각 5 제곱하면 그림과 같은 결과가 됩니다.</string>
    <string name="PrimalityTest28">다음은 각각의 숫자를 mod 연산을 이용해 5로 나누어봅니다.</string>
    <string name="PrimalityTest29">계산 결과는 그림과 같습니다.</string>
    <string name="PrimalityTest3">RSA 암호에선 소수 판별법이 중요한 역할을 합니다.</string>
    <string name="PrimalityTest30">원래 숫자와 나머지 값을 자세히 보면 양쪽이 일치하는 것을 알 수 있습니다.</string>
    <string name="PrimalityTest31">이를 통해 소수 5에 대해 위와 같은 식이 성립한다는 것을 알 수 있습니다.</string>
    <string name="PrimalityTest32">이번에는 합성수(composite number)인 6이라는 숫자에 생각해봅시다.</string>
    <string name="PrimalityTest33">합성수라는 것은 소수가 아닌 자연수라는 것을 의미합니다. 6이라는 숫자는 2X3으로 나타낼 수 있으므로 소수가 아닙니다.</string>
    <string name="PrimalityTest34">동일한 계산을 하면…</string>
    <string name="PrimalityTest4">3599라는 숫자가 소수인지 판별하는 예를 보도록 하겠습니다.</string>
    <string name="PrimalityTest41">5와 2의 경우 원래 숫자와 나머지가 일치하지 않는 것을 알 수 있습니다.</string>
    <string name="PrimalityTest42">사실은 5뿐만 아니라 모든 소수 p에 대해 이 식이 성립한다는 것이 이미 증명돼 있습니다.</string>
    <string name="PrimalityTest43">"이것을 '페르마의 소정리'라고 합니다."</string>
    <string name="PrimalityTest44">페르마의 소정리를 만족하는지 여부로 소수 판별을 하는 방법이 ‘페르마 테스트’입니다.</string>
    <string name="PrimalityTest45">페르마 테스트를 사용해서 113이라는 수가 소수인지 판별해봅시다.</string>
    <string name="PrimalityTest46">113보자 작은 수를 적당히 세 개 선택합니다.</string>
    <string name="PrimalityTest47">이 숫자들을 113 제곱한 후에 113으로 나눈 나머지를 구합니다.</string>
    <string name="PrimalityTest48">어떤 숫자라도 원래 숫자와 나머지 값이 일치합니다.</string>
    <string name="PrimalityTest49">일치하는지 여부를 확인하는 횟수를 늘릴수록 소수일 확실성이 높아집니다.</string>
    <string name="PrimalityTest5">단순한 방법으로는 3599를 2보다 큰 수로 차례대로 사용해가면서 완전히 나누어지는지를 확인하는 방법이 있습니다.</string>
    <string name="PrimalityTest50">단, p보다 작은 모든 수를 확인하려면 많은 시간이 걸립니다.</string>
    <string name="PrimalityTest51">실제로는 몇 개의 수만 확인해서 소수일 가능성이 충분히 높다고 판단할 수 있으면 ‘아마도 소수’라고 판정하고 있습니다.</string>
    <string name="PrimalityTest52">예를 들어 RSA 암호에서 사용되는 소수 판별법에는 페르마 테스트를 개선한 ‘밀러-라빈(Miller-Rabin) 테스트’가 사용되고 있습니다.</string>
    <string name="PrimalityTest53">방법에선 테스트를 반복해서 소수가 아닌 확률이 0.5의 80승보다 작은 단계에서 해당 수를 소수라고 판별합니다.</string>
    <string name="PrimalityTest54">또한, 페르마 테스트를 모두 만족한다고 해도 소수라는 것을 확정할 수 없습니다.</string>
    <string name="PrimalityTest55">조사할 숫자가 소수이면 페르마 테스트에 부합합니다.</string>
    <string name="PrimalityTest56">한편 조사할 숫자가 합성수인 경우 페르마 테스트에 걸리는 숫자가 대부분이지만…</string>
    <string name="PrimalityTest57">소수처럼 페르마 테스트에 부합합니다. 합성수가 아주 적은 확률이지만 존재합니다.</string>
    <string name="PrimalityTest58">예를 들어 561이라는 숫자를 생각해봅시다.</string>
    <string name="PrimalityTest59">561이라는 숫자는 3 11 17 로 나타낼 수 있으로 합성수이지 소수가 아닙니다.</string>
    <string name="PrimalityTest6">‘완전히 나누어진다’는 것은 나머지를 구하는 연산인 mod 연산의 결과가 0인 것을 의미합니다.</string>
    <string name="PrimalityTest60">. 하지만 페르마 테스트에 부합합니다.</string>
    <string name="PrimalityTest63">이런 합성수를 ‘카마이클 수(Carmichael number)’ 또는 ‘절대 유사소수(absolute pseudoprimes)’라고 합니다.</string>
    <string name="PrimalityTest64">카마이클 수를 작은 것부터 차례로 나열한 것이 아래의 그림으로, 많지 않다는 것을 알 수 있습니다.</string>
    <string name="PrimalityTest65">소수가 페르마 테스트에 모두 부합되는 것은 맞지만, 페르마 테스트를 모두 만족한다고 해서 해당 수가 소수라고 단언할 수 없습니다.</string>
    <string name="PrimalityTest66">어디까지나 페르마 테스트는 확률적인 소수 판별법입니다.</string>
    <string name="PrimalityTest67">하지만 다른 효율적인 판별법이 없어서 많은 곳에서 사용되고 있습니다.</string>
    <string name="PrimalityTest68">이것으로 소수 판별법에 대한 설명을 마칩니다.</string>
    <string name="PrimalityTest7">3599의 제곱근은 59.99…이므로 2부터 59까지의 숫자를 차례대로 mod 연산을 하면 됩니다.</string>
    <string name="PrimalityTest8">실제로 mod 연산을 해보면 3599가 59로 완전히 나누어진다는 것을 알 수 있습니다.</string>
    <string name="PrimalityTestDescription">소수 판별법에선 확률적 소수 판별법의 일종인 페르마 테스트를 다룹니다. 이 항목은 모든 알고리즘을 구매 후에 학습할 수 있습니다.</string>
    <string name="Queue">큐</string>
    <string name="Queue0">큐(Queue)는 데이터 구조의 하나입니다.</string>
    <string name="Queue1">큐는 ‘대기 행렬’이라고 불립니다. 명칭처럼 줄서 있는 행렬을 생각하면 이해하기 쉽습니다.</string>
    <string name="Queue10">이것으로큐에 대한 설명을 마칩니다.</string>
    <string name="Queue2">행렬에선 새롭게 온 사람이 가장 뒤에 서며 가장 앞에 있는 사람부터 순서대로 처리됩니다.</string>
    <string name="Queue3">큐에 데이터를 추가하면 가장 뒤에 추가됩니다.</string>
    <string name="Queue5">큐에 데이터를 추가하는 작업을 ‘엔큐(enqueue)’라고 합니다.</string>
    <string name="Queue6">큐에서 데이터를 꺼낼 때는가장 늦게 추가된 데이터부터 꺼냅니다.</string>
    <string name="Queue8">큐에서 데이터를 꺼내는 작업을 ‘디큐(dequeue)’라고 합니다.</string>
    <string name="Queue9">먼저 넣은 것을 먼저 꺼내는 구조를 ‘First In First Out’이라고 하며 앞 글자만 따서 ‘FIFO’라고도 합니다.</string>
    <string name="QuickSort">퀵 정렬</string>
    <string name="QuickSort0">퀵 정렬은 수열을 정렬하는 알고리즘 중 하나입니다.</string>
    <string name="QuickSort1">다른 알고리즘에 비해 비교 및 교환 횟수가 적은 것이 특징으로 대부분의 경우 빠른 속도로 정렬할 수 있습니다.</string>
    <string name="QuickSort100">그러면 실제로 알고리즘의 과정을 보도록 하겠습니다.</string>
    <string name="QuickSort101">알기 쉽게 피봇에 마커를 표시합니다.</string>
    <string name="QuickSort102">계속해서 가장 왼쪽 수에 왼쪽 마커, 오른쪽 수에 오른쪽 마커를 표시합니다.</string>
    <string name="QuickSort103">퀵 정렬은 이 마커들을 사용해서 일련의 작업을 재귀적으로 반복하는 알고리즘입니다.</string>
    <string name="QuickSort105">이와 같이 왼쪽 마커의 역할은 피봇 이상인 수를 발견하는 것이고 오른쪽 마커의 역할은 피봇보다 작은 수를 발견하는 것입니다.</string>
    <string name="QuickSort106">숫자를 바꾸므로 수열의 왼쪽에 피봇보다 작은 수, 오른쪽에 피봇 이상인 수를 모을 수 있습니다.</string>
    <string name="QuickSort107">이것으로 첫 작업이 완료됩니다.</string>
    <string name="QuickSort11">4 &lt; 6이므로 정지합니다.</string>
    <string name="QuickSort12">좌우 마커가 멈춘 시점에 마커의 숫자를 교체합니다.</string>
    <string name="QuickSort13">교체한 후에는 다시 왼쪽 마커를 오른쪽으로 이동합니다.</string>
    <string name="QuickSort14">앞서 본 것처럼 왼쪽 마커는 피봇 숫자보다 이상인 수에 도달하면 멈춥니다.</string>
    <string name="QuickSort18">9 >=6 이므로 정지합니다.</string>
    <string name="QuickSort19">계속해서 오른쪽 마커</string>
    <string name="QuickSort2">처음 작업 대상은 모든 숫자입니다.</string>
    <string name="QuickSort21">오른쪽 마커가 왼쪽 마커와 만날 때도 동작을 멈춥니다.</string>
    <string name="QuickSort22">좌우 마커가 정지했을 때 동일한 위치인 경우 해당 수를 피봇 수와 교체합니다.</string>
    <string name="QuickSort23">좌우 마커가 있는 수를 정렬 완료 상태로 둡니다.</string>
    <string name="QuickSort24">일련에 작업에 의해 수열을…</string>
    <string name="QuickSort25">",피봇의 왼쪽에는 '피봇보다 작은 수'로"</string>
    <string name="QuickSort26">"피봇의 오른쪽에는 '피봇보다 큰 수'로 나눌 수 있습니다."</string>
    <string name="QuickSort27">둘로 나누어진 수열에 대해 일련의 작업을 재귀적으로 반복합니다.</string>
    <string name="QuickSort28">다음은 왼쪽에 있는 수열을 작업 대상으로 합니다.</string>
    <string name="QuickSort29">세 개의 마커를 표시합니다.</string>
    <string name="QuickSort3">정렬 기준이 되는 숫자를 하나 선택합니다. 이 숫자를 피봇(pivot)이라고 부릅니다.</string>
    <string name="QuickSort30">동일한 방법으로 작업을 진행합니다.</string>
    <string name="QuickSort4">왼쪽 마커를 오른쪽으로 이동합니다.</string>
    <string name="QuickSort40">일련의 작업이 끝나면…</string>
    <string name="QuickSort41">"피봇의 왼쪽에는 '피봇보다 작은 수'로"</string>
    <string name="QuickSort42">"피봇의 오른쪽에는 '피봇보다 큰 수'로 나눌 수 있습니다."</string>
    <string name="QuickSort43">다시 재귀적으로 위의 작업을 반복합니다.</string>
    <string name="QuickSort44">왼쪽에 있는 수열을 작업 대상으로 합니다.</string>
    <string name="QuickSort45">대상 수열의 수가 하나인 경우 정렬이 완료됩니다.</string>
    <string name="QuickSort47">두 번째 작업에서 나누어진 수열의 오른쪽을 작업 대상으로 합니다.</string>
    <string name="QuickSort48">세 개의 마커를 표시합니다.</string>
    <string name="QuickSort49">왼쪽 마커를 오른쪽으로 이동합니다.</string>
    <string name="QuickSort50">왼쪽 마커가 오른쪽 마커와 만나도 멈추지 않습니다. 이것은 오른쪽 마커의 움직임과 다릅니다.</string>
    <string name="QuickSort51">왼쪽 마커는 작업 대상 수열의 오른쪽 끝에 도달하면 멈춥니다.</string>
    <string name="QuickSort52">이때 작업 대상 범위 내에서 피봇인 수가 가장 큰 수가 됩니다.</string>
    <string name="QuickSort53">다음은 오른쪽 마커를 이동하지만 왼쪽 마커에 추월당한 경우에는 움직이지 않고 종료합니다.</string>
    <string name="QuickSort54">왼쪽 마커가 작업 대상의 오른쪽 끝에 도달한 경우, 피봇 수를 정렬 완료 상태로 두고 일련의 작업을 종료합니다.</string>
    <string name="QuickSort55">이후로는 동일할 작업을 모든 수가 정렬 완료 상태가 될 때까지 반복하면 됩니다.</string>
    <string name="QuickSort6">왼쪽 마커가 피봇 수 이상인 수에 도착하면 멈춥니다.</string>
    <string name="QuickSort7">8 >= 6 이므로 정지합니다.</string>
    <string name="QuickSort8">계속해서 오른쪽 마커를 왼쪽으로 이동합니다.</string>
    <string name="QuickSort83">모든 수가 정렬 완료 상태가 됐습니다.</string>
    <string name="QuickSort84">이것으로 퀵 정렬의 설명을 마칩니다.</string>
    <string name="QuickSort9">오른쪽 마커는 피봇보다 작은 숫자에 도달하면 멈춥니다.</string>
    <string name="QuickSort99">피봇은 보통 하나의 숫자를 랜덤으로 선택한 것입니다. 여기서는 편의상 항상 가장 오른쪽에 있는 수를 피봇으로 선택하고 있습니다.</string>
    <string name="QuickSortDescription">퀵 정렬은 데이터 비교와 교환 횟수가 적은 것이 특징입니다. 이 항목은 모든 알고리즘을 구매 후에 학습할 수 있습니다.</string>
    <string name="Random">무작위</string>
    <string name="RateThisApp">앱을 평가하기</string>
    <string name="RecursionSection">재귀</string>
    <string name="Restore">구매 기록 복원</string>
    <string name="RestoreAlert">구매 기록이 확인돼서 복원합니다. 이 과정에서 과금은 발생하지 않습니다.</string>
    <string name="RestoreBuyingLog">구매 기록 복원하기</string>
    <string name="RestoreSuccessed">구매 기록 복원을 완료했습니다.</string>
    <string name="Reversed">역</string>
    <string name="ReviewConfirmation">AppStore 열기</string>
    <string name="ReviewConfirmationAndroid">Google Play를 엽니다.</string>
    <string name="RunLength">연속길이 부호(Run Length Encrypt)</string>
    <string name="RunLength0">5x5 칸에 세 가지 색을 이용해 그린 그림을 부호화해보겠습니다.</string>
    <string name="RunLength1">먼저 단순한 기법을 사용해보겠습니다.</string>
    <string name="RunLength10">"이 작업은 '압축'과 반대되는 개념으로 '해제'라고 합니다."</string>
    <string name="RunLength11">데이터 중에는 연속길이 부호에 적합한 것과 그렇지 않은 것이 있습니다.</string>
    <string name="RunLength12">부호화된 것을 자세히 보면, 전체 문자 수가 줄었지만…</string>
    <string name="RunLength13">같은 색이 연속되지 않는 부분에서는 연속길이 부호화 후에 오히려 문자 수가 늘어났습니다.</string>
    <string name="RunLength14">예를 들어 그림과 같이 데이터 연속성이 부족한 것을 연속길이 부호화하면…</string>
    <string name="RunLength15">부호가 원래보다 50배 늘어나게 됩니다.</string>
    <string name="RunLength16">반대로 그림처럼 데이터 연속성이 있는 것을 부호화하면…</string>
    <string name="RunLength17">부호가 10 문자가 됩니다. 원래의 25 문자와 비교하면 압축률이 꽤 높은 것을 알 수 있습니다.</string>
    <string name="RunLength18">이처럼 연속길이 부호는 부호화 대상에 따라 압축 효과가 있을 수도 있고 없을 수도 있습니다.</string>
    <string name="RunLength19">이 때문에 데이터가 일정 수 이상 연속되는 경우에만 연속길이 부호화하는 등의 고민이 필요합니다.</string>
    <string name="RunLength2">세 가지 색에 각각 Y(Yellow), G(Green), B(blue) 라는 문자를 부여했습니다.</string>
    <string name="RunLength20">연속길이 부호의 사용 예로 흑백 팩스를 생각해보겠습니다.</string>
    <string name="RunLength21">그림의 도형을 팩스를 통해 보내려고 할 때, 단순히 각 칸을 W(White), B(Black)이라는 글자로 표현하면 25 문자가 됩니다.</string>
    <string name="RunLength22">통신량을 줄이기 위해 연속길이 부호화로 데이터를 압축합니다.</string>
    <string name="RunLength23">부호화 결과 1 문자 늘어서 26 문자가 됩니다. 이 경우는 연속길이 부호를 이용하는 의미가 없습니다.</string>
    <string name="RunLength24">하지만 흑백 사진에서 사용되는 것은 흰색과 검정색 두 가지 색밖에 없습니다.</string>
    <string name="RunLength25">따라서 흰색 칸이 연속된 후에 나오는 것은 검정색 칸으로 정해져 있습니다.</string>
    <string name="RunLength26">W와 B라는 문자가 없어도 부호로부터 도형을 복원할 수 있을 듯합니다.</string>
    <string name="RunLength27">W와 B라는 문자를 제거하면 13 문자가 돼서 크기가 반정도로 줄어듭니다.</string>
    <string name="RunLength28">단, 부호의 첫 번째 숫자는 흰색 칸이 연속되는 수라는 것을 규칙으로 정할 필요가 있습니다.</string>
    <string name="RunLength29">이 규칙이 있으면 부호로부터 원 이미지를 제대로 복원할 수 있습니다.</string>
    <string name="RunLength3">도형의 왼쪽 상단을 기점으로 해서 한 줄씩 Y, G, B 문자로 변환한 결과 도형을 25문자로 부호화할 수 있습니다.</string>
    <string name="RunLength30">그러면 다음과 같은 그림을 부호화하려면 어떻게 하면 좋을까요?</string>
    <string name="RunLength31">앞서 본 것과 달리 그림의 첫 번째 칸이 흰색이 아닌 검정색입니다.</string>
    <string name="RunLength32">일단 동일한 방법으로 부호화해보았습니다.</string>
    <string name="RunLength33">부호의 첫 번째 수자는 검정색 칸이 연속된 수를 나타내고 있지만…</string>
    <string name="RunLength34">"부호의 첫 번째 숫자는 흰색 칸이 연속된 수'라는 규칙을 지키고 있지 않습니다."</string>
    <string name="RunLength35">그대로 복원하면 흰색과 검정색이 바뀐 그림이 됩니다.</string>
    <string name="RunLength36">부호의 첫 번째 숫자는 흰색 칸이 연속된 수라는 규칙을 지키려면 부호의 선두에 0을 추가했습니다.</string>
    <string name="RunLength37">도형의 첫 번째 칸이 0이라는 것은 흰색 칸이 없다는 의미가 됩니다.</string>
    <string name="RunLength38">선두에 0을 추가하므로 문자 수는 하나 늘었지만 정해진 규칙에 의해 데이터를 압축할 수가 있습니다.</string>
    <string name="RunLength39">연속길이 부호는 일반적으로 데이터의 연속성이 빈약한 텍스트보다 이미지 데이터의 압축에 적합합니다.</string>
    <string name="RunLength4">다음은 그림을 연속길이 부호화해서 25 문자보다 적은 문자 수로 표현해보도록 하겠습니다.</string>
    <string name="RunLength40">어느 경우 등 높은 압축 효과를 얻기 위한 고민이 필요합니다.</string>
    <string name="RunLength41">이것으로 연속길이 부호에 대한 설명을 마치겠습니다.</string>
    <string name="RunLength5">연속길이 부호는, 부호와 그것이 연속된 횟수를 한 세트로 해서 부호화하는 기법입니다.</string>
    <string name="RunLength6">"예를 들어 첫 부분의 'YYYY'는 'Y4'로 표현해서 두 개의 문자로 표현할 수 있습니다."</string>
    <string name="RunLength7">동일한 작업을 반복해서 연속길이 부호화를 완료했습니다.</string>
    <string name="RunLength8">결과적으로 5 문자가 적은 20 문자로 압축됐습니다.</string>
    <string name="RunLength9">그림이 한 줄에 다섯 칸으로 돼있다는 정보를 알고 있으면, 부호로부터 그림을 복원해낼 수 있습니다.</string>
    <string name="SecurityBase">암호의 기본</string>
    <string name="SecurityBase0">현재 인터넷 사회에서 암호 기술은 필수 기술이 되고 있습니다.</string>
    <string name="SecurityBase1">A가 B에게 인터넷을 경유해서 데이터를 전달하려고 합니다.</string>
    <string name="SecurityBase10">데이터를 암호화해두면 설령 악의를 지닌 제삼자가 훔쳐본다고 해도 안심할 수 있습니다.</string>
    <string name="SecurityBase11">지금까지 본 것처럼 현대 인터넷 사회에선 암호화 기술이 매우 중요합니다.</string>
    <string name="SecurityBase12">암호화란 구체적으로 어떤 처리를 의미하는 것일까요?</string>
    <string name="SecurityBase13">컴퓨터는 모든 데이터를 0과 1로 구성되는 2진수로 관리합니다.</string>
    <string name="SecurityBase14">데이터에는 텍스트, 음악, 사진 등 다양한 형식이 있지만</string>
    <string name="SecurityBase15">컴퓨터 내에선 모든 데이터가 2진수로 관리되고 있습니다.</string>
    <string name="SecurityBase150">여기선 암호 기술의 필요성, 데이터는 숫자로 관리된다는 것, 암호화란 수치 계산이라는 것 등을 설명했습니다.</string>
    <string name="SecurityBase16">이 내용을 바탕으로 데이터 암호화에 대해 생객하보도록 하겠습니다.</string>
    <string name="SecurityBase17">데이터는 컴퓨터에게 있어 의미를 지닌 숫자들의 나열입니다.</string>
    <string name="SecurityBase18">암호문도 숫자의 나열로 관리되고 있지만 컴퓨터가 해석할 수 없는 임의의 숫자로 구성돼 있습니다.</string>
    <string name="SecurityBase19">암호화란 데이터에 어떤 연산을 적용해서 컴퓨터가 해석할 수 없는 숫자를 변경하는 것을 의미합니다</string>
    <string name="SecurityBase2">데이터는 인터넷상의 다양한 네트워크나 장비를 통해서 B에게 전달됩니다.</string>
    <string name="SecurityBase20">암호화의 수치 계산에선 ‘키’를 이용합니다.</string>
    <string name="SecurityBase21">키도 숫자로 만들어집니다.</string>
    <string name="SecurityBase22">즉, 암호화 키를 이용한 수치 계산을 통해 데이터의 내용을 제삼자가 해석할 수 없도록 변환하는 것입니다</string>
    <string name="SecurityBase23">반대로 복호화란 키를 이용한 수치 계산을 통해 암호문을 원 데이터로 복원하는 것입니다.</string>
    <string name="SecurityBase24">예로 데이터와 키를 그림에 있는 값으로 하고, 계산 방법을 XOR로 했을 때의 구체적인 과정을 보겠습니다.</string>
    <string name="SecurityBase25">XOR(비배타적 논리합)이란 그림의 진리값 표를 이용해 연산하는 것입니다.</string>
    <string name="SecurityBase26">XOR에선 그림의 식이 성립하는 것이 특징입니다.</string>
    <string name="SecurityBase27">,즉, 어떤 값 A와 어떤 값 B를 XOR로 계산한 결과가 C라고 하면…</string>
    <string name="SecurityBase28">C에 대해 A나 B를 다시 XOR로 계산하면 다른 한 쪽의 값을 얻을 수 있다는 것을 의미합니다.</string>
    <string name="SecurityBase29">데이터에 대해 키를 이용해서 XOR을 계산하면…</string>
    <string name="SecurityBase3">따라서 데이터를 그냥 전달하려고 하면…</string>
    <string name="SecurityBase30">이런 암호문을 얻을 수 있습니다.</string>
    <string name="SecurityBase31">이번에는 암호문을 복호화해보겠습니다.</string>
    <string name="SecurityBase32">암호문에 대해 다시 키를 이용해서 XOR 계산을 하면…</string>
    <string name="SecurityBase33">원 데이터를 얻을 수 있습니다.</string>
    <string name="SecurityBase34">이처럼 XOR이라는 계산 방법을 이용한 암호에선 암호화와 복호화에 동일한 키를 사용하게 됩니다.</string>
    <string name="SecurityBase35">이것으로 암호의 기본에 대한 설명을 마칩니다.</string>
    <string name="SecurityBase4">악의를 지닌 제삼자가 데이터를 훔쳐볼 가능성이 있습니다.</string>
    <string name="SecurityBase5">이 때문에 비밀로 하고 싶은 데이터는 암화화해서 전송할 필요가 있습니다.</string>
    <string name="SecurityBase6">암호화한 데이터를 ‘암호문’이라고 합니다.</string>
    <string name="SecurityBase7">암호문을 B에게 전송합니다.</string>
    <string name="SecurityBase8">B는 A에게서 받은 암호문의 암호를 해제하고 원 데이터를 얻습니다.</string>
    <string name="SecurityBase9">암호문을 원 데이터로 복원하는 것을 ‘복호’라고 합니다.</string>
    <string name="SecurityBasic">보안의 기본</string>
    <string name="SecurityBasic0">인터넷을 경유해서 데이터를 전달할 때 데이터는 다양한 네트워크나 장비를 경유해서 목적지에 도달하게 됩니다.</string>
    <string name="SecurityBasic1">따라서 인터넷을 안전하게 사용하기 위해서는 보안 기술이 필수 불가결이 되고 있습니다.</string>
    <string name="SecurityBasic10">"이 문제를 '위장'이라고 합니다."</string>
    <string name="SecurityBasic11">A가 B에게 메시지 전송을 확실하게 완료했다고 해도…</string>
    <string name="SecurityBasic12">도중에 X가 메시지 내용을 변경했을 가능성이 있습니다.</string>
    <string name="SecurityBasic13">이 문제를 ‘변조(falsification)’이라고 합니다.</string>
    <string name="SecurityBasic14">3자가 의도적으로 변조한 것 외에도 통신상의 장애로 인해 데이터가 망가진 상태로 전달될 수도 있습니다.</string>
    <string name="SecurityBasic15">B가 A에게서 메시지를 받았다고 생각하지만…</string>
    <string name="SecurityBasic16">메시지의 전송자인 A가 악의를 지닌 경우…</string>
    <string name="SecurityBasic17">나중에 A가 ‘그건 내가 보낸 게 아니야’하고 부인할 가능성이 있습니다.</string>
    <string name="SecurityBasic18">이런 경우에는 인터넷상에서의 상거래나 계약 행위 등이 성립하지 않게 됩니다.</string>
    <string name="SecurityBasic19">이 문제를 ‘사후 부인’이라고 합니다.</string>
    <string name="SecurityBasic2">먼저 인터넷에서 데이터를 주고 받을 때에 발생할 수 있는 대표적인 문제 네 가지를 소개하도록 하겠습니다</string>
    <string name="SecurityBasic20">대표적인 네 가지 문제를 소개했습니다.</string>
    <string name="SecurityBasic21">이 문제들은 사람 사이에서만 발생하는 것이 아니라 웹사이트를 열람하는 경우에도 동일하게 발생할 수 있습니다.</string>
    <string name="SecurityBasic22">위와 같은 문제들을 해결하기 위해선 어떤 보안 기술들이 존재하는지 각 문제들에 대처할 수 있는 기술을 보도록 하겠습니다.</string>
    <string name="SecurityBasic23">첫 번째 문제인 ‘도청’을 방지하기 위해서는 ‘암호화’기술을 사용합니다.</string>
    <string name="SecurityBasic24">"두 번째 문제인 ‘위장’을 방지하기 위해서는 ‘메시지 인증 코드'나…"</string>
    <string name="SecurityBasic25">‘전자 서명’ 기술을 사용합니다.</string>
    <string name="SecurityBasic26">세 번째 문제인 ‘변조’을 방지하는 경우에도 ‘메시지 인증 코드’나 …</string>
    <string name="SecurityBasic27">‘전자 서명’ 기술을 사용합니다.</string>
    <string name="SecurityBasic28">이 ‘전자 서명’ 기술은 네 번째 문제인 ‘사후 부인’에도 도움이 됩니다.</string>
    <string name="SecurityBasic29">정리하면 다음 표와 같습니다.</string>
    <string name="SecurityBasic3">A가 B에게 메시지를 전송할 때에…</string>
    <string name="SecurityBasic30">참고로 ‘전자 서명’ 기술에서 문제가 되는 ‘공개키의 소유자를 식별할 수 없는 문제’를 해결 하기 위해 ‘전자 서명서’라는 기술도 사용합니다.</string>
    <string name="SecurityBasic31">이 앱에선 각각의 보안 기술에 대해 자세히 다루고 있습니다.</string>
    <string name="SecurityBasic32">이것으로 보안의 기초에 대한 설명을 마칩니다.</string>
    <string name="SecurityBasic4">경로 상에 있는 X가 메시지 내용을 훔쳐볼 가능성이 있습니다</string>
    <string name="SecurityBasic5">이 문제를 ‘도청(interception)’이라고 합니다.</string>
    <string name="SecurityBasic6">A가 B에게 메시지를 전달했다고 생각하지만…</string>
    <string name="SecurityBasic7">X가 B로 위장했을 가능성이 있습니다.</string>
    <string name="SecurityBasic8">반대로 B가 A에게 메시지를 받았다고 생각하지만…</string>
    <string name="SecurityBasic9">X가 A로 위장했을 가능성도 있습니다.</string>
    <string name="SecuritySection">보안</string>
    <string name="SelectionSort">선택 정렬</string>
    <string name="SelectionSort0">선택 정렬은 수열을 정렬하는 알고리즘 중 하나입니다.</string>
    <string name="SelectionSort1">수열을 선형 탐색해서 최솟값을 찾습니다. 선형 탐색에 대해선 이 앱에서 자세히 설명하고 있습니다.</string>
    <string name="SelectionSort2">최솟값을 열의 왼쪽 끝에 있는 숫자와 교환하고 정렬을 완료합니다.</string>
    <string name="SelectionSort3">참고로 최솟값이 이미 왼쪽 끝에 있으면 아무런 작업도 하지 않습니다.</string>
    <string name="SelectionSort4">동일한 작업을 모든 숫자가 정렬을 마칠 때까지 반복합니다.</string>
    <string name="SelectionSort6">정렬을 완료했습니다.</string>
    <string name="SelectionSort7">이것으로 선택 정렬에 대한 설명을 마치겠습니다.</string>
    <string name="Setting">설정</string>
    <string name="SettingNotShowUnreadButtons">읽지 않은 자국</string>
    <string name="Share">앱 평가 및 공유</string>
    <string name="ShareOnFacebook">페이스북에 공유하기</string>
    <string name="ShareOnTwitter">트위터에 공유하기</string>
    <string name="Shuffle">섞기</string>
    <string name="SortSection">정렬</string>
    <string name="Stack">스택</string>
    <string name="Stack0">스택(Stack)은 데이터 구조의 하나입니다.</string>
    <string name="Stack1">스택은 물건을 세로로 쌓는다고 생각하면 이해하기 쉽습니다.</string>
    <string name="Stack10">이것으로 스택에 대한 설명을 마칩니다.</string>
    <string name="Stack2">쌓여있는 물건들 중에서 하나를 꺼내려면 위에서부터 차례로 꺼내야 합니다.</string>
    <string name="Stack3">스택에 데이터를 추가할 때는 가장 위에 추가됩니다.</string>
    <string name="Stack5">스택에 데이터를 추가하는 작업을 ‘푸쉬(push)’라고 합니다.</string>
    <string name="Stack6">스택에서 데이터를 꺼내는 경우 가장 위, 즉 가장 최근에 추가된 데이터부터 꺼냅니다.</string>
    <string name="Stack8">스택에서 데이터를 꺼내는 작업을 ‘팝(pop)’이라고 합니다.</string>
    <string name="Stack9">스택처럼 나중에 넣은 것을 먼저 꺼내는 구조를 ‘Last In First Out’이라고 하며 앞 글자만 따서 ‘LIFO’라고도 합니다.</string>
    <string name="ThankYouForUnlocking">"모든 알고리즘을 구매해주셔서 감사합니다. '알고리즘 도감'과 즐거운 시간 되세요."</string>
    <string name="ToSendUs">"오류나 건의 사항은 '의견 및 건의 사항' 메뉴를 이용해주세요."</string>
    <string name="Unlock">모든 알고리즘 구매</string>
    <string name="UnlockSuccessed">알고리즘 구매를 완료했습니다.</string>
    <string name="WEB">웹</string>
    <string name="YouCanLearnAfter">「%@」는 모든 알고리즘을 구매한 후에 학습할 수 있습니다.</string>
    <string name="YouCanLearnAfterAndroid">「%s」는 모든 알고리즘을 구매 후에 학습할 수 있습니다.</string>
    <string name="YouCanRestore">이미 모든 알고리즘을 구매한 경우에는 구매 기록을 복원하면 다시 모든 항목을 열람할 수 있습니다.</string>
    <string name="abc_action_bar_home_description">홈 탐색</string>
    <string name="abc_action_bar_up_description">위로 탐색</string>
    <string name="abc_action_menu_overflow_description">옵션 더보기</string>
    <string name="abc_action_mode_done">완료</string>
    <string name="abc_activity_chooser_view_see_all">전체 보기</string>
    <string name="abc_activitychooserview_choose_application">앱 선택</string>
    <string name="abc_capital_off">사용 안함</string>
    <string name="abc_capital_on">사용</string>
    <string name="abc_search_hint">검색...</string>
    <string name="abc_searchview_description_clear">검색어 삭제</string>
    <string name="abc_searchview_description_query">검색어</string>
    <string name="abc_searchview_description_search">검색</string>
    <string name="abc_searchview_description_submit">검색어 보내기</string>
    <string name="abc_searchview_description_voice">음성 검색</string>
    <string name="abc_shareactionprovider_share_with">공유 대상</string>
    <string name="abc_shareactionprovider_share_with_application">%s와(과) 공유</string>
    <string name="abc_toolbar_collapse_description">접기</string>
    <string name="app_name">알고리즘 도감</string>
    <string name="en">영어</string>
    <string name="es">스페인어</string>
    <string name="goal">골</string>
    <string name="ja">일본어</string>
    <string name="ko">한국</string>
    <string name="min">최소</string>
    <string name="pt">포르투갈어</string>
    <string name="ru">러시아어</string>
    <string name="search">수색</string>
    <string name="search_menu_title">검색</string>
    <string name="status_bar_notification_info_overflow">999+</string>
    <string name="zh">중국어 (간체)</string>
</resources>
